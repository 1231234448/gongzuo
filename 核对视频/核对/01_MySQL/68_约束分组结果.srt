1
00:00:00,000 --> 00:00:01,114
< No Speech >

2
00:00:01,114 --> 00:00:07,194
上节课我们讲解了如何在葛肉拜子句当中对多列进行分组

3
00:00:07,234 --> 00:00:13,834
那么这节课我们再来讲解一下如何在葛肉拜子句当中约束分组结果

4
00:00:13,834 --> 00:00:16,274
那么什么是约束分组结果

5
00:00:16,274 --> 00:00:17,594
我们来看这个图

6
00:00:17,754 --> 00:00:20,674
在这个图当中他所完成的查询是什么

7
00:00:20,674 --> 00:00:21,954
我们来看一下

8
00:00:22,274 --> 00:00:26,794
它是计算每个部门的最大薪水

9
00:00:27,034 --> 00:00:27,674
对吧

10
00:00:27,674 --> 00:00:31,034
那么如果仅是计算每个部门的最大薪水

11
00:00:31,034 --> 00:00:33,274
对于这样的查询是非常好实现的

12
00:00:33,474 --> 00:00:36,394
葛肉拜对departmentid做分组

13
00:00:36,434 --> 00:00:40,754
然后用max去求salary的最大值不就可以了吗

14
00:00:40,794 --> 00:00:41,194
对吧

15
00:00:41,194 --> 00:00:42,194
这是很简单的

16
00:00:42,234 --> 00:00:44,074
但是他有要求什么要求

17
00:00:44,514 --> 00:00:51,954
返回大于也就是说他的最大薪水是大于1万的这样的结果

18
00:00:52,634 --> 00:00:57,034
那么也就是说现在他要的结果集并不是分完组以后

19
00:00:57,034 --> 00:01:00,114
并且求完每组最大薪水的这些结果集了

20
00:01:00,274 --> 00:01:04,394
他要对这些结果集再去做数据过滤了

21
00:01:04,474 --> 00:01:05,034
是不是

22
00:01:05,034 --> 00:01:07,354
那么数据过滤的条件是什么

23
00:01:07,714 --> 00:01:12,674
是他们的最大薪水要大于1万的那些数据

24
00:01:13,354 --> 00:01:17,874
那么这又涉及到对结果集的对分组完的数据做结果约束了

25
00:01:17,874 --> 00:01:18,554
对不对

26
00:01:19,234 --> 00:01:21,554
如果对于这样的需求我们该怎么实现的

27
00:01:21,594 --> 00:01:24,354
这里我们就要用到having子句了

28
00:01:24,354 --> 00:01:32,514
因为having子句的作用就是对分组以后的数据再去做数据过滤的

29
00:01:32,954 --> 00:01:34,314
这是having子句的一个作用

30
00:01:34,874 --> 00:01:35,074
好

31
00:01:35,074 --> 00:01:35,914
我们来看一下

32
00:01:36,274 --> 00:01:44,434
having子句是对查询出结果集分组后的结果再去进行过滤的一个子句

33
00:01:44,434 --> 00:01:45,314
好

34
00:01:45,314 --> 00:01:48,314
它的作用就是来约束分组结果的

35
00:01:48,514 --> 00:01:53,154
用well子句约束选择的行用having子句约束组

36
00:01:53,154 --> 00:01:57,234
同学们这两个子句千万不要搞混淆了

37
00:01:57,234 --> 00:02:02,834
虽然他们的作用都是作数据过滤的

38
00:02:02,834 --> 00:02:10,874
但是他们对数据过滤的方式上或者是位置上是有截然不同的

39
00:02:11,314 --> 00:02:16,154
well子句是在查询时对行的过滤的一个子句

40
00:02:16,354 --> 00:02:21,834
而having子句是对分组后的数据再去做数据过滤的

41
00:02:21,834 --> 00:02:24,394
如果不是分组的话我们不能用having子句

42
00:02:24,834 --> 00:02:25,674
明白这意思吧

43
00:02:25,674 --> 00:02:32,114
也就是说我们不可以使用well子句对分组做数据过滤

44
00:02:32,114 --> 00:02:37,474
同样我们也不能使用having子句去对行选择做数据过滤

45
00:02:38,114 --> 00:02:38,714
明白这意思吧

46
00:02:38,714 --> 00:02:41,074
同学们这是这两个子句的一个区别

47
00:02:41,234 --> 00:02:42,594
千万不要搞混淆了

48
00:02:43,154 --> 00:02:43,754
好

49
00:02:43,754 --> 00:02:46,474
为了找到每个部门中最高薪水

50
00:02:46,474 --> 00:02:50,074
而且只显示最高薪水大于1万的那些部门

51
00:02:50,074 --> 00:02:51,874
可以像下面这样做

52
00:02:51,874 --> 00:02:54,714
一用部门号分组

53
00:02:54,714 --> 00:02:55,234
是吧

54
00:02:55,234 --> 00:02:55,914
grow by

55
00:02:55,914 --> 00:02:57,434
然后departmentid分组

56
00:02:57,434 --> 00:03:00,994
在每个部门当中找到最大薪水一个max函数去做

57
00:03:00,994 --> 00:03:03,274
对salary列去找最大薪水就可以了

58
00:03:03,274 --> 00:03:03,714
对吧

59
00:03:03,714 --> 00:03:09,754
二返回那些最高薪水大于1万的部门的雇员的部门

60
00:03:09,754 --> 00:03:12,634
那么第二点在实现时我们就要用到having子句了

61
00:03:12,634 --> 00:03:12,994
对不对

62
00:03:12,994 --> 00:03:14,274
我们来看实现

63
00:03:14,274 --> 00:03:17,154
slack显示departmentid

64
00:03:17,154 --> 00:03:18,394
然后max salary

65
00:03:18,394 --> 00:03:20,234
这是对薪水求最大值对吧

66
00:03:20,234 --> 00:03:21,834
然后from安排一表

67
00:03:21,834 --> 00:03:23,634
那要对谁的薪水求最大值

68
00:03:23,634 --> 00:03:25,150
grow by

69
00:03:25,150 --> 00:03:26,906
< No Speech >

70
00:03:26,906 --> 00:03:28,946
是不是按部门ID分组

71
00:03:28,946 --> 00:03:31,306
这等于求出每个部门的最大薪水了

72
00:03:31,306 --> 00:03:31,826
对不对

73
00:03:31,826 --> 00:03:34,306
但是我现在要的不是每个部门最大

74
00:03:34,306 --> 00:03:35,626
薪水的所有的结果集

75
00:03:35,626 --> 00:03:39,146
我要的是满足那些最大薪水大于1万的

76
00:03:39,146 --> 00:03:39,826
怎么办呢

77
00:03:39,826 --> 00:03:42,306
我们要在getofferby的后面再加一个

78
00:03:42,306 --> 00:03:45,986
having子句来给定对分组数据的一个

79
00:03:45,986 --> 00:03:46,706
顾虑的条件

80
00:03:46,706 --> 00:03:48,106
那么什么条件呢

81
00:03:48,106 --> 00:03:49,786
他的最大薪水

82
00:03:49,786 --> 00:03:52,186
那么求最大薪水是不是仍然得用max

83
00:03:52,186 --> 00:03:52,666
对吧

84
00:03:52,666 --> 00:03:56,306
然后salary最大薪水大于1万的

85
00:03:56,306 --> 00:04:00,186
那么这样所返回的数据就是求出每个

86
00:04:00,186 --> 00:04:03,226
部门最大薪水并且最大薪水大于1万的

87
00:04:03,226 --> 00:04:05,106
那些雇员的信息

88
00:04:05,106 --> 00:04:06,266
< No Speech >

89
00:04:06,266 --> 00:04:11,706
明白这些吧同学们 这是用having子句来对分组数据做数据过滤的

90
00:04:11,706 --> 00:04:15,226
好 我们再来看一下having子句的语法

91
00:04:15,226 --> 00:04:18,346
我们在使用having约束分组时

92
00:04:18,346 --> 00:04:20,946
首先第一我们好像得是被分组的

93
00:04:20,946 --> 00:04:23,586
也就是说我们如果不是分组的是不能用having子句的

94
00:04:23,586 --> 00:04:28,346
二应用主函数 我们在having子句当中是可以使用主函数的

95
00:04:28,346 --> 00:04:29,946
主函数不就指的是聚合函数吗

96
00:04:29,946 --> 00:04:33,066
你看这个例子当中不就是在having子句当中

97
00:04:33,066 --> 00:04:37,546
通过max函数去求最大薪水 然后来作为我的一个判断条件

98
00:04:37,546 --> 00:04:39,266
明白这些吧同学们

99
00:04:39,266 --> 00:04:43,266
然后最关键的一点就是having子句出现的位置

100
00:04:43,266 --> 00:04:47,066
having子句必须要出现在gp子句的后面

101
00:04:47,066 --> 00:04:50,426
因为它是对分组后的数据做数据过滤的

102
00:04:50,426 --> 00:04:54,346
所以它是出现在having子句的 出现在gp子句的后面

103
00:04:54,346 --> 00:04:58,506
明白吧 然后它是出现在gp子句的前面的

104
00:04:58,506 --> 00:05:03,186
只有having子句对数据过滤完了 我们才能去做排序处理

105
00:05:03,186 --> 00:05:05,186
排序处理是最后一步的

106
00:05:05,186 --> 00:05:08,626
明白这些吧同学们 这是having子句的语法

107
00:05:08,626 --> 00:05:10,946
好 那我们再来看一个实例

108
00:05:10,946 --> 00:05:18,546
实例要求显示那些合计薪水超过一万三的每个工作岗位的合计薪水

109
00:05:18,546 --> 00:05:21,022
排除那些较白级当中还有

110
00:05:21,594 --> 00:05:26,234
rep的工作岗位并且用合计月排序

111
00:05:26,234 --> 00:05:29,594
合计月息排序列表

112
00:05:29,594 --> 00:05:33,354
那么这个需求稍稍有那么一些复杂了

113
00:05:33,354 --> 00:05:34,074
但是不要紧

114
00:05:34,074 --> 00:05:35,514
我们一点点来分析

115
00:05:35,514 --> 00:05:37,434
他到底要查的是什么样的数据

116
00:05:37,434 --> 00:05:38,234
我们来看

117
00:05:38,674 --> 00:05:41,714
显示那些合计薪水超过13000的

118
00:05:42,274 --> 00:05:44,594
合计薪水就是sum薪水求和

119
00:05:44,754 --> 00:05:46,314
薪水求和超过13000的

120
00:05:46,314 --> 00:05:48,234
这肯定是一个最终的结果了

121
00:05:48,234 --> 00:05:48,834
对吧

122
00:05:48,834 --> 00:05:52,434
然后每个工作岗位的合计薪水

123
00:05:52,434 --> 00:05:53,034
注意看

124
00:05:53,034 --> 00:05:54,674
每个工作岗位

125
00:05:54,674 --> 00:05:56,594
也就是说我现在要求的结果

126
00:05:56,594 --> 00:05:58,914
是要工作按照工作岗位去分组了

127
00:05:58,914 --> 00:06:00,634
然后在工作岗位分组当中

128
00:06:00,634 --> 00:06:01,714
再去求合计薪水

129
00:06:01,714 --> 00:06:04,674
然后再去求这些分完组以后的结果

130
00:06:04,674 --> 00:06:06,394
它的合计薪水大于13000的

131
00:06:06,994 --> 00:06:07,514
对吧

132
00:06:07,514 --> 00:06:08,714
然后他又有条件了

133
00:06:08,714 --> 00:06:10,314
排除那些叫by的

134
00:06:10,314 --> 00:06:12,874
还有rep的工作岗位

135
00:06:12,874 --> 00:06:15,114
也就是说我在求这些工作岗位的

136
00:06:15,114 --> 00:06:16,354
合计薪水之前

137
00:06:16,674 --> 00:06:18,154
有条件什么条件

138
00:06:18,154 --> 00:06:19,954
jobid当中不能含有

139
00:06:19,954 --> 00:06:23,394
jobid当中必须要含有rep的工作岗位

140
00:06:23,834 --> 00:06:25,594
那这是不是得用val条件去做

141
00:06:25,594 --> 00:06:26,794
这个数据的过滤了

142
00:06:26,794 --> 00:06:27,394
对吧

143
00:06:27,394 --> 00:06:30,274
然后并且用合计月薪排序列表

144
00:06:30,274 --> 00:06:31,514
那就是一个order by子句

145
00:06:31,514 --> 00:06:32,514
对吧

146
00:06:32,514 --> 00:06:33,994
那么这样分析完以后

147
00:06:34,154 --> 00:06:35,114
我们就来实现一下

148
00:06:35,114 --> 00:06:36,314
看看该怎么去做

149
00:06:36,794 --> 00:06:37,954
我们一步一步的来

150
00:06:38,314 --> 00:06:39,394
先select

151
00:06:39,834 --> 00:06:41,154
然后from

152
00:06:41,354 --> 00:06:41,874
对吧

153
00:06:41,874 --> 00:06:42,954
from查哪个表

154
00:06:43,074 --> 00:06:44,154
我们需要的数据

155
00:06:44,154 --> 00:06:45,394
是不是都在unply1表

156
00:06:45,554 --> 00:06:47,154
所以from unply1就够了

157
00:06:47,154 --> 00:06:47,634
是吧

158
00:06:47,634 --> 00:06:48,874
然后注意看

159
00:06:48,914 --> 00:06:52,234
他查的是每个工作岗位的合计薪水

160
00:06:52,954 --> 00:06:55,434
我是不是得用groupby去对

161
00:06:55,434 --> 00:06:57,822
谁呀jobid做分组

162
00:06:58,714 --> 00:07:07,034
对吧同学们 但是他有条件排除那些jobid当中还有rep的工作岗位

163
00:07:07,034 --> 00:07:08,794
这里是不是用一个where了

164
00:07:08,794 --> 00:07:15,114
对吧 where什么 job一点jobid对吧

165
00:07:15,114 --> 00:07:20,074
怎么的呢 not like不能包含排除那些嘛

166
00:07:20,074 --> 00:07:22,194
排除那些jobid当中还有rep

167
00:07:22,194 --> 00:07:25,194
那就是不要jobid当中还有rep的

168
00:07:25,194 --> 00:07:30,194
not like什么呢 代研号 顺眼号都可以

169
00:07:30,194 --> 00:07:32,114
是不是百分号百号百分号

170
00:07:32,114 --> 00:07:33,342
然后rep

171
00:07:33,342 --> 00:07:35,354
< No Speech >

172
00:07:35,354 --> 00:07:35,914
对吧

173
00:07:35,914 --> 00:07:37,394
这是vr条件的过滤

174
00:07:37,394 --> 00:07:37,874
是吧

175
00:07:37,874 --> 00:07:38,834
然后呢

176
00:07:39,834 --> 00:07:47,314
他要什么显示那些合计薪水超过13000的每个工作岗位的合计薪水

177
00:07:47,314 --> 00:07:53,502
也就是说他分完组以后并不是要每个工作每个jobid的巨大薪水

178
00:07:54,202 --> 00:07:56,722
每个叫白地的合计薪水

179
00:07:56,722 --> 00:07:59,042
而是他们的合计薪水超过13000的

180
00:07:59,042 --> 00:08:03,882
那在grove bytes就后面是不是要加having做分组数据的过滤了

181
00:08:03,882 --> 00:08:04,362
对吧

182
00:08:04,362 --> 00:08:06,014
having什么呢

183
00:08:06,014 --> 00:08:07,162
< No Speech >

184
00:08:07,162 --> 00:08:09,162
求薪水合计 salary

185
00:08:09,162 --> 00:08:11,802
然后呢大于13000的

186
00:08:11,802 --> 00:08:14,174
是honghongparaAuto提高了23000

187
00:08:14,938 --> 00:08:17,418
对吧 同学们 然后他要什么 还有排序

188
00:08:17,418 --> 00:08:19,538
然后还有要什么排序

189
00:08:19,538 --> 00:08:23,978
看 并且用合计的月薪排序列表

190
00:08:23,978 --> 00:08:26,698
排序order by 是吧

191
00:08:26,698 --> 00:08:29,018
月薪的合计那就是sum salary

192
00:08:29,018 --> 00:08:31,938
合计就也不就是sum salary

193
00:08:31,938 --> 00:08:32,338
对吧

194
00:08:32,338 --> 00:08:33,338
然后他要什么

195
00:08:33,338 --> 00:08:34,618
< No Speech >

196
00:08:34,618 --> 00:08:35,058
是吧

197
00:08:35,058 --> 00:08:37,338
他要每个雇员的工作岗位

198
00:08:37,338 --> 00:08:41,018
那就是一点job id

199
00:08:41,018 --> 00:08:42,618
然后还有合计薪水

200
00:08:42,618 --> 00:08:44,138
那就是sum函数

201
00:08:44,138 --> 00:08:46,618
然后一点salary

202
00:08:46,618 --> 00:08:49,658
< No Speech >

203
00:08:49,658 --> 00:08:52,858
对吧同学们 这样就可以了 然后我们执行

204
00:08:52,858 --> 00:08:55,418
看到了吗 现在我们就查到了

205
00:08:55,418 --> 00:09:00,858
按照部门按照job id去分组 并且排除了那些

206
00:09:00,858 --> 00:09:04,938
这个job id含有rep的这样的数据 然后对他们做分组

207
00:09:04,938 --> 00:09:08,818
然后呢去算这些分组的薪水的合计

208
00:09:08,818 --> 00:09:13,054
并且最后排除那些薪水合计大于13000的

209
00:09:13,754 --> 00:09:18,314
包含那些薪水大于13000的低于13000或者等于13000的都不显示

210
00:09:18,314 --> 00:09:21,594
所以我们看现在有这么多条数据

211
00:09:21,594 --> 00:09:24,798
你看他们的薪水合计都是大于13000的

212
00:09:25,626 --> 00:09:30,586
明儿同学们,对于这样的需求,我们肯定要用到having子句对分组数据做过滤

213
00:09:30,586 --> 00:09:33,066
起码看啊,这一条是必须要这么做的

214
00:09:33,066 --> 00:09:36,066
如果没有having子句,我们是无法实现这个条件的

215
00:09:36,066 --> 00:09:40,146
对吧同学们,好我们来看一下实时效果反馈啊

216
00:09:40,146 --> 00:09:47,906
having子句的作用是什么呢?A对数据分组,B对分组后的结果进行过滤

217
00:09:47,906 --> 00:09:53,586
C行选择条件的给定,D给定链接条件

218
00:09:53,586 --> 00:09:56,666
那么这道题的答案是谁呢?大家想一下

219
00:09:56,666 --> 00:10:00,786
是不是很显然是B对分组后的结果进行过滤的?

220
00:10:00,786 --> 00:10:04,346
对不对?好,这道题的答案是B

221
00:10:04,346 --> 00:10:06,906
好同学们,那么以上我们就讲解了

222
00:10:06,906 --> 00:10:13,266
如何在Gerlach-Weisz子句当中通过having子句对分组数据去做数据过滤

223
00:10:13,266 --> 00:10:17,026
这里我们一定要分清having子句和vail子句的区别

224
00:10:17,026 --> 00:10:19,070
那么这里我再强调一遍

225
00:10:19,070 --> 00:10:20,762
< No Speech >

226
00:10:20,762 --> 00:10:22,462
它是做行的过滤的

227
00:10:23,354 --> 00:10:28,634
Having子句是对数据分组后的数据做进行过滤的

228
00:10:28,634 --> 00:10:29,434
明白这一次吧

229
00:10:29,434 --> 00:10:30,394
好同学们

230
00:10:30,394 --> 00:10:31,354
那我们这节课呢

