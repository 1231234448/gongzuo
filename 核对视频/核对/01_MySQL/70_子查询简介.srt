1
00:00:00,000 --> 00:00:01,018
< No Speech >

2
00:00:01,018 --> 00:00:05,618
这节课我们再来讲解一下SQL查询当中的子查询

3
00:00:05,618 --> 00:00:12,098
那么什么是子查询呢?子查询它在查询数据时所采用的方式

4
00:00:12,098 --> 00:00:20,578
就是用到我们人类在解决问题时使用的分而治之的方式来做数据查询的

5
00:00:20,578 --> 00:00:23,378
我们来看一下子查询的介绍

6
00:00:23,378 --> 00:00:29,778
比如说现在我要去找出谁的薪水比Ables多

7
00:00:29,778 --> 00:00:33,138
那么对于这样一个问题我们该怎么解决呢?

8
00:00:33,138 --> 00:00:37,778
我是不是得先去查出Ables的薪水是多少

9
00:00:37,778 --> 00:00:42,898
然后我才能查出比他薪水高的人有哪些

10
00:00:42,898 --> 00:00:48,578
所以在解决这个问题的时候,我们完全可以使用子查询的方式去做

11
00:00:48,578 --> 00:00:53,458
什么意思呢?我们在这个查询当中有两个slack的语句构成

12
00:00:53,458 --> 00:00:57,738
只不过是这两个slack的语句在执行时是有先有后的

13
00:00:57,738 --> 00:01:05,938
谁先呢?是不是应该先去查出Ables薪水是多少的这个slack的语句先执行

14
00:01:05,938 --> 00:01:09,818
对吧?然后返回了Able的薪水以后

15
00:01:09,818 --> 00:01:15,418
另外的一个查询再根据返回的Able的薪水再去做判断

16
00:01:15,418 --> 00:01:18,458
看看谁的薪水大于Able薪水

17
00:01:18,458 --> 00:01:23,018
这样就查出来了哪些雇员他的薪水比Able高了

18
00:01:23,018 --> 00:01:24,298
对不对?同学们

19
00:01:24,298 --> 00:01:27,978
那么在这两个查询当中,在这两个slack的语句当中

20
00:01:27,978 --> 00:01:30,938
我们说了有先有后,谁先执行呢?

21
00:01:30,938 --> 00:01:33,258
先查询Able薪水的先执行

22
00:01:33,258 --> 00:01:36,018
那么我们就要把它加一个括号

23
00:01:36,018 --> 00:01:39,618
那么加括号的查询就是子查询

24
00:01:39,618 --> 00:01:45,738
它所对应的外部的以它的结果作为判断条件的那个查询

25
00:01:45,738 --> 00:01:47,498
我们称之为主查询

26
00:01:47,498 --> 00:01:49,978
所以一般我们在写子查询的时候

27
00:01:49,978 --> 00:01:51,738
它都是有两个查询构成

28
00:01:51,738 --> 00:01:54,418
然后子查询是用括号

29
00:01:54,418 --> 00:01:58,138
到底谁是子查询谁是主查询是由小原括号

30
00:01:58,138 --> 00:02:00,218
是由原括号或者叫小括号来区分的

31
00:02:00,218 --> 00:02:03,378
永远是加有括号的优先及高,它先执行

32
00:02:03,378 --> 00:02:06,910
那么谁加有括号了,谁的查询就是子查询

33
00:02:07,450 --> 00:02:09,090
能明白我的意思吧同学们

34
00:02:09,090 --> 00:02:11,090
这就是子查询的一个实用

35
00:02:11,090 --> 00:02:11,930
非常的简单

36
00:02:11,930 --> 00:02:12,810
好

37
00:02:12,810 --> 00:02:13,970
我们来看一下

38
00:02:14,610 --> 00:02:16,410
用子查询解决问题

39
00:02:16,410 --> 00:02:22,330
假如要写一个查询来找出赚钱比ABLE薪水还多的人

40
00:02:22,330 --> 00:02:26,090
为了解决这个问题需要两个查询

41
00:02:26,090 --> 00:02:26,570
对吧

42
00:02:26,570 --> 00:02:28,530
一个是找出ABLE的收入

43
00:02:28,530 --> 00:02:31,290
第二个是查找出收入高于ABLE的人

44
00:02:31,290 --> 00:02:34,490
可以用组合两个查询的方法解决这个问题

45
00:02:34,490 --> 00:02:36,250
内查询或子查询

46
00:02:36,250 --> 00:02:39,130
注意我们子查询也称之为内查询

47
00:02:39,130 --> 00:02:43,090
内查询或子查询返回一个值给外查询或主查询

48
00:02:43,090 --> 00:02:45,930
主查询也称之为外查询

49
00:02:45,930 --> 00:02:46,930
明白我意思吧

50
00:02:46,930 --> 00:02:51,250
使用一个子查询相等于执行了两个连续查询

51
00:02:51,250 --> 00:02:55,050
并且用第一个查询的结果作为第二个查询的收入值

52
00:02:55,050 --> 00:02:57,290
我们一般在使用子查询时

53
00:02:57,290 --> 00:03:02,090
都是使用子查询所返回的结果来作为主查询的一个查询条件

54
00:03:02,090 --> 00:03:06,130
去对数据再进行查询得到我们想要的一个结果

55
00:03:06,130 --> 00:03:07,410
这是子查询的作用

56
00:03:07,410 --> 00:03:09,210
明白这些吧同学们

57
00:03:09,210 --> 00:03:09,730
好

58
00:03:09,730 --> 00:03:12,370
那我们再来看一下子查询的语法

59
00:03:12,370 --> 00:03:14,370
那么在两个查询当中

60
00:03:14,370 --> 00:03:17,090
谁标有小括号谁就是子查询

61
00:03:17,090 --> 00:03:17,690
看到了吗

62
00:03:17,690 --> 00:03:19,370
子查询或者叫内查询

63
00:03:19,370 --> 00:03:21,170
在主查询之前执行一次

64
00:03:21,170 --> 00:03:25,330
因为由于你查询里用到小括号或者叫原括号了

65
00:03:25,330 --> 00:03:27,090
那么原括号的优先级是最高的

66
00:03:27,090 --> 00:03:28,850
所以它肯定是先执行的

67
00:03:28,850 --> 00:03:30,450
那么它就是一个子查询

68
00:03:30,450 --> 00:03:33,810
然后子查询的结果被用于主查询的外查询

69
00:03:33,810 --> 00:03:34,730
就是主查询当中

70
00:03:34,730 --> 00:03:35,810
主查询称为外查询

71
00:03:35,810 --> 00:03:36,570
什么意思

72
00:03:36,570 --> 00:03:39,650
我子查询的目的就是为了查询到一个什么结果

73
00:03:39,650 --> 00:03:41,090
来为主查询服务

74
00:03:41,090 --> 00:03:42,610
让它作为一个条件来使用

75
00:03:42,610 --> 00:03:47,370
或者为主查询其他的查询行为来使用

76
00:03:47,370 --> 00:03:49,130
明白这些吧同学们

77
00:03:49,130 --> 00:03:50,570
好

78
00:03:50,570 --> 00:03:53,330
子查询是一个select语句

79
00:03:53,330 --> 00:03:56,650
它是嵌套另一个select语句中的子句

80
00:03:56,650 --> 00:04:03,010
使用子查询可以用简单的语句构建功能强大的语句

81
00:04:03,010 --> 00:04:05,970
那么我们可以将子查询放到一个cycle子查询

82
00:04:05,970 --> 00:04:08,410
放在一个cycle当中的什么位置呢

83
00:04:08,410 --> 00:04:12,490
可以将子查询放到许多的cycle的子句当中

84
00:04:12,490 --> 00:04:15,810
比如说val子句后面可以跟子查询

85
00:04:15,810 --> 00:04:20,330
那么这个子查询就作为val子句的一个查询条件

86
00:04:20,330 --> 00:04:21,210
明白这些吧

87
00:04:21,210 --> 00:04:23,290
having子句后面也可以跟子查询

88
00:04:23,290 --> 00:04:27,610
那么这个子查询所返回的结果同样将会作为having子句的一个条件

89
00:04:27,610 --> 00:04:30,610
from子句甚至它的后面也可以跟一个子查询

90
00:04:30,610 --> 00:04:35,290
那么现在所查询的结果集就会把它当成一个表来看待

91
00:04:35,898 --> 00:04:40,898
所以where子句、having子句跟from子句后面都可以跟子查询的

92
00:04:40,898 --> 00:04:43,898
OK,好,我们来看一下使用子查询

93
00:04:43,898 --> 00:04:49,898
那么这个案例呢,就是来解决我们刚开始所介绍子查询时说的

94
00:04:49,898 --> 00:04:52,898
谁的薪水比Able高

95
00:04:52,898 --> 00:04:56,898
那我们来看,首先我是不是得先查出Able的薪水啊

96
00:04:56,898 --> 00:04:59,898
所以在这个查询当中,它有两个select语句

97
00:04:59,898 --> 00:05:07,898
其中最后这个括号,select salary from employee where last name等于Able

98
00:05:07,898 --> 00:05:09,898
这是不是先查出Able这个人的薪水是多少

99
00:05:09,898 --> 00:05:13,898
然后把这个薪水作为主查询的条件来使用

100
00:05:13,898 --> 00:05:20,898
主查询select last name from employee where salary大于子查询所返回的salary

101
00:05:20,898 --> 00:05:25,898
那么这不就查出了那些薪水比Able高的人了吗

102
00:05:25,898 --> 00:05:29,898
明白这意思吧,同学们,这个语法上是很好理解的

103
00:05:29,898 --> 00:05:32,898
好,我们再来看一下子查询的原则

104
00:05:32,898 --> 00:05:35,898
子查询是需要放到原括号当中的

105
00:05:35,898 --> 00:05:41,898
然后子查询是要放到比较条件的右边

106
00:05:41,898 --> 00:05:45,898
包括我们刚才所说的,having子句后面也可以有子查询

107
00:05:45,898 --> 00:05:48,898
那么子查询也要放到having子句的右边

108
00:05:48,898 --> 00:05:51,898
包括from子句后面也可以有子查询

109
00:05:51,898 --> 00:05:53,898
那么子查询也要放到from子句的右边

110
00:05:53,898 --> 00:05:55,898
明白这意思吧

111
00:05:55,898 --> 00:05:59,898
然后在单行子查询当中用单行运算符

112
00:05:59,898 --> 00:06:02,898
在多行子查询当中用多行运算符

113
00:06:02,898 --> 00:06:04,898
那么这是什么意思啊

114
00:06:04,898 --> 00:06:08,898
我们子查询在执行时,由于你给定的条件不同

115
00:06:08,898 --> 00:06:12,898
那么子查询所返回的结果的数量也是不同的

116
00:06:12,898 --> 00:06:18,898
对吧,如果现在你的子查询它所返回的结果级的函数只有一条

117
00:06:18,898 --> 00:06:21,898
那它就是一个单行子查询

118
00:06:21,898 --> 00:06:25,898
如果现在你的子查询所返回的条数是一条以上的

119
00:06:25,898 --> 00:06:27,898
那它就是一个多行子查询

120
00:06:27,898 --> 00:06:31,898
那么单行子查询跟多行子查询有什么区别呢

121
00:06:31,898 --> 00:06:35,898
首先它们书写的语法上没有任何区别

122
00:06:35,898 --> 00:06:40,898
最大的区别就是在主查询使用这个结果级来作为查询条件时

123
00:06:40,898 --> 00:06:44,898
它在比较运算符上是有区别的

124
00:06:44,898 --> 00:06:48,898
大家想,如果你的子查询返回的是一行数据

125
00:06:48,898 --> 00:06:51,898
那我主查询拿着这一行数据来做判断时

126
00:06:51,898 --> 00:06:55,898
是不是可以用大于、小于、等于

127
00:06:55,898 --> 00:07:00,898
以及大于等于、小于等于或者是不等于来作为一个条件的判断

128
00:07:00,898 --> 00:07:02,898
对吧,因为你这返回的只是有一个嘛

129
00:07:02,898 --> 00:07:04,898
我当然可以用这些运算符去做判断了

130
00:07:04,898 --> 00:07:09,898
那么如果现在你的子查询返回的是一条以上,比如说两条

131
00:07:09,898 --> 00:07:16,898
那么你还能用salary或者是其他的列去大于、小于、等于或不等于去判断吗

132
00:07:16,898 --> 00:07:21,898
肯定是不能的,这些运算符是不能一个值对多个值判断的

133
00:07:21,898 --> 00:07:24,898
所以这时候我们就采用其他运算符了

134
00:07:24,898 --> 00:07:26,898
比如说用印可不可以

135
00:07:26,898 --> 00:07:30,898
我们之前学过印吧,印是可以的,印是可以包含多个值的嘛

136
00:07:30,898 --> 00:07:35,898
所以说是单行子查询还是多行子查询

137
00:07:35,898 --> 00:07:41,898
最关键的地方就要根据看你的判断方式用的是什么样的方式

138
00:07:41,898 --> 00:07:42,898
明白对吧

139
00:07:42,898 --> 00:07:45,898
好,我们来看一下子查询的类型

140
00:07:45,898 --> 00:07:51,898
单行子查询返回的是一条数据,而多行子查询是返回多条数据

141
00:07:51,898 --> 00:08:00,898
那么未来我们在主查询当中对返回的结果及判断时所使用的运算符也是有区别的

142
00:08:00,898 --> 00:08:01,898
好,我们来看失利

143
00:08:01,898 --> 00:08:03,898
现在失利有这样一个要求

144
00:08:03,898 --> 00:08:09,898
要求查询与Fox同一部门的同事并显示他们的名字与部门ID

145
00:08:09,898 --> 00:08:12,898
那么对于这样一个需求我们该怎么实现呢

146
00:08:12,898 --> 00:08:14,898
如果用子查询来实现非常简单

147
00:08:14,898 --> 00:08:18,898
首先我是不是得先知道Fox的部门ID是多少

148
00:08:18,898 --> 00:08:21,898
然后把他的部门ID查出来

149
00:08:21,898 --> 00:08:27,898
再在主查询当中去查询与他的部门ID相同的雇员

150
00:08:27,898 --> 00:08:29,898
这不就找到他的同事了吗

151
00:08:29,898 --> 00:08:30,898
是吧同学们

152
00:08:30,898 --> 00:08:32,898
好,我们来写一个

153
00:08:32,898 --> 00:08:38,078
我们第一步先去查出Fox的部门ID

154
00:08:39,034 --> 00:08:40,034
182号 and then

155
00:08:40,034 --> 00:08:41,034
好了

156
00:08:41,786 --> 00:08:49,786
然后where lastname 等于fox

157
00:08:49,786 --> 00:08:55,786
然后要什么呢 要一点department id 我们运行

158
00:08:56,570 --> 00:09:01,210
看,现在查出来了,FOX的部门ID是80,而且只返回一条数据

159
00:09:01,210 --> 00:09:02,970
说明是一个单行值查询

160
00:09:02,970 --> 00:09:08,890
那我的主查询完全可以使用等号这种运算符来做条件的判断

161
00:09:08,890 --> 00:09:12,290
好,我们把这个语句先剪切一下

162
00:09:12,290 --> 00:09:14,450
接下来我们再写主查询

163
00:09:14,450 --> 00:09:25,170
主查询,select,from employee,where,1.departmentid,等于什么呢?

164
00:09:25,170 --> 00:09:30,290
等于括号,我们说的紫查询必须要放在括号当中

165
00:09:30,290 --> 00:09:35,890
那这样就把它作为了一个主查询的条件了

166
00:09:35,890 --> 00:09:38,610
把等号放到这,能看明白吧?

167
00:09:38,610 --> 00:09:50,290
然后你的主查询里要什么呢?要1.lastname,部门ID,1.departmentid

168
00:09:50,290 --> 00:09:52,190
把这个格式熟悉一下

169
00:09:52,190 --> 00:09:54,554
< No Speech >

170
00:09:54,554 --> 00:10:01,274
看到了吗?这样我们就用指察群实现了与Fox是同一个部门的同事是谁

171
00:10:01,274 --> 00:10:02,682
< No Speech >

172
00:10:02,682 --> 00:10:09,282
看到了吗?同学们,这些都是部门ID是80的那些人,都是跟Fox是同事的

173
00:10:09,282 --> 00:10:12,602
明白这意思吧?好,我们copy一下

174
00:10:12,602 --> 00:10:15,602
那我们可以发现,其实,这里已经有了

175
00:10:15,602 --> 00:10:21,642
我们可以发现,用指察群解决问题时,它的解决的方式或者是解决复杂问题时

176
00:10:21,642 --> 00:10:23,482
它的解决思路会更清晰一些

177
00:10:23,482 --> 00:10:26,202
是吧?我们人类在解决一些复杂性问题的时候

178
00:10:26,202 --> 00:10:29,082
它也会本能的采用分人知识的方式

179
00:10:29,082 --> 00:10:31,482
我先解决什么,再解决什么,再解决什么

180
00:10:31,482 --> 00:10:32,926
对不对?

181
00:10:33,562 --> 00:10:36,642
那我们再来看一下这个实时效果反馈

182
00:10:36,642 --> 00:10:38,762
纸查询需要放到什么中?

183
00:10:38,762 --> 00:10:40,282
A,原括号当中

184
00:10:40,282 --> 00:10:41,642
B,大括号当中

185
00:10:41,642 --> 00:10:43,042
C,中国号当中

186
00:10:43,042 --> 00:10:44,642
D,书名号中

187
00:10:44,642 --> 00:10:47,562
那么纸查询应该放到什么符号当中呢?

188
00:10:47,562 --> 00:10:48,842
很显然是A嘛

189
00:10:48,842 --> 00:10:50,202
需要放到原括号当中

190
00:10:50,202 --> 00:10:51,122
就是这个小括号

191
00:10:51,122 --> 00:10:51,962
对不对

192
00:10:51,962 --> 00:10:52,482
好

193
00:10:52,482 --> 00:10:53,322
我们看一下答案

194
00:10:53,322 --> 00:10:54,522
1、A、2

195
00:10:54,522 --> 00:10:55,242
好同学们

196
00:10:55,242 --> 00:10:56,082
那么这节课呢

197
00:10:56,082 --> 00:10:58,762
我们先来了解一下什么是纸查询

198
00:10:58,762 --> 00:10:59,122
好

199
00:10:59,122 --> 00:11:01,214
那我们这节课呢就到这儿

