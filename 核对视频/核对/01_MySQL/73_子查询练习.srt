1
00:00:00,000 --> 00:00:01,210
< No Speech >

2
00:00:01,210 --> 00:00:05,890
到目前为止,子查询当中的所有的内容我们都已经讲完了

3
00:00:05,890 --> 00:00:12,490
那么这节课,我们再来通过一些练习,进一步的去巩固我们编写子查询的能力

4
00:00:12,490 --> 00:00:14,130
好,我们先来看第一题

5
00:00:14,130 --> 00:00:22,078
第一题呢,他说写一个查询,显示于Zlotkey在同一部门的雇员的last name跟password

6
00:00:22,078 --> 00:00:24,058
< No Speech >

7
00:00:24,058 --> 00:00:28,338
现在我们要去查询与Zlotkey在同一部门的同事

8
00:00:28,338 --> 00:00:28,738
对吧

9
00:00:28,738 --> 00:00:31,422
要显示他的同事的lastname和password

10
00:00:32,346 --> 00:00:37,598
对吧 然后他后面还有要求说 结果当中是不能包括他自己

11
00:00:38,330 --> 00:00:43,650
那么对于这样的一个练习 我们之前写过了 是不是 我们来分析一下他怎么去做

12
00:00:43,650 --> 00:00:47,370
首先 我们是不是应该在子查询当中 或者叫内查询当中

13
00:00:47,370 --> 00:00:51,090
先去找到Zlotkey的部门ID 对吧

14
00:00:51,090 --> 00:00:56,830
然后在主查询当中 再根据他返回的部门ID 去找和他同一部门的同事

15
00:00:57,338 --> 00:01:04,498
但是这里要求不包括他自己,那么我们在主查询的后面接着用条件把他自己过滤掉不就可以了吗

16
00:01:04,498 --> 00:01:07,658
对吧同学们,好我们来写一个

17
00:01:07,658 --> 00:01:11,966
首先我们先写自查询,自查询是先查

18
00:01:11,966 --> 00:01:13,210
< No Speech >

19
00:01:13,210 --> 00:01:14,650
部门ID对不对

20
00:01:14,650 --> 00:01:15,998
是Lapile Crew

21
00:01:15,998 --> 00:01:17,178
< No Speech >

22
00:01:17,178 --> 00:01:18,462
然后按Play

23
00:01:18,462 --> 00:01:19,514
< No Speech >

24
00:01:19,514 --> 00:01:23,486
对吧?e,然后呢,we'll e.lastname

25
00:01:24,250 --> 00:01:26,250
等于 the lot key

26
00:01:26,250 --> 00:01:28,250
the lot key

27
00:01:28,250 --> 00:01:29,918
白有人在 x 2

28
00:01:29,918 --> 00:01:31,194
< No Speech >

29
00:01:31,194 --> 00:01:35,474
然后呢,指察群要什么呢?是不是要departmentid啊?

30
00:01:35,474 --> 00:01:39,394
那么指察群搞定了以后,接下来就是主查询咯

31
00:01:39,394 --> 00:01:43,166
主查询要什么呢?我们先from 安卜拉一

32
00:01:43,166 --> 00:01:44,730
< No Speech >

33
00:01:44,730 --> 00:01:50,690
然后where e1.departmentid等于这个子查询

34
00:01:50,690 --> 00:01:53,970
那么这是不是等同于找到了他所有的同事了

35
00:01:53,970 --> 00:01:54,410
对吧

36
00:01:54,410 --> 00:01:56,830
然后呢这里还有要求什么要求呢

37
00:01:56,830 --> 00:01:59,034
< No Speech >

38
00:01:59,034 --> 00:02:01,914
那我们是不是还得用and再去做条件的过滤啊

39
00:02:01,914 --> 00:02:02,434
什么呢

40
00:02:02,434 --> 00:02:11,486
e1.lastname不等于这老的key对吧

41
00:02:11,486 --> 00:02:15,706
< No Speech >

42
00:02:15,706 --> 00:02:18,266
然后主查询要选择什么列呢

43
00:02:18,266 --> 00:02:20,506
要他同事的last name

44
00:02:20,506 --> 00:02:22,142
还有他同事的

45
00:02:23,002 --> 00:02:24,222
Department ID

46
00:02:24,730 --> 00:02:25,570
我们看一下啊

47
00:02:25,570 --> 00:02:26,050
啊

48
00:02:26,050 --> 00:02:26,810
入职世界啊

49
00:02:26,810 --> 00:02:27,810
HERITAGE

50
00:02:27,810 --> 00:02:28,922
< No Speech >

51
00:02:28,922 --> 00:02:31,802
然后我们运行

52
00:02:31,802 --> 00:02:32,722
看到了吗

53
00:02:32,722 --> 00:02:36,202
这就是找到了ZlotyKey这个人的所有的同事

54
00:02:36,202 --> 00:02:39,122
以及他们同事的入职时间

55
00:02:39,122 --> 00:02:40,958
这里是不包含他自己的

56
00:02:40,958 --> 00:02:42,138
< No Speech >

57
00:02:42,138 --> 00:02:44,578
这是通过子查询的方式来解决的

58
00:02:44,578 --> 00:02:47,138
好 我们粘到笔记当中

59
00:02:47,138 --> 00:02:48,978
好 我们再来看第二题

60
00:02:48,978 --> 00:02:51,938
第二题呢 它说创建一个查询

61
00:02:51,938 --> 00:02:57,502
显示所有其薪水高于平均薪水的雇员的雇员号。

62
00:02:57,502 --> 00:02:59,194
< No Speech >

63
00:02:59,194 --> 00:03:00,894
按薪水升续排序

64
00:03:01,690 --> 00:03:08,190
那么这个提示要显示哪些人的哪些雇员的薪水高于公司的平均薪水。

65
00:03:08,190 --> 00:03:09,818
< No Speech >

66
00:03:09,818 --> 00:03:14,738
那么我们是不是应该先去知道这些员工的平均薪水是多少

67
00:03:14,738 --> 00:03:16,818
所以我们是不是需要写一个子查询

68
00:03:16,818 --> 00:03:19,578
先去查询公司员工的平均薪水

69
00:03:19,578 --> 00:03:25,738
然后在主查询当中再去用薪水去大于子查询所返回的平均薪水不就可以了吗

70
00:03:25,738 --> 00:03:28,138
对吧同学们 这是比较简单的

71
00:03:28,138 --> 00:03:32,498
你会发现用子查询在解决一些问题时

72
00:03:32,498 --> 00:03:34,898
它是解决问题的思路是很好理解的

73
00:03:34,898 --> 00:03:36,158
对吧

74
00:03:36,666 --> 00:03:42,946
好,那我们先写一个子查询,子查询是先去找到先去算出公司的平均薪水是吧

75
00:03:42,946 --> 00:03:44,286
是那个他

76
00:03:44,286 --> 00:03:47,226
< No Speech >

77
00:03:47,226 --> 00:03:49,226
平均薪水怎么获取啊

78
00:03:49,226 --> 00:03:51,106
是所有员工的平均薪水

79
00:03:51,106 --> 00:03:53,306
那后面是不是没有任何的val条件

80
00:03:53,306 --> 00:03:54,026
对吧

81
00:03:54,026 --> 00:03:57,226
那这avg是不是通过这个函数

82
00:03:57,226 --> 00:04:00,626
然后这里是1.salary

83
00:04:00,626 --> 00:04:02,866
这是不是就找到公司的平均薪水了

84
00:04:02,866 --> 00:04:04,226
我们运行看到了吗

85
00:04:04,226 --> 00:04:05,666
这是公司的平均薪水

86
00:04:05,666 --> 00:04:07,866
然后我们在外面的主查询当中

87
00:04:07,866 --> 00:04:10,226
再去通过salary去对它作为一个大的

88
00:04:10,226 --> 00:04:11,666
作为作为一个

89
00:04:11,666 --> 00:04:14,066
这个作用一个大于判断不就可以了吗

90
00:04:14,066 --> 00:04:14,786
对不对

91
00:04:14,786 --> 00:04:17,906
rate select然后from

92
00:04:17,906 --> 00:04:20,386
employee然后e1

93
00:04:20,386 --> 00:04:21,026
是吧

94
00:04:21,026 --> 00:04:22,066
val

95
00:04:22,066 --> 00:04:24,266
e1的salary

96
00:04:24,266 --> 00:04:27,146
大于指查询所返回的平均薪水就可以了

97
00:04:27,146 --> 00:04:27,586
是吧

98
00:04:27,586 --> 00:04:28,706
然后他要什么呢

99
00:04:28,706 --> 00:04:30,586
要雇员的名字

100
00:04:30,586 --> 00:04:31,986
要雇员号名字

101
00:04:31,986 --> 00:04:34,506
雇员号e1.employee

102
00:04:34,506 --> 00:04:36,254
employee id

103
00:04:36,254 --> 00:04:39,002
< No Speech >

104
00:04:39,002 --> 00:04:43,362
然后还有名字e1.lastname

105
00:04:43,362 --> 00:04:44,042
是吧

106
00:04:44,042 --> 00:04:47,602
然后他还要求按薪水的升续排序

107
00:04:47,642 --> 00:04:49,882
no后面接着加orderby辞句就可以了

108
00:04:49,922 --> 00:04:50,882
orderby

109
00:04:50,922 --> 00:04:53,442
然后呢e1.salary

110
00:04:54,122 --> 00:04:54,482
对吧

111
00:04:54,482 --> 00:04:55,722
默认的不就是升续嘛

112
00:04:55,922 --> 00:04:56,842
好运行

113
00:04:57,482 --> 00:04:57,922
看到了吗

114
00:04:57,922 --> 00:04:58,522
同学们

115
00:04:58,762 --> 00:05:00,442
这就是我们查到的他的

116
00:05:00,482 --> 00:05:00,962
呃

117
00:05:01,362 --> 00:05:03,282
雇员ID还有他的名字

118
00:05:03,282 --> 00:05:03,722
啊

119
00:05:04,442 --> 00:05:04,842
ok

120
00:05:04,842 --> 00:05:07,322
这些都是他的薪水大于平均薪水的

121
00:05:07,322 --> 00:05:07,802
对吧

122
00:05:07,802 --> 00:05:08,094
嗯

123
00:05:08,094 --> 00:05:12,218
< No Speech >

124
00:05:12,218 --> 00:05:26,218
好 这是第二题 我们再来看第三题 第三题要求写一个查询 显示所有工作站有任意雇员的名字当中 含有优的部门的雇员的雇员号和名字

125
00:05:27,066 --> 00:05:28,946
那么想一下这个题是什么

126
00:05:29,546 --> 00:05:32,146
是不是要找谁的部门

127
00:05:32,146 --> 00:05:33,586
就是谁的同事当中

128
00:05:33,586 --> 00:05:35,066
还有这个他的名字当中

129
00:05:35,066 --> 00:05:35,786
还有U的

130
00:05:35,786 --> 00:05:36,786
对吧

131
00:05:36,786 --> 00:05:37,986
你看写一个查询

132
00:05:37,986 --> 00:05:40,026
显示所有工作在有任意

133
00:05:40,026 --> 00:05:41,266
任意雇员的名字当中

134
00:05:41,266 --> 00:05:43,266
还有U的部门的雇员的雇员号

135
00:05:43,466 --> 00:05:45,586
就找出那些部门当中

136
00:05:45,586 --> 00:05:47,626
他的同事还有U的这样的人

137
00:05:47,626 --> 00:05:48,026
对不对

138
00:05:48,026 --> 00:05:49,186
名字当中还有U的

139
00:05:49,186 --> 00:05:49,906
好

140
00:05:49,906 --> 00:05:50,626
我们来写一个

141
00:05:50,626 --> 00:05:52,346
那么这个查询也比较好写

142
00:05:52,386 --> 00:05:53,546
首先怎么办呢

143
00:05:53,586 --> 00:05:55,506
我们是不是得先去在指查询当中

144
00:05:55,506 --> 00:05:56,946
找到那些名字当中

145
00:05:56,946 --> 00:05:59,026
还有U的人的部门ID

146
00:05:59,026 --> 00:05:59,786
对不对

147
00:05:59,786 --> 00:06:01,466
所以先写一个

148
00:06:01,466 --> 00:06:03,386
指查询select

149
00:06:03,386 --> 00:06:04,426
然后from

150
00:06:04,426 --> 00:06:05,506
employee

151
00:06:05,506 --> 00:06:06,226
e

152
00:06:06,226 --> 00:06:06,786
对吧

153
00:06:06,786 --> 00:06:07,746
然后where

154
00:06:07,746 --> 00:06:08,706
什么条件呢

155
00:06:08,706 --> 00:06:09,426
一点

156
00:06:09,426 --> 00:06:10,546
last name

157
00:06:10,546 --> 00:06:11,226
like

158
00:06:11,226 --> 00:06:12,746
名字当中还有U的

159
00:06:12,746 --> 00:06:14,706
那就是百分号U百分号

160
00:06:15,066 --> 00:06:15,546
对吧

161
00:06:15,546 --> 00:06:17,106
那么找到了

162
00:06:17,426 --> 00:06:19,026
这个U的名字当中

163
00:06:19,026 --> 00:06:19,786
还有U的人了

164
00:06:19,786 --> 00:06:20,786
我们要他的什么呢

165
00:06:20,786 --> 00:06:22,386
要他的department ID

166
00:06:22,386 --> 00:06:22,906
对吧

167
00:06:22,906 --> 00:06:25,106
那么拿到department ID了

168
00:06:25,106 --> 00:06:26,506
在外面的主查询里

169
00:06:26,506 --> 00:06:28,506
是不是根据department ID再去找

170
00:06:28,506 --> 00:06:30,186
他的同事不就行了吗

171
00:06:30,426 --> 00:06:30,826
是吧

172
00:06:30,826 --> 00:06:31,746
那怎么办呢

173
00:06:31,746 --> 00:06:32,706
select

174
00:06:33,346 --> 00:06:34,546
然后from

175
00:06:34,546 --> 00:06:35,586
employee

176
00:06:35,586 --> 00:06:36,226
e

177
00:06:36,226 --> 00:06:36,626
对吧

178
00:06:36,626 --> 00:06:37,586
然后where

179
00:06:37,586 --> 00:06:39,326
请不吝点赞 订阅 转发 打赏支持明镜与点点栏目

180
00:06:40,314 --> 00:06:43,674
什么department id对吧

181
00:06:43,674 --> 00:06:45,234
然后大家想

182
00:06:45,234 --> 00:06:49,314
这个子查询现在返回的结果集是一条还是多条

183
00:06:49,946 --> 00:06:57,226
名字当中还有U的人会有多个 他们也不一定都在同一个部门里 他们可能会来源于不同的部门

184
00:06:57,386 --> 00:07:02,946
那么这个子查询返回的结果集很显然会是多条的运行看 是吧

185
00:07:02,946 --> 00:07:09,906
那么对于多条我们这还能去用单行运算服了吗 单行比较运算服了 肯定不能了 对不对

186
00:07:09,906 --> 00:07:15,746
那么怎么办呢 我现在要查的就是这些部门的同事 这些部门的同事

187
00:07:15,746 --> 00:07:22,986
这些部门的同事是不是可以用印呢 只要departmentid等于他 或者等于他 或者等于他的人都可以

188
00:07:22,986 --> 00:07:31,198
所以这很显然是一个印的比较运算 是吧 然后他要什么呢 我们看一下要什么

189
00:07:31,198 --> 00:07:33,050
< No Speech >

190
00:07:33,050 --> 00:07:41,610
要雇员的名字 雇员号和雇员名字 是吧 那就是e1.employeeid 然后逗号

191
00:07:41,610 --> 00:07:45,370
然后e1.lastname OK 运行

192
00:07:45,370 --> 00:07:50,730
好 我们可以看到 这些员工 他们的部门都是还有名字当中

193
00:07:50,730 --> 00:07:55,102
他们的同事都是他们的同事名字当中还有u的 对不对

194
00:07:55,102 --> 00:07:59,610
< No Speech >

195
00:07:59,610 --> 00:08:03,050
好 我们把它粘到笔记当中 这是第三题

196
00:08:03,050 --> 00:08:10,090
我们再来看第四题 第四题它说显示所有部门地点号

197
00:08:10,090 --> 00:08:13,850
地点号department的locationid已经告诉你了 是吧

198
00:08:13,850 --> 00:08:18,410
是170的雇员的last name department number以及job id

199
00:08:19,098 --> 00:08:25,018
那么大家想这个题我怎么去做呢?我是不是得先用指查询去查出雇员号

200
00:08:25,018 --> 00:08:30,378
就是location ID,它的部门的地点号是170的这个雇员的部门

201
00:08:30,378 --> 00:08:38,058
你看它显示所有部门的地点号是它的,然后它的部门号的地点号是170的

202
00:08:38,058 --> 00:08:42,814
那我是不是得根据地点号是170,先把它的部门号查出来?

203
00:08:43,418 --> 00:08:49,018
对吧同学们 然后再用departmentid在主查询当中用departmentid跟他去比较

204
00:08:49,018 --> 00:08:53,818
这不就找到哪些部门的这个地点号是170的吗

205
00:08:53,818 --> 00:08:57,854
对吧同学们 这很好理解 我们来写一个

206
00:08:58,554 --> 00:09:00,554
首先我们还是先写一个指察询

207
00:09:00,554 --> 00:09:02,554
指察询呢,select

208
00:09:02,554 --> 00:09:04,634
< No Speech >

209
00:09:04,634 --> 00:09:08,634
然后from employee e,对吧

210
00:09:08,634 --> 00:09:10,434
然后where什么条件呢

211
00:09:10,434 --> 00:09:13,634
e.loc,不是这个employee

212
00:09:13,634 --> 00:09:17,034
department,department d

213
00:09:17,034 --> 00:09:19,634
然后因为这个location是在department表里的

214
00:09:19,634 --> 00:09:24,634
对吧,d.locationid等于170

215
00:09:24,634 --> 00:09:27,114
1700,对吧

216
00:09:27,114 --> 00:09:28,514
然后我们要他的什么呢

217
00:09:28,514 --> 00:09:30,514
要他的departmentid嘛

218
00:09:30,514 --> 00:09:32,514
对吧,我们运行一下

219
00:09:32,514 --> 00:09:32,638
我们在国家厂商店找薰麻油

220
00:09:33,466 --> 00:09:37,666
看到了吗?这就找到了location id是170的

221
00:09:37,666 --> 00:09:40,266
他们的部门ID有哪些

222
00:09:40,266 --> 00:09:42,746
那么我们外面是不是就要通过主查询

223
00:09:42,746 --> 00:09:44,946
对这些部门ID去做一个判断

224
00:09:44,946 --> 00:09:47,906
这不就找到这些部门的人了吗?对不对?

225
00:09:47,906 --> 00:09:52,222
哎 那怎么办呢?select from employee

226
00:09:52,222 --> 00:09:53,530
< No Speech >

227
00:09:53,530 --> 00:09:55,650
对吧 然后where什么呢

228
00:09:55,650 --> 00:09:57,810
一点departmentid

229
00:09:57,810 --> 00:09:58,930
那我们可以看到

230
00:09:58,930 --> 00:10:01,050
子查询现在返回的数据是多条

231
00:10:01,050 --> 00:10:03,370
所以我们肯定不能用这个等于了

232
00:10:03,370 --> 00:10:04,090
应该是谁呢

233
00:10:04,090 --> 00:10:04,382
应该是伙计吧

234
00:10:04,382 --> 00:10:06,938
< No Speech >

235
00:10:06,938 --> 00:10:10,598
他的department ID这些员工的department ID是这些department ID

236
00:10:10,598 --> 00:10:11,422
那么就找他

237
00:10:11,422 --> 00:10:12,570
< No Speech >

238
00:10:12,570 --> 00:10:15,390
ID 就是地点号是他的部门的员工了

239
00:10:15,962 --> 00:10:19,422
明白这意思吧同学们 然后他要什么呢 我们看

240
00:10:20,090 --> 00:10:22,046
雇员的last name一点儿

241
00:10:22,046 --> 00:10:23,066
< No Speech >

242
00:10:23,066 --> 00:10:26,586
还要department number那就是department id呗

243
00:10:26,586 --> 00:10:28,990
啊 还要什么呢 招拜地 地点

244
00:10:28,990 --> 00:10:31,450
< No Speech >

245
00:10:31,450 --> 00:10:33,822
这样我们就可以查到这个数据了

246
00:10:33,822 --> 00:10:38,682
< No Speech >

247
00:10:38,682 --> 00:10:40,482
我们再来看第五题

248
00:10:40,482 --> 00:10:42,010
< No Speech >

249
00:10:42,010 --> 00:10:47,454
他说显示每个向King报告的雇员的名字和薪水

250
00:10:48,218 --> 00:10:49,790
那么也就是说去查

251
00:10:49,790 --> 00:10:51,258
< No Speech >

252
00:10:51,258 --> 00:10:53,258
这个雇员就是King

253
00:10:53,258 --> 00:10:55,178
King应该是一个部门经理吧

254
00:10:55,178 --> 00:10:55,658
对不对

255
00:10:55,658 --> 00:10:57,378
这个King的部门下有哪些雇员

256
00:10:57,378 --> 00:11:00,254
那么这些向他报告的雇员都是他部门下的员工啊

257
00:11:00,890 --> 00:11:03,262
那么对于这样的题我们怎么去做呀

258
00:11:03,770 --> 00:11:05,630
是不是得先查出King的

259
00:11:05,630 --> 00:11:08,698
< No Speech >

260
00:11:08,698 --> 00:11:10,750
谁是King的雇员吗

261
00:11:11,482 --> 00:11:12,958
明白这些吧同学们

262
00:11:13,466 --> 00:11:14,746
我们来看一下啊

263
00:11:15,546 --> 00:11:17,346
我们先写一个自查询

264
00:11:17,346 --> 00:11:19,098
< No Speech >

265
00:11:19,098 --> 00:11:20,818
select它,然后from

266
00:11:20,818 --> 00:11:22,394
< No Speech >

267
00:11:22,394 --> 00:11:22,894
对吧

268
00:11:22,894 --> 00:11:23,806
然后E

269
00:11:24,666 --> 00:11:28,446
web1.lastname

270
00:11:28,446 --> 00:11:33,402
< No Speech >

271
00:11:33,402 --> 00:11:34,002
对吧

272
00:11:34,002 --> 00:11:34,974
哎 然后呢

273
00:11:34,974 --> 00:11:36,602
< No Speech >

274
00:11:36,602 --> 00:11:39,282
Slack的后面给的是谁呀,是不是E点

275
00:11:39,282 --> 00:11:42,106
< No Speech >

276
00:11:42,106 --> 00:11:47,614
对吧 我们这个时候运行一下看看 现在是不是有两个指 这两个人

277
00:11:47,614 --> 00:11:48,634
< No Speech >

278
00:11:48,634 --> 00:11:54,914
这个King的 对不对 都是名字为King的 然后接下来我们在外面在主查询当中啊

279
00:11:54,914 --> 00:11:55,678
Selector

280
00:11:55,678 --> 00:11:59,482
< No Speech >

281
00:11:59,482 --> 00:12:02,522
还是employee1 对吧

282
00:12:02,522 --> 00:12:03,262
叫胡瓜

283
00:12:03,262 --> 00:12:05,498
< No Speech >

284
00:12:05,498 --> 00:12:15,498
ManagerID,我们要找King的下属,那么King的下属,他的下属员工的ManagerID肯定是King的EmployeeID

285
00:12:15,498 --> 00:12:18,462
对不对?所以E1的ManagerID IN

286
00:12:19,098 --> 00:12:22,938
对吧 这样就找到了所有的key的一个下属

287
00:12:22,938 --> 00:12:24,378
然后呢 要什么呢?

288
00:12:24,378 --> 00:12:25,406
一一甲

289
00:12:25,978 --> 00:12:28,958
last name 还有e1.0

290
00:12:28,958 --> 00:12:30,330
< No Speech >

291
00:12:30,330 --> 00:12:35,006
对吧同学们 运行 我们可以看到 现在这些员工都是向King报告的

292
00:12:35,006 --> 00:12:37,274
< No Speech >

293
00:12:37,274 --> 00:12:42,274
那我们这里不要忘了 King是有两个人 他都叫King 是两个部门的 对吧

294
00:12:42,274 --> 00:12:44,282
< No Speech >

295
00:12:44,282 --> 00:12:51,682
OK 好 我们再来看第6题 第6题他说显示在这个部门的每个雇员的department number

296
00:12:51,682 --> 00:12:52,962
last name跟job id

297
00:12:53,530 --> 00:12:56,970
那我们是不是得先找到这个executive部门

298
00:12:56,970 --> 00:12:59,930
那怎么找呢?我们是不是可以用一个

299
00:12:59,930 --> 00:13:04,410
用一个指查询,用department name,这不是部门名称吗?

300
00:13:04,410 --> 00:13:09,930
去查询department指表,通过部门名称找出这个部门的department id

301
00:13:09,930 --> 00:13:14,730
对吧?然后在主查询当中,再去通过department id去判断

302
00:13:14,730 --> 00:13:17,278
不就找到部门名称为它的department id了吗?

303
00:13:17,278 --> 00:13:19,834
< No Speech >

304
00:13:19,834 --> 00:13:25,554
明白吧同学们 这里我们先去写一个自查询 先找到这个部门名

305
00:13:25,554 --> 00:13:30,718
然后我们就选择从这个部门里输入 然后我们就选择从这个部门里输入

306
00:13:30,718 --> 00:13:31,866
< No Speech >

307
00:13:31,866 --> 00:13:34,426
部门名称是在department的表里的

308
00:13:34,426 --> 00:13:34,746
对吧

309
00:13:34,746 --> 00:13:35,706
department name嘛

310
00:13:35,706 --> 00:13:36,586
然后d

311
00:13:36,586 --> 00:13:37,466
然后where

312
00:13:37,466 --> 00:13:38,066
对吧

313
00:13:38,066 --> 00:13:40,866
然后d点department name

314
00:13:40,866 --> 00:13:45,242
< No Speech >

315
00:13:45,242 --> 00:13:47,482
EXE C U T I V H吧

316
00:13:47,482 --> 00:13:49,402
< No Speech >

317
00:13:49,402 --> 00:13:50,402
再试一次

318
00:13:50,402 --> 00:13:51,070
由 Amara.org 社群提供的字幕

319
00:13:51,070 --> 00:13:54,714
< No Speech >

320
00:13:54,714 --> 00:13:57,054
接下来我们是不是在这里要它的

321
00:13:57,054 --> 00:13:58,234
< No Speech >

322
00:13:58,234 --> 00:14:01,474
那就是D.DepartmentID

323
00:14:01,474 --> 00:14:01,974
是吧

324
00:14:01,974 --> 00:14:05,474
这是我们子查询或者叫内查询需要去完成的工作

325
00:14:05,474 --> 00:14:07,710
那么在外面的主查询呢?

326
00:14:07,710 --> 00:14:08,794
< No Speech >

327
00:14:08,794 --> 00:14:11,038
他要查询什么呢?是不是查员工表啊?

328
00:14:11,674 --> 00:14:15,998
然后以什么作为条件呢?1.departmentid

329
00:14:15,998 --> 00:14:18,778
< No Speech >

330
00:14:18,778 --> 00:14:20,190
只查询反馈的结果

331
00:14:20,190 --> 00:14:21,722
< No Speech >

332
00:14:21,722 --> 00:14:23,722
我们看一下为什么要用int呢?

333
00:14:23,722 --> 00:14:26,910
这个查询,它返回的结果是什么?

334
00:14:26,910 --> 00:14:28,538
< No Speech >

335
00:14:28,538 --> 00:14:34,138
试一条是吧 因为部门名称是他叫他的肯定只有一个

336
00:14:34,138 --> 00:14:38,018
那就相等 用一个代行比较符就可以了

337
00:14:38,018 --> 00:14:40,094
然后要什么呢?一点儿

338
00:14:40,094 --> 00:14:41,338
< No Speech >

339
00:14:41,338 --> 00:14:45,758
我们看一下要department number,department id 还有一点

340
00:14:45,758 --> 00:14:50,522
< No Speech >

341
00:14:50,522 --> 00:14:56,062
这些人他们都是在部门名字为Activity部门工作的

342
00:14:56,062 --> 00:14:57,274
< No Speech >

343
00:14:57,274 --> 00:15:01,914
明白这些了吧?部门名称,相同的部门,这个部门名称肯定只有一个

344
00:15:01,914 --> 00:15:05,274
这句话反方的结果集肯定只有一条,用等号来判断就可以了

345
00:15:05,274 --> 00:15:08,126
明白吧?如果是多条的话,我们再用印

346
00:15:08,126 --> 00:15:11,738
< No Speech >

347
00:15:11,738 --> 00:15:18,938
好同学们,那么这节课我们又通过了6道题,去对纸查询做了一个进一步的巩固

348
00:15:18,938 --> 00:15:23,538
那么相信同学们在编写纸查询时应该有一个熟悉的过程了

349
00:15:23,538 --> 00:15:27,326
其实纸查询写起来并不是很难,我们只要去读懂题了

350
00:15:27,866 --> 00:15:34,026
看他查询是要什么,我们根据查询这个题的需求,我们一步一步的去分析

351
00:15:34,026 --> 00:15:37,866
那么通过指查询就可以很容易的写出来了,明白这意思吧

352
00:15:37,866 --> 00:15:39,866
好,我们这节课就到这,感谢观看

