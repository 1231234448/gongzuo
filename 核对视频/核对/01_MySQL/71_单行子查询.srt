1
00:00:00,000 --> 00:00:01,050
< No Speech >

2
00:00:01,050 --> 00:00:04,250
上节课我们讲解了什么是子查询

3
00:00:04,250 --> 00:00:06,970
那我们在讲解子查询时我们说了

4
00:00:06,970 --> 00:00:09,210
子查询它是分为两大类的

5
00:00:09,210 --> 00:00:11,050
一大类是单行子查询

6
00:00:11,050 --> 00:00:13,050
一大类是多行子查询

7
00:00:13,050 --> 00:00:17,050
那么这节课我们就来讲解一下什么是单行子查询

8
00:00:17,050 --> 00:00:19,050
那么其实在上节课当中

9
00:00:19,050 --> 00:00:22,890
我们已经介绍了单行子查询和多行子查询

10
00:00:22,890 --> 00:00:26,650
它最大的区别就是子查询或者我们叫内查询

11
00:00:26,650 --> 00:00:30,650
它返回的结果集的行数是不一样的

12
00:00:30,650 --> 00:00:34,250
那么单行子查询它仅返回一行

13
00:00:34,250 --> 00:00:37,530
也就是说单行子查询是只返回一个结果集的

14
00:00:37,530 --> 00:00:38,890
一行结果集对吧

15
00:00:38,890 --> 00:00:41,930
然后我们可以使用单行比较符

16
00:00:41,930 --> 00:00:44,330
那么哪些比较符是单行比较符呢

17
00:00:44,330 --> 00:00:51,530
比如说等于大于等于小于等于以及不等于

18
00:00:51,530 --> 00:00:54,730
这是单行比较符对吧

19
00:00:54,730 --> 00:00:57,290
好我们再来看一下单行子查询

20
00:00:57,290 --> 00:00:59,530
单行子查询是从内查询

21
00:00:59,530 --> 00:01:02,490
所谓的内查询就是我们括号里的那个查询对吧

22
00:01:02,490 --> 00:01:04,890
从内查询返回一行的查询

23
00:01:04,890 --> 00:01:09,690
在该子查询类型中用单一操作符来进行操作判断的

24
00:01:09,690 --> 00:01:11,690
这就是单行子查询

25
00:01:11,690 --> 00:01:13,502
好我们来看一个实例

26
00:01:14,202 --> 00:01:18,042
查询FOX的同事,但是不包含他自己

27
00:01:18,042 --> 00:01:22,202
那么查询FOX的同事的这个案例,我们上节课已经做过了

28
00:01:22,202 --> 00:01:23,402
很简单,对吧

29
00:01:23,402 --> 00:01:27,322
我们先查出FOX的部门ID

30
00:01:27,322 --> 00:01:30,442
再用主查询来作为

31
00:01:30,442 --> 00:01:35,162
根据这个指查询所返回的部门ID作为主查询的一个判断条件

32
00:01:35,162 --> 00:01:38,042
去查询FOX的同事就可以了,对吧

33
00:01:38,042 --> 00:01:42,122
但是我们上节课所写的案例当中是包含FOX自己的

34
00:01:42,122 --> 00:01:46,602
现在又要求他不包含,但是这个查询当中是不包含他自己的

35
00:01:46,602 --> 00:01:48,522
那他怎么去排除掉自己呢?

36
00:01:48,522 --> 00:01:52,762
这里我们先去找FOX的同事,并且包含他自己的

37
00:01:52,762 --> 00:01:55,482
然后我们再说怎么排除他自己

38
00:01:55,482 --> 00:01:58,442
好,我们来写一个查询,这是我们上节课写的

39
00:01:58,442 --> 00:02:05,342
select from,我们先把这个指查询写出来

40
00:02:05,342 --> 00:02:06,906
< No Speech >

41
00:02:06,906 --> 00:02:16,066
然后from什么呢?先去查什么呢?先去查fox的departmentid是多少

42
00:02:16,066 --> 00:02:21,026
所以这就是e1.departmentid,返回departmentid,这没问题吧

43
00:02:21,026 --> 00:02:29,534
然后在where,e1的lastname等于fox

44
00:02:30,042 --> 00:02:36,762
然后我们运行查询,现在返回了Fox的departmentID是80

45
00:02:36,762 --> 00:02:37,882
是不是同学们

46
00:02:37,882 --> 00:02:45,402
然后接下来我们外面再去用主查询来使用departmentID跟它返回的80做判断

47
00:02:45,402 --> 00:02:51,802
是吧,那就是select然后from employee,别名我们叫e

48
00:02:51,802 --> 00:03:00,442
然后where,一点departmentID等于这个紫查询所返回的departmentID,是不是就找到他的同事了

49
00:03:00,442 --> 00:03:02,622
然后这里我们要什么呢?要一点departmentID

50
00:03:02,622 --> 00:03:04,090
< No Speech >

51
00:03:04,090 --> 00:03:09,330
然后逗号要一点department的ID,对吧?我们运行

52
00:03:09,330 --> 00:03:13,250
看到了吗?同学们,现在我们查到的数据有34条

53
00:03:13,250 --> 00:03:18,290
然后这里都是跟Fox是同事的一些员工信息

54
00:03:18,290 --> 00:03:21,970
但是这里是包含Fox的,我们找一下看看

55
00:03:21,970 --> 00:03:24,126
在人名当中有没有叫Fox的?

56
00:03:24,126 --> 00:03:25,466
< No Speech >

57
00:03:25,466 --> 00:03:28,826
看到了吗同学们 是不是有faux?

58
00:03:28,826 --> 00:03:34,186
那我们下一步就要通过这个手段来排除他自己了

59
00:03:34,186 --> 00:03:39,386
那么在排除他自己之前 这里我们再注意一下指察群的一个语法

60
00:03:39,386 --> 00:03:39,870
什么呢?

61
00:03:39,870 --> 00:03:40,922
< No Speech >

62
00:03:40,922 --> 00:03:47,802
单行指查询的特点是可以使用等号作为一个条件的判断

63
00:03:47,802 --> 00:03:53,642
那现在我能用等号去作一个条件判断,说明我这个指查询返回的结果肯定是一条的

64
00:03:53,642 --> 00:03:56,766
那么在这一条数据当中,我能不能包含多个例?

65
00:03:57,722 --> 00:04:01,082
也就是说在子杀群当中,我除了要departmentID以外

66
00:04:01,082 --> 00:04:03,882
比如说我要一个11.lastname,可不可以

67
00:04:03,882 --> 00:04:05,434
< No Speech >

68
00:04:05,434 --> 00:04:07,034
是不是肯定不可以的

69
00:04:07,034 --> 00:04:09,994
如果你在返回的子查询当中返回的列

70
00:04:09,994 --> 00:04:11,474
你是有多个列了

71
00:04:11,474 --> 00:04:12,714
不是一个了是两个

72
00:04:12,714 --> 00:04:15,794
那么对于主查询的val条件就蒙了

73
00:04:15,794 --> 00:04:20,194
他不知道拿着你返回的两个列的哪个值去做相等判断

74
00:04:20,194 --> 00:04:21,674
所以这肯定会出错的

75
00:04:21,674 --> 00:04:22,394
运行

76
00:04:22,394 --> 00:04:23,434
看到了吗

77
00:04:23,434 --> 00:04:25,714
原因就是你的列不是一个列

78
00:04:25,714 --> 00:04:26,874
所以它的val条件

79
00:04:26,874 --> 00:04:28,714
主查询的val条件无法做判断了

80
00:04:28,714 --> 00:04:30,274
所以这里同学们一定要注意

81
00:04:30,274 --> 00:04:31,714
在写子查询时

82
00:04:31,714 --> 00:04:32,994
在子查询当中

83
00:04:32,994 --> 00:04:35,114
括号里的子查询或者叫内查询

84
00:04:35,114 --> 00:04:37,314
它返回的列可不能是多个列

85
00:04:37,314 --> 00:04:39,074
只能是一个列

86
00:04:39,074 --> 00:04:40,234
这点能不能记住

87
00:04:40,234 --> 00:04:41,314
这是第一点

88
00:04:41,314 --> 00:04:42,034
第二点

89
00:04:42,034 --> 00:04:47,154
如果你返回的子查询所返回的数据不是一条而是多条

90
00:04:47,154 --> 00:04:49,834
也就是这个department ID不是一个是多个

91
00:04:49,834 --> 00:04:51,514
那么你就不能用等号

92
00:04:51,514 --> 00:04:53,434
不能用单行运算符去做判断了

93
00:04:53,434 --> 00:04:54,674
你看一下举个例子

94
00:04:54,674 --> 00:04:55,954
这里我换成key

95
00:04:55,954 --> 00:04:57,534
我们再来运行

96
00:04:58,330 --> 00:05:00,330
看到了吗?马上又报错了

97
00:05:00,330 --> 00:05:01,850
报错的原因是什么呀?

98
00:05:01,850 --> 00:05:06,130
名字为king的人在我们这个表当中是有两条的

99
00:05:06,130 --> 00:05:09,370
运行,你看我把它选中运行这块查king的这个人

100
00:05:09,370 --> 00:05:11,370
你看它的数据

101
00:05:11,370 --> 00:05:13,370
看到了吗?有两个人叫king

102
00:05:13,370 --> 00:05:15,850
分别是部门ID是80,部门ID是90

103
00:05:15,850 --> 00:05:19,370
所以现在你的这个括号里的子查询或者叫内查询

104
00:05:19,370 --> 00:05:21,770
返回的行数不是一行,而是两行了

105
00:05:21,770 --> 00:05:24,170
你还能用等号去判断吗?那就不能了

106
00:05:24,170 --> 00:05:25,610
那怎么解决这个问题呢?

107
00:05:25,610 --> 00:05:29,410
我们下节课会讲解多行子查询的处理方式

108
00:05:29,410 --> 00:05:31,610
现在我们只是说单行子查询

109
00:05:31,610 --> 00:05:32,610
明白这意思吧?

110
00:05:32,610 --> 00:05:36,770
那么我们条件给的这个focus是只有一个的

111
00:05:36,770 --> 00:05:38,810
focus这个人是只有一个的

112
00:05:38,810 --> 00:05:40,530
所以它返回的数据只有一条

113
00:05:40,530 --> 00:05:44,170
我们可以用在主查询当中可以用等号去做判断

114
00:05:44,170 --> 00:05:45,530
明白这意思吧同学们?

115
00:05:45,530 --> 00:05:49,490
好,那接下来我们再去解决怎么排除它自己呢?

116
00:05:49,490 --> 00:05:53,810
那么所谓的排除它自己是不是就是在这个结果集当中

117
00:05:53,810 --> 00:05:58,610
去用一个last name不等于focus不就把自己排除掉了吗?

118
00:05:59,258 --> 00:06:04,378
对吧 那我还可以在主查询的val子据的后面加条件吗

119
00:06:04,378 --> 00:06:08,378
当然可以了 而且这个条件你再加到哪都可以

120
00:06:08,378 --> 00:06:10,978
比如说我加到指查询的后面 我再加一个条件

121
00:06:10,978 --> 00:06:11,550
字幕by索兰娅✧◝⃣⃣⃣⃣

122
00:06:11,550 --> 00:06:12,602
< No Speech >

123
00:06:12,602 --> 00:06:15,482
这是一个查询条件吗

124
00:06:15,482 --> 00:06:16,482
well条件吗

125
00:06:16,482 --> 00:06:17,602
我再加一个and

126
00:06:17,602 --> 00:06:18,362
然后什么呢

127
00:06:18,362 --> 00:06:23,390
一点last name不等于fox

128
00:06:23,390 --> 00:06:24,538
< No Speech >

129
00:06:24,538 --> 00:06:27,898
看看数据多少条,现在是34条,我运行

130
00:06:28,378 --> 00:06:31,378
看看多少条,33条,同学们,少了一条

131
00:06:31,378 --> 00:06:35,198
谁没了?就是那个fox已经被我们排除掉了

132
00:06:35,198 --> 00:06:36,794
< No Speech >

133
00:06:36,794 --> 00:06:40,954
那么通过这个案例是想同学们说明什么呢

134
00:06:40,954 --> 00:06:46,834
我们在这个主查询当中除了可以给定指查询作为条件以外

135
00:06:46,834 --> 00:06:51,714
我们还可以通过AND继续给定其他的对行的过滤的条件

136
00:06:51,714 --> 00:06:55,594
而且这个条件你除了可以放到指查询的后面以外

137
00:06:55,594 --> 00:06:57,594
你还可以放到外遥子距的后面

138
00:06:57,594 --> 00:06:59,154
比如说我把它的位置换一下

139
00:06:59,154 --> 00:07:00,794
直接放到外遥子距的后面

140
00:07:00,794 --> 00:07:02,394
然后加一个AND

141
00:07:02,394 --> 00:07:05,514
第二个AND后面再给定这个指查询的条件

142
00:07:05,514 --> 00:07:08,394
作为指查询判断的条件可不可以呢

143
00:07:08,394 --> 00:07:09,634
也是没有问题的

144
00:07:09,634 --> 00:07:10,754
为什么也可以呢

145
00:07:10,754 --> 00:07:14,594
因为带括号的查询永远是先执行的

146
00:07:14,594 --> 00:07:17,634
所以当它执行后拿到这个结果了

147
00:07:17,634 --> 00:07:18,074
对吧

148
00:07:18,074 --> 00:07:20,434
那么相当于这个条件是可以做判断了

149
00:07:20,434 --> 00:07:22,394
这个时候VAL先判断它

150
00:07:22,394 --> 00:07:24,474
再去拿这个条件做一个判断

151
00:07:24,474 --> 00:07:26,594
并且是一个这两个条件是一个并且的关系

152
00:07:26,594 --> 00:07:28,394
是不是也可以查到结果集

153
00:07:28,394 --> 00:07:29,114
是吧

154
00:07:29,114 --> 00:07:32,154
所以主查询当中的VAL子距的条件

155
00:07:32,154 --> 00:07:35,114
你是可以出现在这个指查询的

156
00:07:35,114 --> 00:07:38,474
就是这个以指查询作为判断条件的前面

157
00:07:38,474 --> 00:07:40,958
也可以出现在后面是没有问题的

158
00:07:41,594 --> 00:07:49,914
明白这意思吧,同学们,这是我们在带有紫查询的这个主查询当中,再通过其他的条件来做数据过滤也是可以的

159
00:07:49,914 --> 00:07:54,634
那么其实这个例子呢,重点是向大家说明什么呢?

160
00:07:54,634 --> 00:08:00,794
对于这个内查询,或者我们把它叫紫查询,它返回的结果集当中,第一不能包含多个列

161
00:08:00,794 --> 00:08:09,194
第二,查询的结果集只能有一行,因为我们现在用的是单行比较运算服去做条件判断的

162
00:08:09,194 --> 00:08:14,634
所以它就不能返回多行了,返回多行就会出错了,也不能投用多个列

163
00:08:14,634 --> 00:08:18,794
明白这意思吧,同学们,好,我们来看一下实时效果反馈

164
00:08:18,794 --> 00:08:26,954
单行紫查询是从内查询返回什么的查询?A,空数据,B,多行数据,C,多个列数据,D,一行数据

165
00:08:26,954 --> 00:08:31,434
那么这个选项应该是什么?很显然是D嘛,一行数据

166
00:08:31,434 --> 00:08:36,794
单行紫查询返回空数据是不对的,多行数据更不对了,多个列的数据更不对了

167
00:08:36,794 --> 00:08:40,714
多个列是无法判断的,那么只有返回一行数据它才能做判断

168
00:08:40,714 --> 00:08:43,550
当然你返回空数据它也能做判断

169
00:08:44,090 --> 00:08:51,770
对吧?一行空数据也是对的,但是我们用单行指查群更多的是要返回一行有效的数据的

170
00:08:51,770 --> 00:08:55,370
明白这意思吧?所以这个题的答案应该是D

171
00:08:55,370 --> 00:09:00,170
好,同学们,那么以上我们就讲解了什么是单行指查群

172
00:09:00,170 --> 00:09:02,410
好,那我们这一课就到这

