1
00:00:00,000 --> 00:00:01,018
< No Speech >

2
00:00:01,018 --> 00:00:05,778
上节课我们讲解了聚合函数当中的抗打函数的使用

3
00:00:05,778 --> 00:00:09,338
那么到目前为止,聚合函数我们已经讲的差不多了

4
00:00:09,338 --> 00:00:14,298
那么大家再回忆一下,我们之前在讲聚合函数时一再强调

5
00:00:14,298 --> 00:00:17,978
聚合函数和单行函数最大的区别是什么?

6
00:00:17,978 --> 00:00:23,198
聚合函数是需要对数据的分组进行处理的

7
00:00:23,706 --> 00:00:24,226
对吧

8
00:00:24,226 --> 00:00:27,186
所以它也称之为主函数或者叫分组函数

9
00:00:27,186 --> 00:00:28,066
对吧

10
00:00:28,066 --> 00:00:30,626
那么如果你在查询时

11
00:00:30,666 --> 00:00:33,826
未对数据做任何的分组处理

12
00:00:33,866 --> 00:00:37,266
那么聚合函数会把你查询到的所有的

13
00:00:37,266 --> 00:00:39,746
结果集作为一个大组来看待

14
00:00:39,746 --> 00:00:41,906
然后去做相的运算处理

15
00:00:41,986 --> 00:00:43,866
这是聚合函数的一个特点

16
00:00:43,866 --> 00:00:44,146
对吧

17
00:00:44,146 --> 00:00:44,506
同学们

18
00:00:44,506 --> 00:00:48,426
那么如果我们现在的需求是需要

19
00:00:48,426 --> 00:00:51,666
对结果集去做相的分组处理

20
00:00:51,666 --> 00:00:55,426
然后让聚合函数对不同的组去做运算

21
00:00:55,426 --> 00:00:55,906
可不可以

22
00:00:55,906 --> 00:00:57,406
答案肯定是可以的

23
00:00:58,234 --> 00:01:03,594
那么这个时候我们就要学会如何对数据做分组处理了

24
00:01:03,594 --> 00:01:06,874
那么在我们mySQL当中是使用什么呢

25
00:01:06,874 --> 00:01:11,354
Group by子句来对数据做分组处理的

26
00:01:11,354 --> 00:01:12,994
我们来看这个图片当中的例子

27
00:01:12,994 --> 00:01:16,514
在安普拉一表当中有departmentid

28
00:01:16,514 --> 00:01:17,594
这是部门ID对吧

29
00:01:17,594 --> 00:01:18,794
然后还有salary

30
00:01:18,794 --> 00:01:19,954
这是员工的薪水

31
00:01:19,954 --> 00:01:23,394
那么比如说现在我要完成的查询是这样的

32
00:01:23,394 --> 00:01:30,274
要求计算员工表当中各个部门的平均薪水

33
00:01:30,274 --> 00:01:33,034
或者叫每个部门的平均薪水

34
00:01:33,034 --> 00:01:34,874
我们听这个题的需求

35
00:01:34,874 --> 00:01:37,114
从这个题当中我们分析出两点

36
00:01:37,114 --> 00:01:40,274
一每个部门对吧

37
00:01:40,274 --> 00:01:42,434
二平均薪水

38
00:01:42,434 --> 00:01:45,954
我们看在这个需求当中这两个重点语句里

39
00:01:45,954 --> 00:01:47,914
平均薪水怎么求

40
00:01:47,914 --> 00:01:48,754
我们应该知道了

41
00:01:48,754 --> 00:01:51,754
之前我们学过用AVG函数就可以了是吧

42
00:01:51,754 --> 00:01:54,034
那么现在它是对谁求平均薪水

43
00:01:54,034 --> 00:01:57,114
它不是求整个安普拉一表的平均薪水

44
00:01:57,114 --> 00:01:59,234
而是求每个部门的平均薪水

45
00:01:59,234 --> 00:02:01,714
那么第一每个部门怎么求

46
00:02:01,714 --> 00:02:03,914
现在就是放在我们面前要解决的一个问题了

47
00:02:03,914 --> 00:02:04,894
对不对

48
00:02:05,530 --> 00:02:12,570
那么我们现在想如果我要想求每个部门就可以是不是就可以使用数据分组来处理了

49
00:02:12,570 --> 00:02:13,330
什么意思呢

50
00:02:13,330 --> 00:02:16,250
我按照部门ID去分组

51
00:02:16,250 --> 00:02:17,610
那么这个时候呢

52
00:02:17,610 --> 00:02:23,290
my circle会把部门ID相同的数据划分一组

53
00:02:23,290 --> 00:02:26,730
另一组是另一个部门ID的

54
00:02:26,730 --> 00:02:28,530
另一组数据是另一个部门ID的

55
00:02:29,050 --> 00:02:31,930
那么我们如果把这个数据能分成这样的组

56
00:02:31,970 --> 00:02:35,450
我们在对这个组上的数据去求平均工资

57
00:02:35,490 --> 00:02:38,490
是不是就等于对部门员工表当中的

58
00:02:38,530 --> 00:02:43,210
对员工表当中的每个部门去求他的平均薪水了

59
00:02:43,730 --> 00:02:44,090
对不对

60
00:02:44,090 --> 00:02:44,530
同学们

61
00:02:44,570 --> 00:02:46,450
所以在完成这个需求之前

62
00:02:46,450 --> 00:02:47,530
我们要知道有两件事

63
00:02:47,530 --> 00:02:47,770
第一

64
00:02:47,770 --> 00:02:50,970
我们先怎么去按照部门ID去创建分组

65
00:02:51,010 --> 00:02:51,450
第二

66
00:02:51,450 --> 00:02:52,250
分完组以后

67
00:02:52,290 --> 00:02:54,290
我们用什么函数去求平均薪水

68
00:02:55,050 --> 00:02:57,050
其实按照我们现在所分析的

69
00:02:57,050 --> 00:02:59,810
如果我们会使用GRUBY子句就很简单了

70
00:02:59,810 --> 00:03:00,130
怎么办

71
00:03:00,450 --> 00:03:03,570
直接用GRUBY后面你要对哪个列做分组

72
00:03:03,810 --> 00:03:05,930
我现在对departmentid做分组

73
00:03:06,130 --> 00:03:08,250
在后面给departmentid就可以了

74
00:03:08,250 --> 00:03:12,286
这样你拿到的数据就是现在表当中所看到了

75
00:03:12,794 --> 00:03:15,794
departmentid 10就一个,那就是它是一组

76
00:03:15,794 --> 00:03:18,194
20有两个,那这两个数据是一组

77
00:03:18,194 --> 00:03:20,434
50的有这些,那他们的是一组

78
00:03:20,434 --> 00:03:22,354
60的有这些,那他们的是一组

79
00:03:22,354 --> 00:03:23,914
80的是一些,有他们的一组

80
00:03:23,914 --> 00:03:25,434
90的是一些,有他们的一组

81
00:03:25,434 --> 00:03:29,674
这就是按girlbyid后面给的departmentid以后

82
00:03:29,674 --> 00:03:31,354
数据所返回的一个结果

83
00:03:31,354 --> 00:03:33,474
那么现在我们要的是除了分组以外

84
00:03:33,474 --> 00:03:34,474
还要求平均薪水

85
00:03:34,474 --> 00:03:35,114
是吧

86
00:03:35,114 --> 00:03:37,994
所以我们直接在slack的子句后面

87
00:03:37,994 --> 00:03:42,074
通过avg函数去对salary求平均薪水就可以了

88
00:03:42,074 --> 00:03:45,514
这样avg函数就会对这一组求平均薪水

89
00:03:45,514 --> 00:03:46,794
对这一组的数据

90
00:03:46,794 --> 00:03:48,554
对它的salary求平均薪水

91
00:03:48,554 --> 00:03:50,354
对这一组的数据求平均薪水

92
00:03:50,354 --> 00:03:52,154
最后我们看到的结果就是这样的

93
00:03:52,154 --> 00:03:54,354
id为10的4400

94
00:03:54,354 --> 00:03:55,234
因为只有一条数据

95
00:03:55,234 --> 00:03:58,074
id为20的,departmentid为20的

96
00:03:58,074 --> 00:03:59,554
它的平均薪水是9500

97
00:03:59,554 --> 00:04:00,954
看到了吗

98
00:04:00,954 --> 00:04:01,594
同学们

99
00:04:01,594 --> 00:04:04,234
所以我们之前在讲聚合函数的时候也说了

100
00:04:04,234 --> 00:04:06,034
聚合函数我也叫多行函数

101
00:04:06,034 --> 00:04:08,274
它的特点是对应多行操作

102
00:04:08,274 --> 00:04:10,794
并且返回唯一的一个结果集

103
00:04:10,794 --> 00:04:11,874
你看这不就是吗

104
00:04:11,874 --> 00:04:12,474
对吧

105
00:04:12,474 --> 00:04:15,674
看avg函数对这一行数据返回一个

106
00:04:15,674 --> 00:04:17,754
对这两行数据返回一个

107
00:04:17,754 --> 00:04:19,874
对这些数据返回一个

108
00:04:19,874 --> 00:04:20,914
平均薪水嘛

109
00:04:20,914 --> 00:04:21,314
对不对

110
00:04:21,314 --> 00:04:23,514
这就是聚合函数的一个特点

111
00:04:23,514 --> 00:04:25,554
那么我们现在会创建分组了

112
00:04:25,554 --> 00:04:27,394
会使用聚合函数求平均薪水了

113
00:04:27,394 --> 00:04:29,074
那么这个问题就解决了

114
00:04:29,074 --> 00:04:30,554
明白不了同学们

115
00:04:30,554 --> 00:04:31,714
这就是创建分组

116
00:04:31,714 --> 00:04:33,634
我们可以根据自己的需求

117
00:04:33,634 --> 00:04:37,234
去决定对哪一列数据创建什么样的数据分组

118
00:04:37,234 --> 00:04:38,794
那么数据分组的创建

119
00:04:38,794 --> 00:04:40,794
在我们完成一些复杂查询上

120
00:04:40,794 --> 00:04:42,234
是非常有用的

121
00:04:42,234 --> 00:04:43,874
在解决一些特定的问题上

122
00:04:43,874 --> 00:04:44,714
是非常有用的

123
00:04:44,714 --> 00:04:45,754
OK

124
00:04:45,754 --> 00:04:46,074
好

125
00:04:46,074 --> 00:04:47,074
我们再往下看

126
00:04:47,954 --> 00:04:49,194
创建数据分组

127
00:04:49,194 --> 00:04:51,194
在没有进行数据分组之前

128
00:04:51,194 --> 00:04:52,394
所有聚合函数

129
00:04:52,394 --> 00:04:55,194
是将结果集作为一个大的新基础进行处理

130
00:04:55,194 --> 00:04:56,274
这是我们反复强调的

131
00:04:56,274 --> 00:04:56,714
对吧

132
00:04:56,714 --> 00:05:01,434
但是有时则需要将表的信息划分为较小的组

133
00:05:01,434 --> 00:05:04,714
比如说我现在要求每个部门的平均薪水

134
00:05:04,714 --> 00:05:06,394
那我肯定要划分小组了

135
00:05:06,394 --> 00:05:07,794
按照什么划分小组呢

136
00:05:07,794 --> 00:05:08,874
是不是按部门ID

137
00:05:08,874 --> 00:05:10,634
部门ID相同的是一小组

138
00:05:10,634 --> 00:05:10,994
对不对

139
00:05:10,994 --> 00:05:13,994
可以用Groupby子句来实现

140
00:05:13,994 --> 00:05:14,914
OK

141
00:05:14,914 --> 00:05:17,194
我们来看一下Groupby子句的语法

142
00:05:17,194 --> 00:05:19,594
那么我们创建数据分组时

143
00:05:19,594 --> 00:05:21,674
这个Groupby子句应该放到哪呢

144
00:05:21,674 --> 00:05:22,554
同学们注意

145
00:05:22,554 --> 00:05:25,074
Groupby子句它出现的位置是固定的

146
00:05:25,074 --> 00:05:25,118
那么我们来看一下Groupby子句的语法

147
00:05:25,118 --> 00:05:26,170
< No Speech >

148
00:05:26,170 --> 00:05:30,410
如果你有well子句的话必须出现在well子句的后面

149
00:05:30,410 --> 00:05:33,330
如果你有order by子句是在order by子句的前面

150
00:05:33,330 --> 00:05:35,290
也就是说well跟order by之间的

151
00:05:35,290 --> 00:05:37,010
它不能出现在其他的位置

152
00:05:37,010 --> 00:05:38,370
这是他语法上要求的

153
00:05:38,370 --> 00:05:39,806
明白我意思吧?

154
00:05:40,314 --> 00:05:55,294
好,我们再来看一下使用Gerber紫句的一个原则,使用VALS字句呢,我们可以在划分行成组以前过滤数据,也就是说我们在做数据分组时,我们仍然可以先用VALS字句去做行的过滤数据。

155
00:05:55,294 --> 00:05:56,602
< No Speech >

156
00:05:56,602 --> 00:06:04,350
那么这个时候,Well子聚过滤好行以后,GerrBi是对Well子聚过滤好行以后的数据再次去做分组

157
00:06:05,178 --> 00:06:09,818
明白这意思吧?所以GROW BY的特点是对你查询到的结果集做分组嘛

158
00:06:09,818 --> 00:06:13,418
那么至于这个结果集是什么样的?那取决于你vile子聚的给定

159
00:06:13,418 --> 00:06:18,142
你不给vile子聚就查所有的,如果给vile子聚就是查满足条件的vile子聚

160
00:06:18,746 --> 00:06:21,946
查询满足vile子据的条件的这样的数据

161
00:06:21,946 --> 00:06:22,346
然后呢

162
00:06:22,346 --> 00:06:24,746
Growby再对这个结果机去做分组处理

163
00:06:24,746 --> 00:06:25,386
明白这意思吧

164
00:06:25,386 --> 00:06:25,786
同学们

165
00:06:25,786 --> 00:06:27,586
如果有vile子据

166
00:06:27,586 --> 00:06:31,146
那么order那么这个growby子据必须出现在vile子据的后面

167
00:06:31,146 --> 00:06:32,186
这就是为什么

168
00:06:32,186 --> 00:06:35,106
Growby必须要出现在vile子据的后面的原因了

169
00:06:35,106 --> 00:06:37,226
它是先计算行

170
00:06:37,226 --> 00:06:37,946
对吧

171
00:06:37,946 --> 00:06:40,426
先把这个条件满足条件的数据查出来

172
00:06:40,426 --> 00:06:41,906
然后再分组

173
00:06:41,906 --> 00:06:42,986
最后再orderby

174
00:06:42,986 --> 00:06:45,946
所以它出现的位置也决定了它执行的位置

175
00:06:45,946 --> 00:06:47,466
它子据执行的顺序

176
00:06:47,466 --> 00:06:47,550
那么我们今天就讲到这里

177
00:06:48,186 --> 00:06:55,866
那么明白同学们,在Gb子句当中必须包含列,也就是说你Gb子句后面不能是空的,必须要给一个列

178
00:06:55,866 --> 00:07:04,826
明白这意思吧,那人说老师,我不想分组,我就想把所有的查询的结果集放成一个大组来看怎么办,那不写Gb子句就可以了

179
00:07:04,826 --> 00:07:09,758
是吧,OK,好,我们来看一下使用Gb子句

180
00:07:10,682 --> 00:07:12,242
这是一个具体的案例了

181
00:07:13,242 --> 00:07:15,242
我们看在这个案例当中

182
00:07:15,842 --> 00:07:18,322
就是我们刚刚所看到的第一个图片

183
00:07:18,322 --> 00:07:20,842
去求每个部门的平均薪水的实现了

184
00:07:20,882 --> 00:07:22,362
我们是不是要用Group by

185
00:07:22,362 --> 00:07:24,242
对department id分组

186
00:07:24,442 --> 00:07:24,802
对吧

187
00:07:24,802 --> 00:07:28,282
这个时候他会查出所有的安普拉

188
00:07:28,282 --> 00:07:29,122
一表当中

189
00:07:29,322 --> 00:07:31,922
department id相同的数据

190
00:07:31,922 --> 00:07:33,602
并且把他们都做了一块一块的分组

191
00:07:33,602 --> 00:07:34,002
对吧

192
00:07:34,042 --> 00:07:39,082
然后在对分组数据当中去做平均薪水的求职处理

193
00:07:39,082 --> 00:07:41,002
最后返回的结果就是这样的

194
00:07:42,002 --> 00:07:42,482
看到了吗

195
00:07:42,482 --> 00:07:42,922
同学们

196
00:07:42,922 --> 00:07:44,682
OK

197
00:07:44,962 --> 00:07:45,282
好

198
00:07:45,282 --> 00:07:46,122
我们再来看

199
00:07:46,122 --> 00:07:47,562
< No Speech >

200
00:07:47,562 --> 00:07:48,602
Group by子句

201
00:07:48,762 --> 00:07:50,722
下面是包含一个Group by子句的

202
00:07:50,722 --> 00:07:52,882
select一句的求职过程

203
00:07:53,322 --> 00:07:56,442
首先select子句是指定要返回的列的

204
00:07:56,482 --> 00:07:56,962
是吧

205
00:07:56,962 --> 00:07:58,402
这Group by子句是要求职

206
00:07:58,402 --> 00:08:00,442
取决于返回的列的

207
00:08:00,722 --> 00:08:03,962
然后在安普拉一表这个表当中的部门号

208
00:08:04,322 --> 00:08:06,242
用Group by子句指定分组

209
00:08:06,242 --> 00:08:09,162
所指定分组的所有薪水的平均值

210
00:08:09,282 --> 00:08:10,442
现在在安普拉一表当中

211
00:08:10,442 --> 00:08:11,322
你要对谁分组

212
00:08:11,482 --> 00:08:13,202
你必须要在Group by子句的后面

213
00:08:13,202 --> 00:08:14,882
给定你要分组的列

214
00:08:15,002 --> 00:08:15,362
是吧

215
00:08:15,362 --> 00:08:16,682
我给department id了

216
00:08:16,802 --> 00:08:19,082
他就会按照department id的数据去分组

217
00:08:19,082 --> 00:08:21,002
把相同的数据分一组

218
00:08:21,002 --> 00:08:22,042
相同的数据分一组

219
00:08:22,042 --> 00:08:23,042
相同的数据分一组

220
00:08:23,042 --> 00:08:23,922
这就是数据分组

221
00:08:24,402 --> 00:08:24,722
对吧

222
00:08:24,722 --> 00:08:28,162
然后from子句指定数据库必须访问的表

223
00:08:28,402 --> 00:08:31,042
from你分组这个列来源于哪个表

224
00:08:31,042 --> 00:08:32,042
你必须要给定表名

225
00:08:32,042 --> 00:08:32,802
这是无所谓的

226
00:08:33,282 --> 00:08:34,602
这是肯定的

227
00:08:34,602 --> 00:08:37,322
然后well子句是指定被返回的行

228
00:08:37,682 --> 00:08:39,522
我们如果有行的过滤

229
00:08:39,842 --> 00:08:42,962
必须要使用well子句去做行过滤的处理

230
00:08:43,322 --> 00:08:44,402
因为无well子句

231
00:08:44,402 --> 00:08:45,042
默认情况下

232
00:08:45,042 --> 00:08:46,162
所有的行是被返回的

233
00:08:46,162 --> 00:08:47,522
也就是说你没有well子句

234
00:08:47,522 --> 00:08:49,682
它正常还是查表当中的所有的数据的

235
00:08:49,682 --> 00:08:50,282
明白这次吧

236
00:08:50,282 --> 00:08:52,082
然后Group by子句

237
00:08:52,082 --> 00:08:53,122
< No Speech >

238
00:08:53,122 --> 00:08:54,882
指定行怎样被分组

239
00:08:55,242 --> 00:08:56,602
行用部门号分组

240
00:08:56,602 --> 00:08:59,722
所以avg函数被应用于薪水列

241
00:08:59,722 --> 00:09:02,322
所以以计算每个部门的平均薪水

242
00:09:03,282 --> 00:09:04,122
明白这次吧

243
00:09:04,122 --> 00:09:06,002
这是Group by子句

244
00:09:06,002 --> 00:09:06,842
好

245
00:09:06,842 --> 00:09:07,882
我们来看一个示例

246
00:09:08,242 --> 00:09:10,642
计算每个部门的员工总数

247
00:09:10,642 --> 00:09:12,242
我们看这个示例

248
00:09:12,922 --> 00:09:15,082
计算每个部门的员工总数

249
00:09:15,082 --> 00:09:16,682
我们从需求当中

250
00:09:16,682 --> 00:09:18,642
还是能分解出两个重要的信息

251
00:09:18,642 --> 00:09:19,082
第一

252
00:09:19,082 --> 00:09:21,522
每个部门的还得按部门分组

253
00:09:21,522 --> 00:09:22,042
对不对

254
00:09:22,042 --> 00:09:23,762
然后计算每个部门的什么呢

255
00:09:24,162 --> 00:09:25,202
员工总数

256
00:09:25,442 --> 00:09:27,162
员工总数我们用什么可以计算

257
00:09:27,282 --> 00:09:28,282
是不是可以用计数

258
00:09:28,882 --> 00:09:29,202
对吧

259
00:09:29,202 --> 00:09:29,682
计数是谁

260
00:09:29,842 --> 00:09:30,762
不就是count吗

261
00:09:30,882 --> 00:09:31,962
count行不就行了

262
00:09:32,322 --> 00:09:33,482
你有多少条数据

263
00:09:33,482 --> 00:09:35,002
每个部门有多少条数据

264
00:09:35,002 --> 00:09:36,562
我就count多少条

265
00:09:36,562 --> 00:09:38,602
不就返回这个部门的员工总数了吗

266
00:09:39,042 --> 00:09:40,002
明白这些是吧同学们

267
00:09:40,002 --> 00:09:40,682
好

268
00:09:40,682 --> 00:09:42,302
我们来实现一下

269
00:09:42,302 --> 00:09:43,674
< No Speech >

270
00:09:43,674 --> 00:09:47,314
select, from, and employee

271
00:09:47,314 --> 00:09:50,106
< No Speech >

272
00:09:50,106 --> 00:09:52,066
然后有没有什么查询条件呢

273
00:09:52,066 --> 00:09:53,346
没有的对吧

274
00:09:53,346 --> 00:09:55,186
哎我们不需要well子具的

275
00:09:55,186 --> 00:09:57,306
因为它是求部门的平均薪水嘛

276
00:09:57,306 --> 00:09:59,146
那么啊求部门的员工总数嘛

277
00:09:59,146 --> 00:10:01,306
那我们这里肯定要先按部门去分组了

278
00:10:01,306 --> 00:10:02,066
怎么办呢

279
00:10:02,066 --> 00:10:03,546
growth by子具对吧

280
00:10:03,546 --> 00:10:05,746
后面给定你对哪个列做分组

281
00:10:05,746 --> 00:10:08,306
它会把相同的这个列的相同的数据啊

282
00:10:08,306 --> 00:10:10,986
分成一个组相同的数据分为一个组啊

283
00:10:10,986 --> 00:10:14,706
那我就按照一点departmentid做分组

284
00:10:14,706 --> 00:10:15,186
对吧

285
00:10:15,186 --> 00:10:16,866
那么你现在对它分组了以后

286
00:10:16,866 --> 00:10:17,746
你要求什么呢

287
00:10:17,746 --> 00:10:20,186
我要求每个组的总元数啊

288
00:10:20,186 --> 00:10:22,146
这个员工的总数员工总数

289
00:10:22,146 --> 00:10:24,346
我们是是不是可以用count呀

290
00:10:24,346 --> 00:10:24,866
对吧

291
00:10:24,866 --> 00:10:26,226
然后这里放什么呢

292
00:10:26,226 --> 00:10:27,906
放形容就可以了

293
00:10:27,906 --> 00:10:30,026
有一行数据作为一个员工

294
00:10:30,026 --> 00:10:31,546
有一行数据作为一个员工

295
00:10:31,546 --> 00:10:31,826
是吧

296
00:10:31,826 --> 00:10:32,666
那有多少行数据

297
00:10:32,666 --> 00:10:34,266
那就多少个员工呗

298
00:10:34,266 --> 00:10:34,906
明白这意思吧

299
00:10:34,906 --> 00:10:35,306
哎

300
00:10:35,306 --> 00:10:37,666
那么这里同学们需要注意啊

301
00:10:37,666 --> 00:10:38,866
在聚合函数当中

302
00:10:38,866 --> 00:10:40,466
我们是不能在mysql当中啊

303
00:10:40,466 --> 00:10:42,746
是不能对聚合函数做嵌套使用的

304
00:10:42,746 --> 00:10:45,066
比如说我count里放一个sum函数

305
00:10:45,066 --> 00:10:46,546
count里放个me函数啊

306
00:10:46,546 --> 00:10:47,786
这是不可以的啊

307
00:10:47,786 --> 00:10:48,026
好

308
00:10:48,026 --> 00:10:50,146
那我们这里直接count的形容就可以了

309
00:10:50,146 --> 00:10:51,586
运行

310
00:10:51,586 --> 00:10:52,026
看到了吗

311
00:10:52,026 --> 00:10:52,346
同学们

312
00:10:52,346 --> 00:10:52,666
这样呢

313
00:10:52,666 --> 00:10:55,346
我们也可以再把departmentid再取出来啊

314
00:10:55,346 --> 00:10:56,606
poriousharry的 injector是enable的

315
00:10:57,466 --> 00:10:59,946
DepartmentID逗号 然后运行

316
00:10:59,946 --> 00:11:00,990
帮我一点忙 知道吗?

317
00:11:00,990 --> 00:11:03,514
< No Speech >

318
00:11:03,514 --> 00:11:05,554
我们看结果啊 第一个空的

319
00:11:05,994 --> 00:11:07,914
然后呢 count1这是什么意思

320
00:11:08,034 --> 00:11:11,394
说明在员工标里有一个人没有部门ID

321
00:11:11,394 --> 00:11:12,554
这个人是有一个的

322
00:11:12,554 --> 00:11:14,394
有没有这样的人 有啊 谁啊

323
00:11:14,394 --> 00:11:16,514
grant嘛 grant是没有部门的嘛

324
00:11:17,114 --> 00:11:17,554
对不对

325
00:11:17,554 --> 00:11:18,874
哎 我们之前查过他

326
00:11:18,914 --> 00:11:20,434
查过这个数据的 是吧

327
00:11:20,474 --> 00:11:22,034
所以没有部门的有一个

328
00:11:22,074 --> 00:11:23,674
然后部门ID是10的有一个

329
00:11:23,674 --> 00:11:25,314
部门ID是20的有两个员工

330
00:11:25,314 --> 00:11:27,354
部门ID是30的有6个员工

331
00:11:27,354 --> 00:11:28,114
以此类推

332
00:11:28,714 --> 00:11:29,154
是吧

333
00:11:29,154 --> 00:11:31,394
这样呢我们就把每个部门的员工总数

334
00:11:31,394 --> 00:11:33,034
就都已经全查询出来了

335
00:11:33,034 --> 00:11:33,554
是吧

336
00:11:33,554 --> 00:11:35,714
哎 所以我们大家头脑里一定想

337
00:11:35,754 --> 00:11:38,114
当我去查询这个执行以后啊

338
00:11:38,674 --> 00:11:40,314
数据结果集这个

339
00:11:40,434 --> 00:11:42,234
返回的结果集是什么样的

340
00:11:42,834 --> 00:11:43,354
对吧

341
00:11:43,354 --> 00:11:44,794
头脑里面有这个概念

342
00:11:44,834 --> 00:11:47,394
它就是一个呃这样就是一个表

343
00:11:47,434 --> 00:11:48,834
然后表里有多条数据

344
00:11:48,834 --> 00:11:50,794
然后按照departmentid去做了一个

345
00:11:50,794 --> 00:11:52,074
不同的数据分组

346
00:11:52,114 --> 00:11:54,434
啊相同的departmentid是一组

347
00:11:54,434 --> 00:11:56,154
相同的departmentid是一组

348
00:11:56,194 --> 00:11:57,954
然后去求他们的总人数

349
00:11:57,954 --> 00:11:59,914
对每一组返回一个结果集

350
00:12:00,474 --> 00:12:02,354
这是组函数聚合函数的特点

351
00:12:02,354 --> 00:12:03,794
嘛明白吗

352
00:12:03,794 --> 00:12:04,274
同学们

353
00:12:04,274 --> 00:12:04,474
哎

354
00:12:04,474 --> 00:12:05,994
最后的结果就是我们所看到的

355
00:12:05,994 --> 00:12:06,914
这个结果啊

356
00:12:07,114 --> 00:12:07,634
ok

357
00:12:07,874 --> 00:12:09,114
那么数据创建分组呢

358
00:12:09,114 --> 00:12:10,194
还是比较简单的

359
00:12:10,194 --> 00:12:10,474
是吧

360
00:12:10,474 --> 00:12:12,034
就是根据geruby子据

361
00:12:12,034 --> 00:12:14,154
根据我们的业务需求去指定

362
00:12:14,194 --> 00:12:15,634
分组列就可以了啊

363
00:12:15,874 --> 00:12:16,434
ok

364
00:12:16,434 --> 00:12:16,794
好

365
00:12:16,794 --> 00:12:18,314
我们来看一下这个实时效果

366
00:12:18,314 --> 00:12:18,914
反馈

367
00:12:18,954 --> 00:12:21,474
geruby是创建什么的子据

368
00:12:21,514 --> 00:12:22,914
a数据分组

369
00:12:22,954 --> 00:12:24,234
b查询

370
00:12:24,274 --> 00:12:25,634
c条件

371
00:12:25,874 --> 00:12:27,274
d链接

372
00:12:27,754 --> 00:12:29,554
那么这道题的答案应该是谁呢

373
00:12:29,594 --> 00:12:31,234
很显然是a嘛

374
00:12:31,234 --> 00:12:33,834
是创建数据组的子据

375
00:12:33,874 --> 00:12:34,274
对吧

376
00:12:34,274 --> 00:12:35,434
所以这个题的答案是a

377
00:12:35,434 --> 00:12:36,594
好同学们

378
00:12:36,594 --> 00:12:37,314
那么以上呢

379
00:12:37,314 --> 00:12:38,354
我们就讲解了

380
00:12:38,394 --> 00:12:40,954
如何去创建数据分组

381
00:12:40,994 --> 00:12:41,274
好

382
00:12:41,274 --> 00:12:43,422
那我们这节课呢就到这

