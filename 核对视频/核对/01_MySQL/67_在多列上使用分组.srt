1
00:00:00,000 --> 00:00:01,050
< No Speech >

2
00:00:01,050 --> 00:00:07,330
上节课我们讲解了如何使用Gerbery子句来实现数据分组处理

3
00:00:07,330 --> 00:00:12,190
那么这节课我们再来看一下如何在多列上使用分组

4
00:00:13,178 --> 00:00:17,978
我们能不能在Grow by子句当中对多列进行分组处理呢

5
00:00:17,978 --> 00:00:19,178
答案肯定是可以的

6
00:00:19,178 --> 00:00:21,498
那么在一些特定的需求上

7
00:00:21,498 --> 00:00:24,938
我们确实是需要在多列上进行分组处理

8
00:00:24,938 --> 00:00:26,978
才能查到我们所要的数据的

9
00:00:26,978 --> 00:00:28,498
我们来看一下下面查询

10
00:00:28,498 --> 00:00:32,618
select department id job id

11
00:00:32,618 --> 00:00:34,498
还有sum用了一个sum函数

12
00:00:34,498 --> 00:00:35,858
并且把salary放到里面了

13
00:00:35,858 --> 00:00:39,338
这肯定是一个求薪水总额的

14
00:00:39,338 --> 00:00:41,538
这样的一个业务处理了

15
00:00:41,538 --> 00:00:41,938
对吧

16
00:00:41,938 --> 00:00:44,298
但是它查询的条件是什么呢

17
00:00:44,298 --> 00:00:44,978
我们看啊

18
00:00:44,978 --> 00:00:46,138
from安排一表

19
00:00:46,138 --> 00:00:47,738
然后后面跟个grow by子句

20
00:00:47,738 --> 00:00:48,734
注意看

21
00:00:49,338 --> 00:00:52,418
它是先对departmentid做分组了

22
00:00:52,418 --> 00:00:55,498
逗号又加了一个列叫jobid

23
00:00:55,498 --> 00:00:59,258
那么也就是说现在在gerbby子句当中

24
00:00:59,258 --> 00:01:01,298
对两个列做了数据分组

25
00:01:01,298 --> 00:01:05,138
那么现在它数据分组后的这个数据应该是什么样的呢

26
00:01:05,138 --> 00:01:06,738
我们要注意啊

27
00:01:06,738 --> 00:01:13,098
这个时候gerbby它对查到的数据先去按照departmentid分组

28
00:01:13,098 --> 00:01:15,618
先去按照departmentid分组

29
00:01:15,618 --> 00:01:19,978
等一下啊现在先按照departmentid分组

30
00:01:19,978 --> 00:01:24,458
在这个数据当中这一部分是departmentid分组的

31
00:01:24,458 --> 00:01:26,418
然后比如说这里有id

32
00:01:26,418 --> 00:01:27,898
departmentid是10的

33
00:01:27,898 --> 00:01:29,298
departmentid是20的

34
00:01:29,298 --> 00:01:30,698
departmentid是30的

35
00:01:30,698 --> 00:01:32,218
departmentid是50的

36
00:01:32,218 --> 00:01:36,578
然后呢由于你gerbby子句后面又加了一个jobid

37
00:01:36,578 --> 00:01:37,418
指的是什么呢

38
00:01:37,418 --> 00:01:40,298
在这个分组的基础之上

39
00:01:40,298 --> 00:01:46,178
注意啊是在departmentid分完组以后的这个基础之上

40
00:01:46,178 --> 00:01:49,138
再去按照jobid分组

41
00:01:49,138 --> 00:01:52,898
那么也就是说它会把这个分组数据当中

42
00:01:52,898 --> 00:01:55,738
再去找jobid相同的数据

43
00:01:55,738 --> 00:01:59,678
再去做一个分组的一个处理

44
00:02:00,282 --> 00:02:04,002
看到了吗同学们 最后可能会形成这样的一个结果集

45
00:02:04,002 --> 00:02:08,094
这根据你叫拜的这个数据来决定的

46
00:02:08,094 --> 00:02:10,618
< No Speech >

47
00:02:10,618 --> 00:02:11,738
看到了吗同学们

48
00:02:12,538 --> 00:02:14,458
那么相当于你现在的分组

49
00:02:14,458 --> 00:02:15,418
如果多列分组

50
00:02:15,418 --> 00:02:18,098
你这个分组的结果可能又被细化了

51
00:02:18,298 --> 00:02:18,818
对吧

52
00:02:18,858 --> 00:02:19,978
然后呢

53
00:02:20,018 --> 00:02:24,058
再对这些分组再去求薪水总额

54
00:02:24,618 --> 00:02:28,098
那么所以把这个C口语句翻译过来是什么

55
00:02:28,298 --> 00:02:36,538
是不是去求相同部门的相同工作岗位的薪水总额

56
00:02:36,538 --> 00:02:37,054
我还是最 late

57
00:02:37,850 --> 00:02:44,010
是吧同学们 相同部门的相同工作岗位的薪水总额

58
00:02:44,010 --> 00:02:48,130
所以对于这样的一个业务需求 我们肯定要去做多列分组的

59
00:02:48,130 --> 00:02:53,410
先按部门ID去分组 分完组之后再对相同的部门ID里再去做数据分组

60
00:02:53,410 --> 00:02:59,130
干嘛呢 把相同部门的数据里再去找他们的相同的交掰地再分组

61
00:02:59,130 --> 00:03:04,766
然后对这个最后的分组交掰地分完组的结果去做SUM函数运算

62
00:03:05,466 --> 00:03:06,946
能不能明白同学们

63
00:03:06,946 --> 00:03:09,186
这是在多列上分组的一个结果

64
00:03:09,186 --> 00:03:11,146
那么我们在使用多列分组时

65
00:03:11,146 --> 00:03:12,386
我可以告诉大家

66
00:03:12,746 --> 00:03:16,746
你的头脑里一定要有分完结果集的

67
00:03:16,746 --> 00:03:18,546
大概的一个效果图

68
00:03:18,546 --> 00:03:20,306
就像我刚才在这画的一样

69
00:03:20,506 --> 00:03:22,306
它分完组数据是什么样的

70
00:03:22,306 --> 00:03:25,426
然后在对交歪地再做分组时

71
00:03:25,746 --> 00:03:26,786
再做分组时

72
00:03:26,786 --> 00:03:28,426
那么这个效果又是什么样的

73
00:03:28,426 --> 00:03:30,346
你的头脑里必须要形成这种

74
00:03:30,386 --> 00:03:32,866
类似于能够看到数据分完组的

75
00:03:32,866 --> 00:03:34,466
这个结构的这样的一个图

76
00:03:34,466 --> 00:03:37,426
然后你才能知道你对于这样的一个查询

77
00:03:37,466 --> 00:03:38,786
使用这样的一个分组

78
00:03:38,786 --> 00:03:40,146
到底正确还是不正确

79
00:03:40,146 --> 00:03:41,986
是不是能拿到你想要的数据

80
00:03:42,466 --> 00:03:43,666
能明白我的意思吧同学们

81
00:03:43,666 --> 00:03:46,826
所以说在多列上分组也是很好理解的

82
00:03:46,826 --> 00:03:48,906
就是在一个分组的列的基础之上

83
00:03:49,266 --> 00:03:51,026
对分完组的列的结果集上

84
00:03:51,026 --> 00:03:52,546
又做了一些分组的处理

85
00:03:52,666 --> 00:03:53,346
明白这意思吧

86
00:03:53,346 --> 00:03:56,382
哎ok好我们看啊

87
00:03:57,146 --> 00:04:04,186
在组中分组,我们可以列出多个Globalized 字句返回的组和子组的摘要结果

88
00:04:04,186 --> 00:04:07,546
就是你可以在Globalized 字句当中对多个列进行分组

89
00:04:07,546 --> 00:04:13,346
可以用Globalized 字句中的列的顺序确定结果的默认排序顺序

90
00:04:13,346 --> 00:04:18,386
下面是图片当中,Selected 字句当中包含Globalized 字句时的求值过程

91
00:04:18,386 --> 00:04:20,986
就是我们看到的这个语句的求值过程

92
00:04:20,986 --> 00:04:25,106
首先,Selected 字句指定被返回的列

93
00:04:25,106 --> 00:04:28,946
要什么呢?要部门号,然后交班地

94
00:04:28,946 --> 00:04:33,386
然后在Globalized 字句当中指定了组当中所有薪水的合计

95
00:04:33,386 --> 00:04:35,826
因为我们要求所有的薪水的合计

96
00:04:35,826 --> 00:04:41,026
谁的薪水的合计呢?是相同部门的,相同的工作岗位的薪水的合计

97
00:04:41,026 --> 00:04:45,826
对不对?好,然后呢,From 字句是定位数据库当中必须访问的表

98
00:04:45,826 --> 00:04:46,866
那就是安普赖易

99
00:04:46,866 --> 00:04:50,906
然后Globalized 字句是指定你的数据怎样做分组处理

100
00:04:50,906 --> 00:04:53,346
首先先用部门号进行分组

101
00:04:53,346 --> 00:04:55,346
然后对部门号分组完以后

102
00:04:55,346 --> 00:04:59,706
再去用部门号分组中的结果,再用JobID进行分组

103
00:04:59,706 --> 00:05:01,826
分组当中又做了一个分组处理

104
00:05:01,826 --> 00:05:03,706
就形成了不同的小组,对吧?

105
00:05:03,706 --> 00:05:06,866
然后呢,最后SUM函数对于每个组的

106
00:05:06,866 --> 00:05:13,826
每个这个部门号的分组中的JobID的Salary列去求薪水的合计

107
00:05:13,826 --> 00:05:15,426
能不能明白这些东西吗?

108
00:05:15,426 --> 00:05:20,466
这是这个在多列当中分组的一个结果

109
00:05:20,466 --> 00:05:22,186
好,我们再来看一个示例

110
00:05:22,186 --> 00:05:29,426
现在这个示例要求计算每个部门的不同工作岗位的员工总数

111
00:05:29,426 --> 00:05:31,546
我们听这个题

112
00:05:31,546 --> 00:05:34,066
它这个题当中我们应该分析出三个内容

113
00:05:34,066 --> 00:05:35,946
第一,每个部门的

114
00:05:35,946 --> 00:05:38,786
第二,每个部门当中不同工作岗位的

115
00:05:38,786 --> 00:05:40,626
第三,员工总数

116
00:05:40,626 --> 00:05:42,106
那么员工总数怎么求?

117
00:05:42,106 --> 00:05:44,386
很好求,count就可以了,对不对?

118
00:05:44,386 --> 00:05:46,666
那么这个部门怎么做?

119
00:05:46,666 --> 00:05:50,346
每个部门的,那就Globalized部门Department of MyD不就可以了吗?

120
00:05:50,346 --> 00:05:54,386
然后它要求每个部门的不同工作岗位

121
00:05:54,386 --> 00:05:58,306
那我们是不是还得在部门分组当中再去对工作岗位做分组

122
00:05:58,306 --> 00:06:00,306
那就是这个JobID分组呗

123
00:06:00,306 --> 00:06:03,106
对吧?然后再去求员工总数嘛,是不是?

124
00:06:03,106 --> 00:06:05,866
好,那么对于这样一个需求我们该怎么去实现呢?

125
00:06:05,866 --> 00:06:07,546
这里我们来写一个

126
00:06:07,546 --> 00:06:09,666
首先Select

127
00:06:09,666 --> 00:06:12,426
然后呢,from,and apply

128
00:06:12,426 --> 00:06:14,750
对吧?然后呢,Group by

129
00:06:15,418 --> 00:06:17,418
那么我们现在要对谁做分组?

130
00:06:17,418 --> 00:06:19,418
< No Speech >

131
00:06:19,418 --> 00:06:23,298
一点是不是要对departmentid做分组

132
00:06:23,338 --> 00:06:23,778
对吧

133
00:06:23,818 --> 00:06:26,618
然后我们要求每个部门的不同工作

134
00:06:26,618 --> 00:06:27,058
岗位

135
00:06:27,058 --> 00:06:28,858
是不是还得对jobid做分组

136
00:06:28,858 --> 00:06:29,258
是吧

137
00:06:29,258 --> 00:06:31,778
那就一点jobid

138
00:06:32,058 --> 00:06:32,498
是吧

139
00:06:32,498 --> 00:06:33,258
然后要什么

140
00:06:33,258 --> 00:06:35,978
要一点departmentid

141
00:06:35,978 --> 00:06:37,658
一点jobid

142
00:06:37,658 --> 00:06:41,618
然后计算每个部门的不同工作岗位

143
00:06:41,618 --> 00:06:42,858
的人总人数

144
00:06:42,858 --> 00:06:45,258
那是不是还得用到一个count函数

145
00:06:45,418 --> 00:06:47,658
然后这里谁给星是不是就可以了

146
00:06:47,818 --> 00:06:48,418
对吧

147
00:06:48,418 --> 00:06:49,378
然后你行

148
00:06:49,698 --> 00:06:50,178
看到了吗

149
00:06:50,178 --> 00:06:50,778
同学们

150
00:06:50,978 --> 00:06:53,138
现在我们所查询到的结果

151
00:06:53,298 --> 00:06:56,418
就是每个部门下不同工作岗位的

152
00:06:56,418 --> 00:06:57,178
员工的总数

153
00:06:57,178 --> 00:06:57,778
我们看一下

154
00:06:57,778 --> 00:06:59,738
这没有部门的是1

155
00:06:59,738 --> 00:07:00,178
对吧

156
00:07:00,178 --> 00:07:01,618
然后部门id是10的

157
00:07:01,618 --> 00:07:03,178
jobid是他的一个人

158
00:07:03,378 --> 00:07:04,138
只有一个人

159
00:07:04,138 --> 00:07:05,858
然后部门id是20的

160
00:07:05,858 --> 00:07:07,138
有两个工作岗位

161
00:07:07,138 --> 00:07:07,738
看到了吗

162
00:07:07,778 --> 00:07:10,498
那么每个工作岗位下分别有一人

163
00:07:10,858 --> 00:07:11,298
是吧

164
00:07:11,298 --> 00:07:12,898
然后部门id为30的

165
00:07:12,898 --> 00:07:14,298
也是有两个工作岗位

166
00:07:14,578 --> 00:07:16,218
其中一个工作岗位有5人

167
00:07:16,218 --> 00:07:17,618
一个工作岗位有一个人

168
00:07:17,618 --> 00:07:20,058
然后像部门id为50的

169
00:07:20,058 --> 00:07:21,338
他也是有两个工作岗位

170
00:07:21,338 --> 00:07:23,538
那么两个工作岗位当中人数分别是

171
00:07:23,538 --> 00:07:24,418
20和20

172
00:07:24,618 --> 00:07:25,458
他还有三个

173
00:07:25,538 --> 00:07:26,258
这还有一个

174
00:07:26,258 --> 00:07:26,698
是吧

175
00:07:26,698 --> 00:07:28,018
然后工作岗位是5人

176
00:07:28,458 --> 00:07:28,938
看到了吗

177
00:07:28,938 --> 00:07:29,498
同学们

178
00:07:29,538 --> 00:07:32,098
这样就查到了我们所需要的数据

179
00:07:32,098 --> 00:07:35,658
所以当我们在处理这样的查询时

180
00:07:35,658 --> 00:07:38,338
我们肯定会用到多列分组的

181
00:07:38,738 --> 00:07:39,618
还是那句话

182
00:07:39,738 --> 00:07:42,098
一旦我们要用多列分组去做

183
00:07:42,098 --> 00:07:44,058
结果级的求值处理时

184
00:07:44,058 --> 00:07:47,858
我们的头脑里一定要有结果级

185
00:07:47,858 --> 00:07:50,418
分完组以后的数据的一个大概的

186
00:07:50,418 --> 00:07:51,538
一个结构图

187
00:07:51,858 --> 00:07:52,378
明白吧

188
00:07:52,618 --> 00:07:53,858
这样我们就能知道

189
00:07:53,858 --> 00:07:54,978
在这个结构当中

190
00:07:54,978 --> 00:07:57,338
我们的查询是否正确了

191
00:07:57,618 --> 00:07:58,178
OK

192
00:07:58,698 --> 00:07:59,018
好

193
00:07:59,018 --> 00:08:00,978
我们再来看一个实时效果反馈

194
00:08:01,098 --> 00:08:03,218
如下说法正确的是

195
00:08:03,218 --> 00:08:03,698
A

196
00:08:03,978 --> 00:08:06,738
Group by子句可以链接多个表

197
00:08:06,858 --> 00:08:07,418
B

198
00:08:07,538 --> 00:08:10,298
Group by子句可以给定多个条件

199
00:08:10,378 --> 00:08:11,098
C

200
00:08:11,098 --> 00:08:14,778
Group by子句可以对多个列进行分组

201
00:08:14,778 --> 00:08:15,298
D

202
00:08:15,298 --> 00:08:18,778
Group by子句可以出现在val子句的前面

203
00:08:19,258 --> 00:08:20,778
那么在这四个选项当中

204
00:08:20,778 --> 00:08:22,298
哪个选项是正确的呢

205
00:08:22,658 --> 00:08:23,578
很显然是C

206
00:08:23,978 --> 00:08:26,338
Group by子句可以对多列进行分组

207
00:08:26,338 --> 00:08:26,738
对吧

208
00:08:26,738 --> 00:08:27,978
我们看A

209
00:08:28,138 --> 00:08:30,258
Group by子句可以链接多个表吗

210
00:08:30,258 --> 00:08:31,098
肯定是不可以的

211
00:08:31,098 --> 00:08:31,898
Group by子句

212
00:08:31,898 --> 00:08:34,258
它不是做链接的这样的一个子句

213
00:08:34,258 --> 00:08:34,578
对不对

214
00:08:34,578 --> 00:08:35,858
多表链接的子句它不是的

215
00:08:36,178 --> 00:08:36,738
然后B

216
00:08:36,938 --> 00:08:38,978
Group by子句可以给定多个条件吗

217
00:08:39,018 --> 00:08:41,018
Group by子句它是做数据分组的

218
00:08:41,018 --> 00:08:42,138
它也不是给定条件的

219
00:08:42,138 --> 00:08:42,498
对不对

220
00:08:42,498 --> 00:08:44,098
然后C是正确的

221
00:08:44,258 --> 00:08:44,538
D

222
00:08:44,538 --> 00:08:47,858
Group by子句可以出现在val子句的前面吗

223
00:08:48,058 --> 00:08:48,538
不可以

224
00:08:48,538 --> 00:08:49,538
我们上一课就说了

225
00:08:49,618 --> 00:08:52,178
Group by子句只能出现在val子句的后面

226
00:08:52,178 --> 00:08:55,338
因为它是对查询完以后的结果集

227
00:08:55,378 --> 00:08:57,018
去做数据分组的

228
00:08:57,018 --> 00:08:57,458
对吧

229
00:08:57,458 --> 00:08:59,978
那么val子句是你做查询数据之前的

230
00:08:59,978 --> 00:09:01,178
一个条件的过滤

231
00:09:01,338 --> 00:09:03,618
所以它肯定要在val子句肯定要在

232
00:09:03,618 --> 00:09:05,058
Group by子句的前面的

233
00:09:05,058 --> 00:09:05,738
明白这意思吧

234
00:09:05,738 --> 00:09:08,018
所以这个题的答案是C

235
00:09:08,018 --> 00:09:08,698
好

236
00:09:08,698 --> 00:09:09,058
同学们

237
00:09:09,058 --> 00:09:10,578
那么以上我们就讲解了

238
00:09:10,578 --> 00:09:13,338
如何通过Group by对多列进行分组

239
00:09:13,338 --> 00:09:13,898
好

240
00:09:13,898 --> 00:09:16,030
那我们这一课就到这

