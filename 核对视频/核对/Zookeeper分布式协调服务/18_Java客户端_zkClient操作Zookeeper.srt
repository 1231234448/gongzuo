1
00:00:00,090 --> 00:00:01,570
Hello 小伙伴大家好

2
00:00:01,570 --> 00:00:05,090
这节课我们来学习如何通过ZKCLAM的这个库

3
00:00:05,090 --> 00:00:07,730
来操作这个RuKPer的一个服务

4
00:00:07,730 --> 00:00:11,770
我们之前使用的是这个RuKPer的原生API去做的

5
00:00:11,770 --> 00:00:13,490
可能我们会遇到一些问题

6
00:00:13,490 --> 00:00:16,490
比如说我们需要重复注册Water

7
00:00:16,490 --> 00:00:19,650
当然我们之前所说过这个Water它只有一次

8
00:00:19,650 --> 00:00:23,530
那如果说你还需要对我们某一个节点进行监听的话

9
00:00:23,530 --> 00:00:25,210
我们需要重复注册

10
00:00:25,210 --> 00:00:28,370
第二个就是这个筛审失效重连的问题

11
00:00:28,370 --> 00:00:30,730
第三个就是一些议程的处理

12
00:00:30,730 --> 00:00:33,930
比如说我们删除节点的时候不能删除子节点

13
00:00:33,930 --> 00:00:38,330
又比如说我们在新增节点的时候必须得有副节点

14
00:00:38,330 --> 00:00:42,250
这些在实际的工作中还是比较繁琐的

15
00:00:42,250 --> 00:00:50,210
随着这个ZKCLAM它是GitHub上一个开源的RuKPer的客户端

16
00:00:50,210 --> 00:00:56,210
所以说它在原来的这个RuKPer的原生API接口之上做了一些包装

17
00:00:56,210 --> 00:01:00,370
所以说变的是一个什么呢 更加易用的一个RuKPer客户端了

18
00:01:00,370 --> 00:01:02,930
所以说人家内部也是干嘛呢

19
00:01:02,930 --> 00:01:04,730
把这些诸多的问题给解决了

20
00:01:04,730 --> 00:01:10,330
比如说筛审超时重连或者是这个Water反复注册的这些功能

21
00:01:10,330 --> 00:01:11,650
人家都给我们解决了

22
00:01:11,650 --> 00:01:17,170
所以说小伙伴在开发的过程中就不需要考虑这些细节问题了

23
00:01:17,170 --> 00:01:19,930
从而是不是可以提高我们的一个开发效率

24
00:01:19,930 --> 00:01:25,210
我们接下来我们来看一下这个ZKCLAM的这个库我们该如何去玩

25
00:01:25,210 --> 00:01:27,930
首先第一步既然说我们要玩这个库

26
00:01:27,930 --> 00:01:30,490
那我们是得先引入人家这个库的包吧

27
00:01:30,490 --> 00:01:32,050
把人家这个依赖给引进来

28
00:01:32,050 --> 00:01:33,970
我们把这句话直接复制上

29
00:01:33,970 --> 00:01:35,410
打开我们的一个编译器

30
00:01:35,410 --> 00:01:38,770
那在这块我们直接这个是我们的原生API是不是

31
00:01:38,770 --> 00:01:39,650
把它给注册掉

32
00:01:39,650 --> 00:01:43,690
然后我们再加一个我们这个ZKCLAM的这个包

33
00:01:43,690 --> 00:01:47,770
那我们加上之后在这块我们再创建一个实体类

34
00:01:47,770 --> 00:01:52,050
我们就叫它ZKCLAMP

35
00:01:52,050 --> 00:01:55,330
ZKCLAMP什么呢?MAY方法

36
00:01:55,330 --> 00:01:56,330
ZKCLAMP的MAY

37
00:01:56,330 --> 00:01:58,530
然后在这个里边我们编写一个MAY方法

38
00:01:58,530 --> 00:01:59,730
编写一个主类

39
00:01:59,730 --> 00:02:01,810
那这个主类我们主要干嘛呢

40
00:02:01,810 --> 00:02:05,650
就是去做ZKCLAMP的一个什么呢

41
00:02:05,650 --> 00:02:09,930
操作这个操作Rookkeeper的一个API

42
00:02:09,930 --> 00:02:10,450
OK

43
00:02:10,450 --> 00:02:12,530
就是通过这个库来操作Rookkeeper

44
00:02:12,530 --> 00:02:14,890
我们之前通过的是原生API去做的

45
00:02:14,890 --> 00:02:15,370
是吧

46
00:02:15,370 --> 00:02:17,050
那第一步大家注意

47
00:02:17,050 --> 00:02:19,810
那我既然说我要用这个库来操作Rookkeeper

48
00:02:19,810 --> 00:02:21,930
那第一步永远都是什么呢

49
00:02:21,930 --> 00:02:24,930
永远都是创建绘画

50
00:02:24,930 --> 00:02:25,730
没问题吧

51
00:02:25,730 --> 00:02:27,930
创建一个绘画

52
00:02:27,930 --> 00:02:29,770
你不管是连接的是Rookkeeper服务

53
00:02:29,770 --> 00:02:30,770
还是Redis服务

54
00:02:30,770 --> 00:02:32,090
还是等等一些别的服务

55
00:02:32,090 --> 00:02:33,890
那第一步永远都是创建绘画

56
00:02:33,890 --> 00:02:35,530
那我们这个该如何去做呢

57
00:02:35,530 --> 00:02:38,970
我们new一个ZKCLAMP

58
00:02:38,970 --> 00:02:40,130
在这个ZKCLAMP里边

59
00:02:40,130 --> 00:02:44,170
我们只需要编写我们192.168.66.121

60
00:02:44,170 --> 00:02:46,290
2181

61
00:02:46,290 --> 00:02:47,050
没问题吧

62
00:02:47,050 --> 00:02:50,210
然后在这个里边我们写一个

63
00:02:50,210 --> 00:02:50,430
完然吧

64
00:02:50,430 --> 00:02:51,450
< No Speech >

65
00:02:51,450 --> 00:02:53,890
走你豆花走你OK

66
00:02:53,890 --> 00:02:54,810
一个是101

67
00:02:54,810 --> 00:02:56,530
一个是102

68
00:02:56,530 --> 00:02:58,410
一个是103

69
00:02:58,490 --> 00:02:59,290
没问题吧

70
00:02:59,490 --> 00:03:00,450
我们这个绘画

71
00:03:00,450 --> 00:03:01,770
我们就通过这个

72
00:03:01,810 --> 00:03:03,250
newzkclan的

73
00:03:03,250 --> 00:03:04,370
我们就给他创建出来了

74
00:03:04,370 --> 00:03:05,370
非常的简单

75
00:03:05,370 --> 00:03:07,730
第一个创建一个绘画

76
00:03:08,490 --> 00:03:10,930
zkclan的返回值

77
00:03:10,930 --> 00:03:12,210
就给他写一个zk吧

78
00:03:12,730 --> 00:03:14,290
第一步我们创建绘画

79
00:03:14,290 --> 00:03:15,730
就已经完成了

80
00:03:15,890 --> 00:03:17,490
就是大功告成

81
00:03:17,730 --> 00:03:19,370
接下来我们来看一下

82
00:03:19,370 --> 00:03:22,850
我们该如何获取节点的变化

83
00:03:23,050 --> 00:03:25,570
就是我们该如何获取节点

84
00:03:26,130 --> 00:03:28,170
获取子节点

85
00:03:28,650 --> 00:03:29,770
如何获取子节点

86
00:03:30,250 --> 00:03:32,930
来打开我们命令王终端

87
00:03:33,050 --> 00:03:34,930
在这块我们通过ls看一下

88
00:03:34,930 --> 00:03:36,370
我们有一个node1

89
00:03:36,370 --> 00:03:37,450
我们再来看一下

90
00:03:37,690 --> 00:03:40,250
node1里边有个b是不是

91
00:03:40,250 --> 00:03:43,570
然后我们在create创建一个

92
00:03:43,570 --> 00:03:45,370
node1里边放一个a

93
00:03:45,370 --> 00:03:46,010
再来一个a

94
00:03:46,010 --> 00:03:46,370
OK

95
00:03:46,370 --> 00:03:47,730
那你说在node1里边

96
00:03:47,730 --> 00:03:49,370
是不是又有个a的子节点了

97
00:03:49,530 --> 00:03:50,250
这个时候假如说

98
00:03:50,250 --> 00:03:52,370
我要获取一个子节点

99
00:03:52,370 --> 00:03:53,570
我想获取一个节点

100
00:03:53,570 --> 00:03:54,450
下面的子节点

101
00:03:54,450 --> 00:03:55,450
我们该如何去做

102
00:03:55,450 --> 00:03:56,770
zk点什么

103
00:03:57,610 --> 00:03:59,330
点getchildren没问题

104
00:03:59,690 --> 00:04:00,570
然后在这个位置中

105
00:04:00,570 --> 00:04:02,090
我们直接编写一个

106
00:04:02,090 --> 00:04:04,810
叫做node1

107
00:04:05,330 --> 00:04:06,210
非常简单

108
00:04:06,250 --> 00:04:08,130
返回值它是一个list

109
00:04:08,130 --> 00:04:08,970
这个list里边

110
00:04:08,970 --> 00:04:09,730
是不是包含的

111
00:04:09,730 --> 00:04:11,370
< No Speech >

112
00:04:11,370 --> 00:04:12,530
list里边是不是包含的

113
00:04:12,530 --> 00:04:14,530
就是我们所有的子节点了

114
00:04:15,250 --> 00:04:15,770
没有问题

115
00:04:15,770 --> 00:04:17,890
我们直接把这个东东

116
00:04:17,890 --> 00:04:20,130
我们是不是可以直接给它

117
00:04:20,130 --> 00:04:21,010
便利出来

118
00:04:21,010 --> 00:04:21,410
是不是

119
00:04:21,410 --> 00:04:23,570
我们通过for each

120
00:04:24,250 --> 00:04:26,250
我们通过for each的这种方式

121
00:04:26,490 --> 00:04:28,210
我们把它给便利出来

122
00:04:28,210 --> 00:04:29,530
< No Speech >

123
00:04:29,530 --> 00:04:30,330
走你

124
00:04:30,490 --> 00:04:31,490
然后在这个位置中

125
00:04:31,610 --> 00:04:34,290
我们直接打印输出 f

126
00:04:34,690 --> 00:04:35,330
打印输出这个

127
00:04:35,330 --> 00:04:37,170
那这个是不是我们的子节点了

128
00:04:37,370 --> 00:04:39,330
我们直接运行一下

129
00:04:39,730 --> 00:04:40,570
运行一下

130
00:04:40,570 --> 00:04:41,890
老是这种写法

131
00:04:42,010 --> 00:04:42,410
就是一种

132
00:04:42,410 --> 00:04:43,770
Lambda表达式的这种写法

133
00:04:43,930 --> 00:04:45,490
你看a和b

134
00:04:45,490 --> 00:04:46,450
给我们打印出来了

135
00:04:46,450 --> 00:04:48,210
这就是获取子节点

136
00:04:48,210 --> 00:04:48,530
OK

137
00:04:49,170 --> 00:04:49,810
完了之后

138
00:04:50,410 --> 00:04:51,490
我们看第三步

139
00:04:51,650 --> 00:04:54,290
我们该如何创建节点

140
00:04:54,770 --> 00:04:56,530
我们学会了如何获取子节点

141
00:04:56,730 --> 00:04:58,610
我们再来看如何创建节点

142
00:04:58,690 --> 00:05:00,130
在原生的API中

143
00:05:00,130 --> 00:05:01,530
我们通过create

144
00:05:01,730 --> 00:05:03,330
这个方法创建节点

145
00:05:03,570 --> 00:05:04,290
在这个里边

146
00:05:04,290 --> 00:05:05,290
我们来看看通过什么

147
00:05:05,730 --> 00:05:06,930
zk.

148
00:05:06,930 --> 00:05:07,810
能不能create了

149
00:05:08,130 --> 00:05:08,930
也可以

150
00:05:08,930 --> 00:05:09,530
是不是

151
00:05:09,570 --> 00:05:10,890
里面有一堆参数

152
00:05:10,890 --> 00:05:12,130
这个参数里边写什么

153
00:05:13,050 --> 00:05:14,610
我们来看第一个位置pass

154
00:05:14,610 --> 00:05:17,250
我们来写no的2

155
00:05:17,450 --> 00:05:19,010
这个代表就是节点的名字

156
00:05:19,250 --> 00:05:19,970
很简单

157
00:05:19,970 --> 00:05:21,890
第二个代表的是我们节点的数据

158
00:05:21,890 --> 00:05:22,370
是不是

159
00:05:22,370 --> 00:05:24,810
第三个代表的是我们节点的类型

160
00:05:24,810 --> 00:05:26,890
这个类型就是create model

161
00:05:26,890 --> 00:05:27,090
什么

162
00:05:27,450 --> 00:05:29,130
我们的持久化节点

163
00:05:29,250 --> 00:05:29,610
没问题

164
00:05:29,930 --> 00:05:30,850
我们通过这句话

165
00:05:31,250 --> 00:05:33,010
就创建了一个节点

166
00:05:33,250 --> 00:05:34,490
我们就创建了一个节点

167
00:05:34,530 --> 00:05:35,290
然后在这句话

168
00:05:35,410 --> 00:05:37,130
我们最下面我们写一句话

169
00:05:37,210 --> 00:05:39,850
我就说创建节点成功

170
00:05:40,290 --> 00:05:41,050
非常的简单

171
00:05:41,050 --> 00:05:42,130
把这个我们注释掉

172
00:05:42,250 --> 00:05:43,650
不然一直打印太麻烦了

173
00:05:43,650 --> 00:05:45,690
我们直接运行走你

174
00:05:45,730 --> 00:05:46,490
来看一下

175
00:05:47,170 --> 00:05:48,810
最后他说节点创建成功

176
00:05:48,810 --> 00:05:50,090
帮我们创建了一个no的2

177
00:05:50,090 --> 00:05:52,330
在这块我们直接ls斜杠

178
00:05:52,330 --> 00:05:54,370
看看no的2出来了

179
00:05:54,370 --> 00:05:56,370
是不是创建节点成功

180
00:05:56,730 --> 00:05:59,690
完成之后我们来再看第4个功能

181
00:05:59,690 --> 00:06:00,850
< No Speech >

182
00:06:00,850 --> 00:06:01,610
第4个

183
00:06:01,850 --> 00:06:03,090
第4个我们来看一下

184
00:06:03,090 --> 00:06:04,570
我们该如何修改

185
00:06:04,810 --> 00:06:06,090
no的2的节点数据

186
00:06:06,330 --> 00:06:07,850
第一个我们该修改

187
00:06:08,490 --> 00:06:10,890
修改节点数据

188
00:06:11,290 --> 00:06:13,090
我们zk点之前

189
00:06:13,090 --> 00:06:14,890
我们要修改是通过set

190
00:06:15,170 --> 00:06:15,570
是吧

191
00:06:15,570 --> 00:06:17,410
set你看这块它只能set什么

192
00:06:17,490 --> 00:06:18,570
set一个序列化

193
00:06:18,970 --> 00:06:22,450
set一个我们start

194
00:06:22,730 --> 00:06:25,610
还要set一个acl权限

195
00:06:25,810 --> 00:06:27,090
我们不对是吧

196
00:06:27,250 --> 00:06:28,730
那就叫write

197
00:06:28,850 --> 00:06:30,730
你看写一个数据

198
00:06:30,890 --> 00:06:31,730
非常简单

199
00:06:31,850 --> 00:06:33,370
这块我们要给哪一个写个数据

200
00:06:33,490 --> 00:06:35,010
叫no的2写个数据

201
00:06:35,130 --> 00:06:35,770
值是多少

202
00:06:36,250 --> 00:06:38,770
它的值就是我们需要修改的值

203
00:06:38,770 --> 00:06:40,490
比如说给它来个百占

204
00:06:40,650 --> 00:06:42,770
简单把这个我们注释掉

205
00:06:42,770 --> 00:06:44,450
我们把这句话执行一下

206
00:06:44,450 --> 00:06:47,410
我们的no的2里边就变成百占了

207
00:06:47,650 --> 00:06:48,610
我们运行一下看看

208
00:06:49,450 --> 00:06:50,610
然后运行完成之后

209
00:06:50,810 --> 00:06:51,970
打开我们的面联合中文

210
00:06:52,010 --> 00:06:55,570
我们通过什么get no的2来看一下

211
00:06:55,890 --> 00:06:58,090
你看里边是变成了百占没问题

212
00:06:58,570 --> 00:06:59,970
完成之后我们再来继续看

213
00:07:00,210 --> 00:07:01,930
我们通过可以修改数据

214
00:07:01,930 --> 00:07:02,410
是吧

215
00:07:02,530 --> 00:07:05,610
第5个我们该如何删除

216
00:07:05,610 --> 00:07:09,054
我该如何删除数据

217
00:07:09,818 --> 00:07:10,778
删除数据

218
00:07:10,778 --> 00:07:12,738
当然我们在删除数据之前

219
00:07:12,818 --> 00:07:14,058
我们先获取一下数据

220
00:07:14,258 --> 00:07:15,218
获取数据

221
00:07:15,218 --> 00:07:17,618
不然我们删掉没有数据获取了

222
00:07:18,138 --> 00:07:19,498
我们就通过zk

223
00:07:19,658 --> 00:07:20,858
zk.

224
00:07:20,858 --> 00:07:22,618
你看写叫write

225
00:07:22,938 --> 00:07:24,418
读不就叫write吗

226
00:07:24,418 --> 00:07:25,178
你看write data

227
00:07:25,178 --> 00:07:27,098
然后里边我们放一个斜杠

228
00:07:27,098 --> 00:07:28,658
node2是吧

229
00:07:28,658 --> 00:07:29,538
然后在这个位置中

230
00:07:29,658 --> 00:07:31,338
我们来一个看看它的返回值

231
00:07:31,338 --> 00:07:32,058
object

232
00:07:32,298 --> 00:07:33,738
我们直接是不是可以给大家来一个

233
00:07:33,738 --> 00:07:34,378
死准类型

234
00:07:34,738 --> 00:07:36,498
你看之前我们的返回值

235
00:07:36,498 --> 00:07:37,978
在原生的API中

236
00:07:37,978 --> 00:07:40,338
它的返回值是不是一个叫做

237
00:07:40,378 --> 00:07:41,338
Bit数组

238
00:07:41,338 --> 00:07:41,938
是不是

239
00:07:41,938 --> 00:07:43,578
但是在我们的zk

240
00:07:43,578 --> 00:07:43,938
client

241
00:07:43,938 --> 00:07:45,258
你看返回的是一个死人类型

242
00:07:45,378 --> 00:07:47,058
这就是人家给我们包装的好处

243
00:07:47,058 --> 00:07:47,658
是不是

244
00:07:47,658 --> 00:07:49,258
然后我们直接把o放进去

245
00:07:49,258 --> 00:07:51,298
是不是得到了我们具体的一个结果值了

246
00:07:51,298 --> 00:07:52,218
非常的方便

247
00:07:52,538 --> 00:07:53,538
就是我们通过这种方式

248
00:07:53,698 --> 00:07:55,338
我们就可以获取数据

249
00:07:55,738 --> 00:07:56,338
第6个

250
00:07:56,618 --> 00:07:57,458
我们来看第6步

251
00:07:57,458 --> 00:08:00,298
我们看看该如何删除数据

252
00:08:00,298 --> 00:08:01,058
删除数据

253
00:08:01,058 --> 00:08:03,698
我们直接通过zk.delete

254
00:08:03,858 --> 00:08:05,978
简单通过delete的这种方式

255
00:08:05,978 --> 00:08:07,418
我们就可以删除所有

256
00:08:07,418 --> 00:08:10,178
我们可以删除斜杠node2的数据

257
00:08:10,698 --> 00:08:11,298
OK

258
00:08:11,618 --> 00:08:12,658
这个获取数据

259
00:08:12,658 --> 00:08:13,498
这个删除数据

260
00:08:13,498 --> 00:08:14,298
我们直接注掉

261
00:08:14,418 --> 00:08:15,098
老是不运行了

262
00:08:15,098 --> 00:08:15,738
因为一运行

263
00:08:15,858 --> 00:08:17,378
我们节点就被删除掉了

264
00:08:17,378 --> 00:08:19,218
因为我们还要去做下一步操作

265
00:08:19,218 --> 00:08:19,938
是不是

266
00:08:20,258 --> 00:08:21,098
第7个

267
00:08:21,258 --> 00:08:21,978
我们来看看

268
00:08:21,978 --> 00:08:23,658
在zkclient里边

269
00:08:23,658 --> 00:08:25,658
我们该如何注册监听

270
00:08:26,018 --> 00:08:28,058
我们该如何注册一个

271
00:08:28,058 --> 00:08:30,418
就是我该如何注册一个什么

272
00:08:30,818 --> 00:08:34,738
数据的一个监听事件

273
00:08:34,738 --> 00:08:37,458
我如何注册一个数据监听的事件

274
00:08:37,818 --> 00:08:39,738
我们通过zk.sub

275
00:08:39,738 --> 00:08:40,418
大家注意看

276
00:08:40,418 --> 00:08:42,018
这块叫tutorialchanges

277
00:08:42,018 --> 00:08:43,578
这块有个叫datatransfer

278
00:08:43,578 --> 00:08:44,458
一个是数据的

279
00:08:44,458 --> 00:08:45,058
一个是节点的

280
00:08:45,058 --> 00:08:45,458
是吧

281
00:08:45,458 --> 00:08:46,498
那我就先写个节点的

282
00:08:46,498 --> 00:08:49,298
然后在这个节点的方法里边

283
00:08:49,298 --> 00:08:50,338
大家注意前面是pass

284
00:08:50,338 --> 00:08:53,738
后边是一个叫zklistener

285
00:08:53,738 --> 00:08:56,018
就是我们这个叫什么

286
00:08:56,018 --> 00:08:57,738
这个叫监听机制

287
00:08:57,738 --> 00:08:58,218
是吧

288
00:08:58,498 --> 00:09:01,058
然后我们再来个监听

289
00:09:01,058 --> 00:09:01,698
我们node

290
00:09:01,698 --> 00:09:02,818
你有一个

291
00:09:02,818 --> 00:09:03,418
你有一个

292
00:09:03,418 --> 00:09:03,454
小伙伴

293
00:09:04,090 --> 00:09:07,330
你看有个叫izkchildren

294
00:09:07,330 --> 00:09:09,090
什么什么listener是吧

295
00:09:09,090 --> 00:09:10,570
然后在这个位置中大家注意

296
00:09:10,570 --> 00:09:12,930
你看他写了一个这个节点的数据改变了

297
00:09:12,930 --> 00:09:15,050
并且呢把这个改变完的子节点

298
00:09:15,050 --> 00:09:16,410
是不是也给我们显示了一下

299
00:09:16,410 --> 00:09:17,650
来把这个写到这

300
00:09:17,650 --> 00:09:19,770
我们叫我们看看啊

301
00:09:19,770 --> 00:09:21,850
呃在这个里边我们说有个node1啊

302
00:09:21,850 --> 00:09:25,170
来看一下node1里边是不是有那个东东啊

303
00:09:25,170 --> 00:09:25,930
你看啊

304
00:09:25,930 --> 00:09:29,610
node1里边我们应该是有一个呃有子节点的啊

305
00:09:29,610 --> 00:09:29,790
9

306
00:09:30,330 --> 00:09:32,070
诶,node1里边也没了

307
00:09:32,070 --> 00:09:34,470
那我们呢,诶,不是啊,node1嘛

308
00:09:34,470 --> 00:09:36,150
1里边是不是还有个a和b啊

309
00:09:36,150 --> 00:09:38,070
呃,然后呢我们就看看这个node1

310
00:09:38,070 --> 00:09:39,410
啊,这个node1

311
00:09:39,410 --> 00:09:41,410
这个node1呢,如果这个node1

312
00:09:41,410 --> 00:09:44,210
事件发生了改变,则进行一个毁掉,是吧

313
00:09:44,210 --> 00:09:47,110
毁掉的时候呢,它是不是会触发到这个函数里边

314
00:09:47,110 --> 00:09:50,870
在这个里边呢,我就说数据改变了

315
00:09:50,870 --> 00:09:52,610
啊,数据发生了改变

316
00:09:52,610 --> 00:09:54,990
那改变完后长什么样子呢

317
00:09:55,410 --> 00:09:56,810
是不是叫这个名啊

318
00:09:56,810 --> 00:09:57,810
是不是它呀

319
00:09:57,810 --> 00:10:02,290
它,你看我们通过.foreach的这种方式

320
00:10:02,290 --> 00:10:05,730
然后呢,f,箭头,花棍号的这种方式

321
00:10:05,730 --> 00:10:08,450
我们是不是可以直接把这个f进行输出

322
00:10:08,450 --> 00:10:09,890
没问题吧,这就是什么呢

323
00:10:09,890 --> 00:10:11,210
我们监听了一个事件

324
00:10:11,210 --> 00:10:12,410
当然呢我们还需要干嘛呢

325
00:10:12,410 --> 00:10:15,810
我们还需要让它永久的睡它的十万年

326
00:10:15,810 --> 00:10:18,770
啊,我们让它烙类型点

327
00:10:18,770 --> 00:10:19,850
什么呢,value啊

328
00:10:19,850 --> 00:10:21,690
让它永久的睡眠下去

329
00:10:21,690 --> 00:10:23,970
帮我们去做一个监听的一个机制

330
00:10:23,970 --> 00:10:24,770
来吧

331
00:10:24,770 --> 00:10:28,170
我们点击这个debug的方式运行啊

332
00:10:28,170 --> 00:10:29,170
运行完之后呢

333
00:10:29,170 --> 00:10:30,770
我们直接在这个里边

334
00:10:30,770 --> 00:10:33,250
我们对它这个节点进行一个删除操作

335
00:10:33,250 --> 00:10:37,770
delete,删除node1里边的a

336
00:10:37,770 --> 00:10:38,570
走你

337
00:10:38,570 --> 00:10:40,930
就是我把这个node1里面的a给它干掉了

338
00:10:40,930 --> 00:10:42,130
然后呢我们会发现你看

339
00:10:42,130 --> 00:10:43,450
数据发生了改变了

340
00:10:43,450 --> 00:10:45,890
但是里面的节点你看是不是只剩下一个b了

341
00:10:45,890 --> 00:10:46,490
简单吧

342
00:10:46,490 --> 00:10:47,730
就是我们通过这种方式啊

343
00:10:47,730 --> 00:10:48,770
也可以对这些什么呢

344
00:10:48,770 --> 00:10:51,290
对注册的数据进行了什么呢

345
00:10:51,290 --> 00:10:51,850
数据啊

346
00:10:51,850 --> 00:10:53,010
这是数据是吧

347
00:10:53,010 --> 00:10:54,650
那我们应该是节点

348
00:10:54,650 --> 00:10:55,250
节点

349
00:10:55,250 --> 00:10:56,890
< No Speech >

350
00:10:56,890 --> 00:10:59,490
本来是要讲数据的 讲到这跑偏了是吧

351
00:10:59,490 --> 00:11:01,490
那我们接下来再看 再讲一个

352
00:11:01,490 --> 00:11:02,906
< No Speech >

353
00:11:02,906 --> 00:11:03,906
第八个

354
00:11:03,906 --> 00:11:06,106
第八个我们就真正的去干嘛呢

355
00:11:06,106 --> 00:11:09,346
去讲注册节点的数据

356
00:11:09,346 --> 00:11:11,546
就是数据的监听时间

357
00:11:11,546 --> 00:11:13,690
< No Speech >

358
00:11:13,690 --> 00:11:15,690
那么把这个给大家注释掉

359
00:11:15,690 --> 00:11:16,490
OK

360
00:11:16,490 --> 00:11:18,890
那完了之后我们走你

361
00:11:18,890 --> 00:11:20,970
那我要监听数据了

362
00:11:20,970 --> 00:11:22,610
那还是zk点

363
00:11:22,610 --> 00:11:25,370
你看这个是我们监听节点的

364
00:11:25,370 --> 00:11:28,050
那su你看有一个叫data称是吧

365
00:11:28,050 --> 00:11:30,690
第一个位置我们要放的是node2

366
00:11:31,050 --> 00:11:33,690
然后第二个位置我们要new的是一个i

367
00:11:33,690 --> 00:11:35,010
你看是data listener

368
00:11:35,010 --> 00:11:37,250
就是针对于数据的一个listener

369
00:11:37,250 --> 00:11:39,410
上面这个是如果说数据发生了改变

370
00:11:39,410 --> 00:11:40,930
则干嘛呢

371
00:11:40,930 --> 00:11:43,770
触发这个就是数据改变了

372
00:11:43,770 --> 00:11:46,250
然后到下面是数据被删除的时候

373
00:11:46,250 --> 00:11:50,530
你看数据就是数据

374
00:11:50,530 --> 00:11:54,014
这个数据被删除了

375
00:11:54,014 --> 00:11:55,162
< No Speech >

376
00:11:55,162 --> 00:11:58,002
数据被删除了则触发这个毁掉函数

377
00:11:58,002 --> 00:11:58,562
OK

378
00:11:58,562 --> 00:12:00,482
然后我们继续运行一下

379
00:12:00,482 --> 00:12:02,282
我们有一个node2是不是

380
00:12:02,282 --> 00:12:04,282
然后我们再把这个数据给删掉之后

381
00:12:04,282 --> 00:12:05,762
我们看看它会不会毁掉到这

382
00:12:05,762 --> 00:12:06,762
会不会毁掉到这

383
00:12:06,762 --> 00:12:07,282
OK

384
00:12:07,482 --> 00:12:09,402
我们打开我们的命令和漏断

385
00:12:09,402 --> 00:12:13,082
我们delete斜杠node2删掉

386
00:12:13,082 --> 00:12:14,602
那删掉之后来到我们这边

387
00:12:14,602 --> 00:12:16,922
大家注意你看是不是数据被删除了

388
00:12:16,922 --> 00:12:19,682
一样可以达到这种坚定的这种机制

389
00:12:19,802 --> 00:12:20,522
这就是什么

390
00:12:20,842 --> 00:12:23,442
ZKclient它的操作方式比我们的

391
00:12:23,442 --> 00:12:26,002
什么Zoocaper的原生的API操作方式

392
00:12:26,242 --> 00:12:27,602
要简单了许多

393
00:12:27,802 --> 00:12:29,282
所以说我们在工作中

394
00:12:29,402 --> 00:12:32,922
我们建议优先使用这个叫ZKclient的

395
00:12:32,922 --> 00:12:35,602
这个库来操作Zoocaper的服务

396
00:12:35,602 --> 00:12:36,162
好了

397
00:12:36,362 --> 00:12:38,842
这节课给大家讲解ZKclient的使用

398
00:12:39,042 --> 00:12:40,282
到这就结束了

399
00:12:40,282 --> 00:12:41,630
现在谢谢大家

