1
00:00:00,986 --> 00:00:07,422
这节课我们再来讲解一下外连接查询当中的全外连接,就是这个Fall

2
00:00:08,378 --> 00:00:14,538
那么这里同学们需要注意,在MySQL当中,它是不支持全外连接查询的

3
00:00:14,538 --> 00:00:19,258
也就是说我们不能在MySQL当中去使用false outer join关键字

4
00:00:19,258 --> 00:00:21,098
那么我们怎么办呢?

5
00:00:21,098 --> 00:00:27,898
在MySQL当中,我们可以通过其他的方式来实现这种全外连接的效果

6
00:00:27,898 --> 00:00:31,658
好,那我们先来看一下全外连接查询数据时

7
00:00:31,658 --> 00:00:36,698
用它作为两个表去做数据查询时,它的查询的结果集是什么样的呢?

8
00:00:36,698 --> 00:00:44,298
我们来看这个图,全外连接查询除了会返回满足查询条件的数据以外

9
00:00:44,298 --> 00:00:50,938
它还会把两个表当中那些不匹配规则的数据也都显示出来

10
00:00:50,938 --> 00:00:55,338
也就是说全外连接除了会返回匹配规则的数据以外

11
00:00:55,338 --> 00:01:01,738
它还会把两个表当中的固儿数据都显示出来

12
00:01:01,738 --> 00:01:04,778
这就是全外连接的作用,明白这意思吧?

13
00:01:04,778 --> 00:01:10,298
注意,MySQL当中是不支持FalloutJoin连接的

14
00:01:10,298 --> 00:01:14,538
但是我们可以使用union来实现全外连接

15
00:01:14,538 --> 00:01:18,938
union是MySQL当中的一个关键字,一个语句,一个子句

16
00:01:18,938 --> 00:01:21,978
我们用它是可以实现全外连接的

17
00:01:21,978 --> 00:01:24,458
那么它是如何实现全外连接的呢?

18
00:01:24,458 --> 00:01:27,658
这里我们要先来了解一下union关键字的作用

19
00:01:27,658 --> 00:01:32,458
union它可以将两个查询结果集合并

20
00:01:32,458 --> 00:01:35,338
也就是说它的作用其实就是做两个结果集合并的

21
00:01:35,338 --> 00:01:38,538
明白吧?然后返回的行都是唯一的

22
00:01:38,538 --> 00:01:45,898
如果对整个结果集合就相当于如同对整个结果集使用了distinct

23
00:01:45,898 --> 00:01:47,338
这是union的作用

24
00:01:47,338 --> 00:01:48,938
那么这里我们再总结一下

25
00:01:48,938 --> 00:01:51,258
union的作用就是做结果集合并

26
00:01:51,258 --> 00:01:56,138
并且会自动的帮助我们剔除结果集合并以后的那些重复数据

27
00:01:56,138 --> 00:01:57,338
这是union的作用

28
00:01:57,338 --> 00:02:00,938
那么除了union以外,在MySQL当中还有unionall

29
00:02:00,938 --> 00:02:04,778
unionall的作用只是简单的将两个结果集合并了

30
00:02:04,778 --> 00:02:05,498
就返回了

31
00:02:05,498 --> 00:02:09,018
这样如果返回的两个结果集当中有重复数据

32
00:02:09,018 --> 00:02:10,298
它是不会剔除重复的

33
00:02:10,298 --> 00:02:14,698
那么它返回的结果集当中就会包含重复的数据了

34
00:02:14,698 --> 00:02:19,178
它跟union相比较,它是不会做重复数据的剔除的

35
00:02:19,178 --> 00:02:21,178
明白了同学们?

36
00:02:21,178 --> 00:02:27,098
OK,好,我们来看一下用union来实现全外连接的一个语法结构

37
00:02:27,098 --> 00:02:29,498
这里我们要依赖于两个查询

38
00:02:29,498 --> 00:02:33,818
一个查询去做左表的显示,一个查询做右表的显示

39
00:02:33,818 --> 00:02:36,538
然后把两个表的结果集一合并

40
00:02:36,538 --> 00:02:39,258
这不就相当于两个表的固有数据都显示出来了嘛

41
00:02:39,258 --> 00:02:41,738
对不对?很简单,很好理解

42
00:02:41,738 --> 00:02:43,738
好,我们来看这样的一个实例

43
00:02:43,738 --> 00:02:49,658
首先要求我们查询出所有雇员的名字以及他们的部门名称

44
00:02:49,658 --> 00:02:53,818
也就是说在这个结果集当中要雇员的名字还有部门的名字

45
00:02:53,818 --> 00:02:57,018
是吧,雇员的名字,部门的名字这肯定要来源于两个表了

46
00:02:57,018 --> 00:02:59,898
分别是employee表跟department表

47
00:02:59,898 --> 00:03:04,138
然后他说了包含那些没有雇员的部门

48
00:03:04,138 --> 00:03:08,218
也就是说他要显示部门当中那些没有员工的部门

49
00:03:08,218 --> 00:03:10,938
那就是部门表当中的雇员数据

50
00:03:10,938 --> 00:03:13,178
以及没有部门的员工

51
00:03:13,178 --> 00:03:17,258
还要显示员工表当中那些没有部门的员工

52
00:03:17,258 --> 00:03:20,138
那就是还要显示员工表当中的雇员数据

53
00:03:20,138 --> 00:03:24,938
那么对于这样的一个需求,我们肯定是要用到全外连接了

54
00:03:24,938 --> 00:03:29,018
好,我们来看一下对于这样的一个需求我们该怎么去实现

55
00:03:29,018 --> 00:03:30,394
< No Speech >

56
00:03:30,394 --> 00:03:34,954
好,我们先写一个,这个语句我们分成两部分来看

57
00:03:34,954 --> 00:03:39,674
这是一部分,然后用一个union关键字

58
00:03:39,674 --> 00:03:42,274
然后这是一部分,对吧?

59
00:03:42,274 --> 00:03:49,274
上面这部分我们是做这个左表的这样左外连接的一个查询

60
00:03:49,274 --> 00:03:53,434
然后下面,union的下面那个语句我们打算做右表的连接查询

61
00:03:53,434 --> 00:03:55,674
可以吧?好,那我们先来搞定左表

62
00:03:55,674 --> 00:03:58,634
左表就是先把安波拉一表的固仁数据显示出来

63
00:03:58,634 --> 00:04:03,354
是吧?那就是select,然后呢from,我们先把结构打出来

64
00:04:03,354 --> 00:04:06,994
from,比如说现在我要把安波拉一作为这个左表

65
00:04:06,994 --> 00:04:12,394
那就是安波拉一,对吧?然后呢,left join

66
00:04:12,394 --> 00:04:14,474
alt是可以忽略的,是吧?left join

67
00:04:14,474 --> 00:04:18,194
然后谁呢?department,d

68
00:04:18,778 --> 00:04:22,258
对吧同学们 然后呢 给定链接条件

69
00:04:22,258 --> 00:04:27,818
一点departmentid等于d.departmentid

70
00:04:27,818 --> 00:04:30,258
注意啊 这不要加分号啊 这不要加分号

71
00:04:30,258 --> 00:04:34,098
为什么呢 因为我们现在所写的这是一条sql语句

72
00:04:34,098 --> 00:04:36,818
然后这是我们完成的第一个查询

73
00:04:36,818 --> 00:04:38,658
当然这里还要考虑这个投影了

74
00:04:38,658 --> 00:04:47,018
它要一点lastname逗号以及d.departmentname

75
00:04:47,018 --> 00:04:52,938
那么我们上面这个语句是去把amplieid作为左表

76
00:04:52,938 --> 00:04:54,178
并且使用了左外连接

77
00:04:54,178 --> 00:04:58,778
那么上面这个查询语句就会显示amplieid表当中的所有符合条件的数据

78
00:04:58,778 --> 00:05:01,778
以及那些它所对应的孤儿数据

79
00:05:01,778 --> 00:05:03,698
amplieid表当中的孤儿数据

80
00:05:03,698 --> 00:05:06,858
对吧 然后呢unit下面再加个括号

81
00:05:06,858 --> 00:05:09,498
用它来做另一个表的查询

82
00:05:09,498 --> 00:05:11,498
对吧 我们还是先搭结构

83
00:05:11,498 --> 00:05:14,218
slack它 然后from 对吧

84
00:05:14,218 --> 00:05:19,738
那么from什么呢 还是去查amplieid跟department

85
00:05:19,738 --> 00:05:21,898
当然这里你仍然可以用左外连接

86
00:05:21,898 --> 00:05:25,258
然后把department表作为左表不就可以了吗

87
00:05:25,258 --> 00:05:27,978
这个语句就是显示另一个表的孤儿数据嘛

88
00:05:27,978 --> 00:05:32,218
对不对 当然你也可以使用右外连接

89
00:05:32,218 --> 00:05:34,698
然后让department作为右表不也可以吗

90
00:05:34,698 --> 00:05:37,418
是吧 那这里我为了练习啊 我就用右外连接了

91
00:05:37,418 --> 00:05:39,418
可以吧 左外右外我们都用一下

92
00:05:39,418 --> 00:05:41,058
那如果要用右外连接的话

93
00:05:41,058 --> 00:05:43,338
那左表仍然是amplieid 对吧

94
00:05:43,338 --> 00:05:45,738
注意这个别名就不要再e 要用e了

95
00:05:45,738 --> 00:05:47,458
这是在一条cycle语句当中

96
00:05:47,458 --> 00:05:49,178
所以这时候别名重名了

97
00:05:49,178 --> 00:05:51,458
我们要换一下 这个叫e1 可以吧

98
00:05:51,458 --> 00:05:55,818
然后呢e1 然后没有点 没有这个逗号

99
00:05:55,818 --> 00:05:57,406
接着然后right

100
00:05:58,394 --> 00:06:03,394
然后department表第一

101
00:06:03,394 --> 00:06:04,514
可以吧

102
00:06:04,514 --> 00:06:06,114
然后连接条件

103
00:06:06,114 --> 00:06:13,114
1.departmentid等于第一点departmentid

104
00:06:13,114 --> 00:06:16,194
department小线id

105
00:06:16,194 --> 00:06:17,914
注意后面也不要加分号

106
00:06:17,914 --> 00:06:21,034
在最后的括号后面加一个分号

107
00:06:21,034 --> 00:06:21,954
这表示一条语句

108
00:06:21,954 --> 00:06:22,354
对吧

109
00:06:22,354 --> 00:06:24,074
然后这投影什么

110
00:06:24,074 --> 00:06:26,194
这投影是不是得跟我们上面是一样的

111
00:06:26,194 --> 00:06:28,394
因为他也要lastname跟departmentname

112
00:06:28,394 --> 00:06:28,874
对不对

113
00:06:28,874 --> 00:06:32,834
那就是1.lastname逗号

114
00:06:32,834 --> 00:06:35,710
第一点department name

115
00:06:35,710 --> 00:06:36,826
< No Speech >

116
00:06:36,826 --> 00:06:41,626
OK,你看,同学们,我们先这样,我们先把上面的查询语句运行一下

117
00:06:41,626 --> 00:06:50,266
看到了吗?这是返回所有的雇员以及他们的部门,并且包含了那些没有部门的雇员

118
00:06:50,266 --> 00:06:53,054
我们看这里有没有那个grant

119
00:06:53,054 --> 00:06:56,602
< No Speech >

120
00:06:56,602 --> 00:06:57,622
找一下啊

121
00:06:57,622 --> 00:06:59,418
< No Speech >

122
00:06:59,418 --> 00:07:00,258
是不是有啊?

123
00:07:00,258 --> 00:07:00,658
好

124
00:07:00,658 --> 00:07:02,418
然后我们现在再来执行这个语句

125
00:07:02,418 --> 00:07:04,938
选中右键运行一选择

126
00:07:04,938 --> 00:07:05,778
这是查什么

127
00:07:05,778 --> 00:07:08,058
这是查所有的雇员以及部门

128
00:07:08,058 --> 00:07:11,058
并且包含那些没有员工的部门

129
00:07:11,058 --> 00:07:11,538
对吧

130
00:07:11,538 --> 00:07:13,438
我们看有没有

131
00:07:13,438 --> 00:07:16,186
< No Speech >

132
00:07:16,186 --> 00:07:17,186
往下走

133
00:07:17,186 --> 00:07:18,234
< No Speech >

134
00:07:18,234 --> 00:07:21,114
看到了吗?同学们,这些部门都是没有雇员的

135
00:07:21,114 --> 00:07:26,114
是吧?那我们现在把这两个结果,这两个查询放到一起执行

136
00:07:26,114 --> 00:07:29,074
同时用union关键字来拼接一下结果集

137
00:07:29,074 --> 00:07:34,994
那么在这个结果集当中是不是就包含了这个既没有部门的雇员

138
00:07:34,994 --> 00:07:37,994
以及没有雇员的部门啊,是不是?我们看一下

139
00:07:37,994 --> 00:07:42,034
现在这个结果集当中,我们去找一下看看有没有这个没有部门的雇员

140
00:07:42,034 --> 00:07:48,074
就是那个grant,有吧?然后有没有那些没有部门的,没有雇员的部门呢?

141
00:07:48,074 --> 00:07:56,594
看,也有啊,是吧?这样我们就通过union这个关键字解决了全外连接的实现

142
00:07:56,594 --> 00:08:01,554
明白这些吧,同学们?OK,好,我们来看一下这节课的实时效果反馈

143
00:08:01,554 --> 00:08:07,154
union的作用是什么?A,合并结果集并不剔除重复数据

144
00:08:07,154 --> 00:08:10,274
B,合并结果集并剔除重复数据

145
00:08:10,274 --> 00:08:12,154
C,剔除重复数据

146
00:08:12,154 --> 00:08:13,914
D,指定链接条件

147
00:08:13,914 --> 00:08:16,434
那么union的作用到底是什么?

148
00:08:16,434 --> 00:08:20,434
大家想想,是不是合并结果集并剔除重复数据?

149
00:08:20,434 --> 00:08:23,034
那么它的答案是不是应该是B?对不对?

150
00:08:23,034 --> 00:08:29,914
好,同学们,那么以上我们就讲解了如何在MySQL当中实现全外连接

151
00:08:29,914 --> 00:08:32,318
好,那我们这节课就到这

