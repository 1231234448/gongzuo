1
00:00:00,890 --> 00:00:05,690
从这一刻开始,我们就来讲解一下MySQL当中的索引

2
00:00:05,690 --> 00:00:08,490
那么我们要先搞清楚什么是索引呢?

3
00:00:08,490 --> 00:00:12,318
其实索引在我们生活当中也是随处可见的

4
00:00:13,018 --> 00:00:21,018
当我们去某个写字楼时,一般在写字楼的一楼的显眼位置都会有一个楼层的索引牌

5
00:00:21,018 --> 00:00:26,018
上面会提示一层有哪些公司,二层有哪些公司,三层有哪些公司

6
00:00:26,018 --> 00:00:30,878
对吧,我们可以通过这个索引牌快速的找到我们要去的公司在几层

7
00:00:30,878 --> 00:00:31,962
< No Speech >

8
00:00:31,962 --> 00:00:34,202
写字楼里的锁影牌的作用

9
00:00:34,202 --> 00:00:37,082
那么除了写字楼里有锁影牌以外

10
00:00:37,082 --> 00:00:40,442
在我们生活当中比如说我们去查新华字典时

11
00:00:40,442 --> 00:00:42,522
当我们有某个字不认识的时候

12
00:00:42,522 --> 00:00:44,318
我们是不是可以通过查询字典

13
00:00:44,318 --> 00:00:45,754
< No Speech >

14
00:00:45,754 --> 00:00:47,994
看看它怎么读什么含义对吧

15
00:00:47,994 --> 00:00:50,314
那么我们怎么查字典同学们考虑一下

16
00:00:50,314 --> 00:00:52,514
是不是要么通过拼音来查

17
00:00:52,514 --> 00:00:54,394
要么通过乒乓步手来查对吧

18
00:00:54,394 --> 00:00:56,114
比如说如果你知道这个字叫什么

19
00:00:56,114 --> 00:00:57,474
但是你不知道什么意思

20
00:00:57,474 --> 00:00:59,034
那你可以通过拼音来查

21
00:00:59,034 --> 00:01:00,954
如果这个字你不知道它怎么读

22
00:01:00,954 --> 00:01:02,474
我们可以通过乒乓步手来查

23
00:01:02,474 --> 00:01:04,914
但是不管你用哪种方式来查

24
00:01:04,914 --> 00:01:06,634
我们在它的锁引页里

25
00:01:06,634 --> 00:01:08,994
只要是信化字典都会有锁引页对不对

26
00:01:08,994 --> 00:01:11,070
我们在它的锁引页里都可以找到

27
00:01:11,770 --> 00:01:14,210
通过偏方部署也好,通过ping也好

28
00:01:14,210 --> 00:01:16,542
都能找到这个字,以及这个字所在的页码

29
00:01:17,082 --> 00:01:17,722
对吧

30
00:01:17,722 --> 00:01:22,202
那么我们就可以根据索引页里所提示的位置

31
00:01:22,202 --> 00:01:24,830
这个页码直接去找到这个字所在的位置

32
00:01:24,830 --> 00:01:26,106
< No Speech >

33
00:01:26,106 --> 00:01:28,986
对吧?这就是索引的作用

34
00:01:28,986 --> 00:01:32,026
所以你会发现索引的目的是什么?

35
00:01:32,026 --> 00:01:38,106
就是为了能够让我们快速的找到我们想要的东西的一种机制

36
00:01:38,106 --> 00:01:41,066
没错,MySQL当中的索引也是这样的

37
00:01:41,066 --> 00:01:43,466
那么其实不仅仅是在MySQL当中

38
00:01:43,466 --> 00:01:46,586
只要是固安型数据库里都有索引

39
00:01:46,586 --> 00:01:47,742
而且它们的作用也很简单

40
00:01:48,634 --> 00:01:51,454
都是为了能够让我们快速的找到

41
00:01:51,454 --> 00:01:52,986
< No Speech >

42
00:01:52,986 --> 00:02:02,186
我们来看一下索引介绍,索引是对数据库表当中的一列或多列的值进行排序的一种结构

43
00:02:02,186 --> 00:02:07,386
使用索引可以快速访问数据库表中特定的信息

44
00:02:07,386 --> 00:02:13,790
索引是一种特殊文件,它们包含着对数据表里所有记录的数据

45
00:02:13,790 --> 00:02:14,906
< No Speech >

46
00:02:14,906 --> 00:02:18,462
更通俗的说 数据库索引

47
00:02:19,418 --> 00:02:23,818
前面的目录能够加快数据库的查询速度

48
00:02:23,818 --> 00:02:28,818
MySQL索引的建立对于MySQL的高效运行是很重要的

49
00:02:28,818 --> 00:02:31,818
索引可以大大提高MySQL的检索速度

50
00:02:31,818 --> 00:02:34,698
所以索引的作用在我们数据库当中

51
00:02:34,698 --> 00:02:37,578
就是为了提高我们检索数据的效率

52
00:02:37,578 --> 00:02:39,038
比如说我们现在有一个表

53
00:02:39,738 --> 00:02:42,078
在这个表当中呢,现在有这个

54
00:02:42,970 --> 00:02:47,090
上万条甚至十几万条或者是几十万条的数据

55
00:02:47,090 --> 00:02:51,166
如果我们想去在几十万条当中的数据啊去找其中的某一条

56
00:02:51,166 --> 00:02:53,882
< No Speech >

57
00:02:53,882 --> 00:02:57,790
我们去找的方式只能是一条一条的找,除非直到找到为止

58
00:02:58,490 --> 00:03:00,490
那你想这个速度是非常慢的

59
00:03:00,490 --> 00:03:02,490
那么如果有索引呢

60
00:03:02,490 --> 00:03:04,282
< No Speech >

61
00:03:04,282 --> 00:03:06,142
把表中的某一列

62
00:03:06,970 --> 00:03:08,570
把这一列的值拿出来

63
00:03:08,570 --> 00:03:11,098
< No Speech >

64
00:03:11,098 --> 00:03:14,418
MySQL 数据库会把这个列的值放到一个特定文件里

65
00:03:14,418 --> 00:03:17,298
其实这个特殊文件或者特定文件它也是一种表

66
00:03:17,298 --> 00:03:18,578
会把它放到这个表里

67
00:03:18,578 --> 00:03:21,218
然后对这个数据做排序处理

68
00:03:21,218 --> 00:03:24,978
那么它就相当于我们新华字典的这个索引页了

69
00:03:24,978 --> 00:03:28,178
当我去找这个字以这个列作为查询条件的时候

70
00:03:28,178 --> 00:03:29,726
它会先去索引表里

71
00:03:29,726 --> 00:03:31,066
< No Speech >

72
00:03:31,066 --> 00:03:37,986
然后这个字对应的就是这个数据在数据文件或者叫表当中的物理位置或者叫确切位置

73
00:03:37,986 --> 00:03:42,066
直接就可以找到这个数据 就像新华字典CN这个字 519页

74
00:03:42,066 --> 00:03:44,066
它可以直接去519页

75
00:03:44,066 --> 00:03:45,530
< No Speech >

76
00:03:45,530 --> 00:03:46,030
是吧

77
00:03:46,030 --> 00:03:49,726
这比你去表当中一条一条的找是不是输掉快很多

78
00:03:50,426 --> 00:03:54,226
对吧同学们,所以数据库当中的锁引的作用只有一个

79
00:03:54,226 --> 00:03:56,926
就是为了提升查询效率的

80
00:03:57,914 --> 00:03:59,914
好,我们来看一下索引的作用

81
00:03:59,914 --> 00:04:02,274
索引相当于图书上的目录

82
00:04:02,274 --> 00:04:05,554
可以根据目录上的页码快速找到所需的内容

83
00:04:05,554 --> 00:04:06,434
提高性能

84
00:04:06,434 --> 00:04:07,614
提高什么性能呢?

85
00:04:07,614 --> 00:04:09,146
< No Speech >

86
00:04:09,146 --> 00:04:10,346
这是索引的作用

87
00:04:10,346 --> 00:04:12,346
那我们再来看一下索引的优点

88
00:04:12,346 --> 00:04:14,106
索引有什么优点呢

89
00:04:14,106 --> 00:04:16,506
我们通过创建唯一性索引

90
00:04:16,506 --> 00:04:20,346
可以保证数据库表当中的每一行数据都是唯一性的

91
00:04:20,346 --> 00:04:23,546
我们索引是有一种类型叫唯一性索引的

92
00:04:23,546 --> 00:04:25,226
那么一旦创建了唯一性索引

93
00:04:25,226 --> 00:04:27,946
那么这一行的数据肯定是具备唯一性的

94
00:04:27,946 --> 00:04:31,066
然后可以加快数据的检索速度

95
00:04:31,066 --> 00:04:32,026
这是最重要的

96
00:04:32,026 --> 00:04:32,346
对吧

97
00:04:32,346 --> 00:04:34,906
然后可以加速表与表之间的链接

98
00:04:34,906 --> 00:04:37,386
比如说我们在查询做多表查询的时候

99
00:04:37,386 --> 00:04:39,946
如果这两个表的条件列都创建了索引

100
00:04:39,946 --> 00:04:44,746
那么它的链接速度会比没有创建索引的速度要快很多

101
00:04:44,746 --> 00:04:47,546
那么在使用分组和排序进行检索的时候

102
00:04:47,546 --> 00:04:50,426
可以减少查询中分组跟排序的时间

103
00:04:50,426 --> 00:04:51,706
这是索引的优点

104
00:04:51,706 --> 00:04:53,226
那么索引有没有缺点呢

105
00:04:53,226 --> 00:04:54,266
肯定是有的

106
00:04:54,266 --> 00:04:56,906
创建索引和维护索引需要耗费时间

107
00:04:56,906 --> 00:04:59,706
这种时间是随着数据量增加而增加的

108
00:04:59,706 --> 00:05:00,734
我们刚刚说了,如果有问题请在下方留言,我们会尽快解决的

109
00:05:00,734 --> 00:05:02,266
< No Speech >

110
00:05:02,266 --> 00:05:04,946
它创建首页的方式会把你这一列

111
00:05:04,946 --> 00:05:06,466
你对某一个列创建首页

112
00:05:06,466 --> 00:05:09,266
它会把这个列的值拿出来放到一个特定的表当中

113
00:05:09,266 --> 00:05:09,746
对吧

114
00:05:09,746 --> 00:05:12,986
那么如果你这个表里的数据又增加了很多

115
00:05:12,986 --> 00:05:15,546
那意味着这一列的数据是不是也会增加很多

116
00:05:15,546 --> 00:05:18,142
那么这个时候Meseco数据肯定要去维护

117
00:05:18,714 --> 00:05:24,034
那么这里的值肯定也会随着增加而增加的

118
00:05:24,034 --> 00:05:25,034
明白这意思吧?

119
00:05:25,034 --> 00:05:27,234
它不是创建完就不变了,会变的

120
00:05:27,234 --> 00:05:31,034
会随着你这个主表里的数据发生改变而改变的

121
00:05:31,034 --> 00:05:31,998
明白这意思吧?

122
00:05:31,998 --> 00:05:33,754
< No Speech >

123
00:05:33,754 --> 00:05:37,594
那么锁引需要占用物理空间,数据量越大,占用空间就越大

124
00:05:37,594 --> 00:05:40,394
你为这一个列创建锁引了

125
00:05:40,394 --> 00:05:43,194
你这个表里的数据越来越多,这列的值越来越多

126
00:05:43,194 --> 00:05:45,182
你锁引表里的数据它要多么多么多么多么多么多么多么多么多

127
00:05:45,182 --> 00:05:46,586
< No Speech >

128
00:05:46,586 --> 00:05:48,786
那你说音表里的数据也会越来越多

129
00:05:48,786 --> 00:05:51,066
所以说音表占用物理空间越来越大

130
00:05:51,066 --> 00:05:52,254
明白这些字吧

131
00:05:52,254 --> 00:05:53,306
< No Speech >

132
00:05:53,306 --> 00:06:00,670
增三改的效率,因为每次增三改,锁引都需要进行动态维护

133
00:06:00,670 --> 00:06:03,034
< No Speech >

134
00:06:03,034 --> 00:06:06,034
每次进行增三改,索引都需要进行动态维护

135
00:06:06,034 --> 00:06:11,514
什么意思呢?就是当我们这个表当中的索引列的值经常会发生改变

136
00:06:11,514 --> 00:06:17,114
比如说它原来的A变成了B,现在的C变成了D

137
00:06:17,114 --> 00:06:21,394
那么由于这一列已经放到了索引表当中了,把它建索引了嘛

138
00:06:21,394 --> 00:06:26,434
那由于这个主表里的值发生改变了,索引表里的这个值也要跟着去动态维护的

139
00:06:26,434 --> 00:06:28,834
否则就会出现不匹配的现象了,是不是?

140
00:06:28,834 --> 00:06:33,314
所以你的值,你建索引的这个值频繁的会发生变化

141
00:06:33,314 --> 00:06:37,394
那么也就意味着索引表里的这个列的值也会频繁的去动态维护

142
00:06:37,394 --> 00:06:39,966
是吧?那肯定效率上也会受到影响的

143
00:06:40,538 --> 00:06:44,098
那么什么时候需要创建索引呢?

144
00:06:44,098 --> 00:06:47,498
就是频繁作为查询条件的字段应该创建索引

145
00:06:47,498 --> 00:06:49,498
比如说我现在这个表里有某个列

146
00:06:49,498 --> 00:06:53,418
它经常会出现在我val的子句的后面作为一个条件列

147
00:06:53,418 --> 00:06:57,018
那么对于这样的列,为了加快条件列的查询速度

148
00:06:57,018 --> 00:06:58,698
我们可以把它创建索引的

149
00:06:58,698 --> 00:07:00,658
明白这些吧?把这个列创建索引

150
00:07:00,658 --> 00:07:05,578
二,查询中的排序字段创建索引将大大提高排序的速度

151
00:07:05,578 --> 00:07:07,578
索引就是排序加快查找

152
00:07:07,578 --> 00:07:11,098
比如说我们经常会用到表当中的某一个列去做排序处理

153
00:07:11,098 --> 00:07:13,498
那么对于这个列呢,你就可以把它创建索引了

154
00:07:13,498 --> 00:07:15,138
为什么呢?因为我们之前说了

155
00:07:15,138 --> 00:07:18,178
MySQL的索引就是把某一个列的值拿出来

156
00:07:18,178 --> 00:07:22,018
比如说你把这个列的值,把这个列作为索引列去创建了

157
00:07:22,018 --> 00:07:24,858
那么它会把这个数据拿出来放到一个索引表里

158
00:07:24,858 --> 00:07:27,538
但它不是胡乱的放到索引表里的

159
00:07:27,538 --> 00:07:31,006
它会对这个数据先做排序的,然后再放到索引表里

160
00:07:31,578 --> 00:07:34,178
然后通过算法就可以快速地定位这条数据了

161
00:07:34,178 --> 00:07:36,818
然后通过这个数据再快速地找到主表里的数据

162
00:07:36,818 --> 00:07:37,538
明白这意思吧

163
00:07:37,538 --> 00:07:42,378
所以它本身这一列的值在熟银表里就已经做排序的功能了

164
00:07:42,378 --> 00:07:44,458
所以我们在对这个列做排序时

165
00:07:44,458 --> 00:07:46,978
直接去熟银表里就可以拿到排序好的数据

166
00:07:46,978 --> 00:07:48,606
那排序的效率肯定会高咯

167
00:07:48,606 --> 00:07:51,162
< No Speech >

168
00:07:51,162 --> 00:07:54,242
查询中统计或者分组的字段

169
00:07:54,242 --> 00:07:57,022
比如说我们在查询当中经常会用到一些字段

170
00:07:57,818 --> 00:08:00,698
经常会对某个列做分组或者做统计处理

171
00:08:00,698 --> 00:08:02,378
那么这个时候你也可以把它做一个

172
00:08:02,378 --> 00:08:03,218
数理的创建

173
00:08:03,218 --> 00:08:05,150
把这一个列做一个数理的创建

174
00:08:05,978 --> 00:08:08,178
那么什么时候不需要创建输引呢?

175
00:08:08,178 --> 00:08:12,126
1. 频繁的更换字段不适合创建输引

176
00:08:12,922 --> 00:08:15,722
然后呢,因为每次更新不单单是更新记录

177
00:08:15,722 --> 00:08:17,842
还会更新缩影保存缩影文件

178
00:08:17,842 --> 00:08:19,842
也就是说你这个列的某一个字段

179
00:08:19,842 --> 00:08:21,642
某一个列的值会经常变化

180
00:08:21,642 --> 00:08:23,722
那么这个列就不建议创建缩影了

181
00:08:23,722 --> 00:08:25,442
因为你这一列的值一旦变化了

182
00:08:25,442 --> 00:08:27,922
缩影表里的数据也要动态维护的

183
00:08:27,922 --> 00:08:28,922
明白这意思吧

184
00:08:28,922 --> 00:08:31,922
vile条件里用不到的字段就不要创建缩影了

185
00:08:31,922 --> 00:08:33,802
比如说这个列它不会出现在

186
00:08:33,802 --> 00:08:37,402
或者不是经常的出现在vile子句的后面来作为条件列了

187
00:08:37,402 --> 00:08:38,362
那么这样的列呢

188
00:08:38,362 --> 00:08:40,242
这样的字段就不要创建缩影了

189
00:08:40,242 --> 00:08:41,682
然后表记录太少

190
00:08:41,682 --> 00:08:42,562
不需要创建缩影

191
00:08:42,562 --> 00:08:44,362
比如说你这个表里只有几十条

192
00:08:44,362 --> 00:08:44,922
几百条

193
00:08:44,922 --> 00:08:46,122
甚至几千条

194
00:08:46,122 --> 00:08:48,522
对于这样的数据就不要创建缩影了

195
00:08:48,522 --> 00:08:50,558
对于几千条数据买sql还是很快的

196
00:08:50,558 --> 00:08:52,122
< No Speech >

197
00:08:52,122 --> 00:08:54,270
经常增生改的表

198
00:08:55,162 --> 00:08:58,238
比如说你这个表里经常会发生数据正三改

199
00:08:58,238 --> 00:08:59,546
< No Speech >

200
00:08:59,546 --> 00:09:02,106
没有查精神改造DML操作

201
00:09:02,106 --> 00:09:04,106
那么这样就不要为它创建缩影了

202
00:09:04,106 --> 00:09:04,826
因为我们说了

203
00:09:04,826 --> 00:09:06,906
一旦数据发现了发生了改动

204
00:09:06,906 --> 00:09:08,266
缩影表要动态维护的

205
00:09:08,266 --> 00:09:08,946
是不是

206
00:09:08,946 --> 00:09:11,706
然后数据重复且分布平均的字段

207
00:09:11,706 --> 00:09:15,026
因此经常查询和经常排序的字段建立缩影

208
00:09:15,026 --> 00:09:15,826
但是注意

209
00:09:15,826 --> 00:09:18,186
某些数据包含大量重复的

210
00:09:18,186 --> 00:09:20,586
因此它建立缩影就没有太大的效果了

211
00:09:20,586 --> 00:09:21,826
例如性别字段

212
00:09:21,826 --> 00:09:24,106
只有男女就不适合建立缩影了

213
00:09:24,106 --> 00:09:25,586
比如说我这个表里

214
00:09:25,586 --> 00:09:25,630
建立缩影之后

215
00:09:25,630 --> 00:09:26,874
< No Speech >

216
00:09:26,874 --> 00:09:28,830
这一列是一个6

217
00:09:28,830 --> 00:09:29,914
< No Speech >

218
00:09:29,914 --> 00:09:31,394
存的值是男女

219
00:09:31,394 --> 00:09:33,514
那么其实无论你数据再多

220
00:09:33,514 --> 00:09:35,034
这个列的值外后就两种

221
00:09:35,034 --> 00:09:35,994
男或者是女

222
00:09:35,994 --> 00:09:36,394
对吧

223
00:09:36,394 --> 00:09:38,594
那么如果你把这一列创建索引列了

224
00:09:38,594 --> 00:09:39,914
那在索引表里当中

225
00:09:39,914 --> 00:09:41,822
就是有大量的排好序的男

226
00:09:41,822 --> 00:09:43,162
< No Speech >

227
00:09:43,162 --> 00:09:50,722
那么你在做性别查询时,你并不会因为把性别创建索引而提高查询效率,为什么?

228
00:09:50,722 --> 00:09:54,242
因为你这里的数据大部分还都是男,大部分还是女

229
00:09:54,242 --> 00:09:57,950
他要在这部分当中再去找这个男所对应的数据到底是谁

230
00:09:58,522 --> 00:10:00,522
因为它有很多都是重复的

231
00:10:00,522 --> 00:10:02,922
重复的数据一多了

232
00:10:02,922 --> 00:10:06,122
它就不能够快速的定位到唯一的一条数据了

233
00:10:06,122 --> 00:10:07,562
明白这意思吧同学们

234
00:10:07,562 --> 00:10:09,242
所以如果有大量重复的

235
00:10:09,242 --> 00:10:11,242
这个列里存在大量重复的数据

236
00:10:11,242 --> 00:10:12,350
就不要创建数页了

237
00:10:12,986 --> 00:10:16,506
好 那我们再来看一下Meseco当中的属饮类型

238
00:10:16,506 --> 00:10:18,986
那么在Meseco当中它有很多属饮类型

239
00:10:18,986 --> 00:10:20,506
比如第一个普通属饮

240
00:10:20,506 --> 00:10:22,986
普通属饮是最基本的属饮 它没有任何限制

241
00:10:22,986 --> 00:10:25,214
你可以对表当中的属饮类型的属饮类型来做分析

242
00:10:25,946 --> 00:10:27,226
都来创建普通输赢

243
00:10:27,226 --> 00:10:28,186
明白这意思吧

244
00:10:28,186 --> 00:10:29,466
然后还有唯一输赢

245
00:10:29,466 --> 00:10:31,870
唯一输赢的链的值必须是1的

246
00:10:31,870 --> 00:10:33,434
< No Speech >

247
00:10:33,434 --> 00:10:34,878
如果是组合输液

248
00:10:35,546 --> 00:10:38,750
折劣值的组合必须是唯一的

249
00:10:39,482 --> 00:10:41,482
这个我们后面都会讲到

250
00:10:41,482 --> 00:10:42,686
然后主见所以

251
00:10:42,686 --> 00:10:43,706
< No Speech >

252
00:10:43,706 --> 00:10:47,546
唯一的标识一条记录不能为空,一般primary key来约束

253
00:10:47,546 --> 00:10:53,146
其实当我们在表里为某个表里的某个列创建组件约束时

254
00:10:53,146 --> 00:10:55,066
我们之前是不是讲过约束

255
00:10:55,066 --> 00:10:56,158
当你为这个列列遍全世界的众多已久的人成联,然后,把他第多少次专家和那几百万人追赶在一起的时候,众多的众人跟你准备一起直请是否要跟他合作。

256
00:10:56,826 --> 00:10:58,426
或者是分配了一个组件约束

257
00:10:58,426 --> 00:11:02,078
那么这个列本身就自动具备了组件锁引了

258
00:11:02,650 --> 00:11:08,090
主件,具有主件约束的列,它会自动创建主件缩影

259
00:11:08,090 --> 00:11:11,850
那么什么是联合缩影呢?联合缩影也叫复合缩影

260
00:11:11,850 --> 00:11:17,770
是在多个枝段上建立缩影,联合复合指的就是由多个列所构成的缩影

261
00:11:17,770 --> 00:11:20,170
明白这意思吧?在多个枝段上创建的缩影

262
00:11:20,170 --> 00:11:21,210
能够加速

263
00:11:21,210 --> 00:11:22,554
< No Speech >

264
00:11:22,554 --> 00:11:24,914
好 那么这是索引当中的分类

265
00:11:24,914 --> 00:11:27,874
我们再来看一下这节课的实时效果反馈

266
00:11:27,874 --> 00:11:30,834
那么索引作用是为了提高什么的速度

267
00:11:30,834 --> 00:11:31,166
A

268
00:11:31,166 --> 00:11:32,314
< No Speech >

269
00:11:32,314 --> 00:11:36,514
B 修改数据 C 更新数据 D 查询数据

270
00:11:36,514 --> 00:11:39,514
那么索引的作用到底是为了提高什么的速度

271
00:11:39,514 --> 00:11:43,678
很显然是 D 查询数据的效率 查询数据的速度

272
00:11:43,678 --> 00:11:45,850
< No Speech >

273
00:11:45,850 --> 00:11:47,678
这是第1节答案是D 对吧

274
00:11:47,678 --> 00:11:50,682
< No Speech >

275
00:11:50,682 --> 00:11:54,642
那么这节课我们就这一个实质效果反馈

276
00:11:54,642 --> 00:11:56,318
好同学们那我们这节课呢就先说到这里

