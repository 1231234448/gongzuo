1
00:00:00,000 --> 00:00:01,114
< No Speech >

2
00:00:01,114 --> 00:00:06,874
到目前为止,聚合函数的使用以及创建数据分组我们都已经讲过了

3
00:00:06,874 --> 00:00:14,954
那么这节课我们再通过一些练习,进一步去提高我们对聚合函数的使用以及创建数据分组的能力

4
00:00:14,954 --> 00:00:16,394
好,我们来看第一题

5
00:00:16,394 --> 00:00:18,942
显示所有雇员的最高聚合函数

6
00:00:19,834 --> 00:00:24,954
合计和平均薪水列标签分别为max,min,sum和avg

7
00:00:24,954 --> 00:00:28,794
然后他要求四舍五入结果为最近的整数

8
00:00:28,794 --> 00:00:32,874
我们知道求最高最低平均合计跟平均薪水

9
00:00:32,874 --> 00:00:34,154
我们用聚合函数就可以了

10
00:00:34,154 --> 00:00:34,554
对吧

11
00:00:34,554 --> 00:00:36,314
那么四舍五入怎么办呢

12
00:00:36,314 --> 00:00:39,954
我们是不是可以用单行函数的run的函数就可以了

13
00:00:39,954 --> 00:00:40,394
对吧

14
00:00:40,394 --> 00:00:45,314
所以我们用run的函数分别去对最高最低合计跟平均薪水的值

15
00:00:45,314 --> 00:00:46,754
做个四舍五入处理就可以了

16
00:00:46,754 --> 00:00:47,034
是吧

17
00:00:47,034 --> 00:00:48,234
还是比较简单的

18
00:00:48,234 --> 00:00:48,954
好

19
00:00:48,954 --> 00:00:49,054
那这个是我们和平函数 Bros Learn的part 2

20
00:00:49,562 --> 00:00:50,562
我们来写一个

21
00:00:50,562 --> 00:00:52,502
呃SELECT

22
00:00:52,502 --> 00:00:53,914
< No Speech >

23
00:00:53,914 --> 00:00:55,326
雨 знаком

24
00:00:55,326 --> 00:00:57,434
< No Speech >

25
00:00:57,434 --> 00:01:03,390
对吧 然后起个别名义 然后呢 这里我要先Round

26
00:01:03,962 --> 00:01:08,922
然后这里给谁啊?最高薪水,那就是max,然后一点salary

27
00:01:08,922 --> 00:01:12,602
有人说老师,不是这个聚合函数不能嵌套吗?

28
00:01:12,602 --> 00:01:16,202
是的,但是我们现在可不是聚合函数嵌套啊

29
00:01:16,202 --> 00:01:19,642
咱们注意啊,MySQL当中的聚合函数是不能相互嵌套的

30
00:01:19,642 --> 00:01:23,642
比如说你在这个max当中嵌入一个sum函数,这是不允许的

31
00:01:23,642 --> 00:01:27,562
但是我们在把聚合函数嵌套到单行函数当中是没有问题的

32
00:01:27,562 --> 00:01:31,402
明白这一次吧?好,起个列标签,max

33
00:01:31,402 --> 00:01:41,242
然后再让最小是吧,那就是min,然后一点salary

34
00:01:41,242 --> 00:01:42,362
< No Speech >

35
00:01:42,362 --> 00:01:48,002
然后命,然后再来还有一个合计,那就是sub

36
00:01:48,002 --> 00:01:49,018
< No Speech >

37
00:01:49,018 --> 00:01:50,298
先去Run它

38
00:01:50,298 --> 00:01:52,314
< No Speech >

39
00:01:52,314 --> 00:01:56,126
然后呢,sum,然后一点

40
00:01:56,126 --> 00:01:57,530
< No Speech >

41
00:01:57,530 --> 00:01:59,422
起个编名

42
00:01:59,422 --> 00:02:04,986
< No Speech >

43
00:02:04,986 --> 00:02:12,266
OK 然后呢逗号还有一个平均值 那就是Round 然后AVG

44
00:02:12,266 --> 00:02:15,130
< No Speech >

45
00:02:15,130 --> 00:02:19,130
然后呢一点Salary 是不是就可以了

46
00:02:19,130 --> 00:02:20,734
好 我们来运行

47
00:02:21,466 --> 00:02:25,306
好 我们可以看到 现在就求出了整个员工表当中的

48
00:02:25,306 --> 00:02:28,094
这少个别名是吧 AVG

49
00:02:28,094 --> 00:02:29,978
< No Speech >

50
00:02:29,978 --> 00:02:33,338
好这样就抽出整个员工表当中最大最小

51
00:02:33,338 --> 00:02:37,418
合计跟平均值并且做事实无误处理的这样一个结果了

52
00:02:37,418 --> 00:02:41,258
好我们把它copy到笔记当中这是第一题

53
00:02:41,258 --> 00:02:43,098
好我们再来看第二题

54
00:02:43,098 --> 00:02:49,818
第二题他说写一个查询显示每一个工作岗位的人数

55
00:02:49,818 --> 00:02:53,818
每一个工作岗位那这是不是得创建数据分组了

56
00:02:53,818 --> 00:02:56,858
我们对这个工作岗位做分组

57
00:02:56,858 --> 00:03:00,218
然后对分组里的数据做count不就可以了吗

58
00:03:00,218 --> 00:03:02,378
对不对这个比较简单

59
00:03:02,378 --> 00:03:04,254
好我们来写一个

60
00:03:04,254 --> 00:03:06,106
< No Speech >

61
00:03:06,106 --> 00:03:10,106
然后从Employee对吧

62
00:03:10,106 --> 00:03:11,106
然后呢

63
00:03:11,106 --> 00:03:14,106
这里我们要用到GroupBy子句了吧

64
00:03:14,106 --> 00:03:16,106
GroupBy对谁分组呢

65
00:03:16,106 --> 00:03:18,106
起个别名义啊

66
00:03:18,106 --> 00:03:20,106
然后对Employee的JobID

67
00:03:20,106 --> 00:03:22,106
工作岗位不是JobID吗

68
00:03:22,106 --> 00:03:23,106
对他做分组啊

69
00:03:23,106 --> 00:03:26,106
然后呢这里我们可以显示一点JobID啊

70
00:03:26,106 --> 00:03:27,998
easy count

71
00:03:27,998 --> 00:03:29,306
< No Speech >

72
00:03:29,306 --> 00:03:31,986
行 每个工作组的人数 对吧

73
00:03:31,986 --> 00:03:36,826
< No Speech >

74
00:03:36,826 --> 00:03:45,786
看到了吗?同学们,现在我们已经查出来了,在安普赖伊表当中,这些工作岗位的人数是多少

75
00:03:45,786 --> 00:03:48,666
< No Speech >

76
00:03:48,666 --> 00:03:50,066
好 这是第二题

77
00:03:50,682 --> 00:03:57,842
我们再来看第三题,第三题它要求确定经理人数不需要列出他们

78
00:03:57,842 --> 00:04:04,002
列标签为number of manager,提示用manager id决定经理

79
00:04:04,002 --> 00:04:08,882
也就是说我们可以通过这个manager id来决定经理数

80
00:04:08,882 --> 00:04:17,282
那么怎么办呢?我们是不是就可以使用count对manager id这一列去做一个技术处理不就可以了吗?

81
00:04:17,282 --> 00:04:24,122
但是要想到员工表当中,他可能会有很多员工,而且有很多员工是相同经理的

82
00:04:24,122 --> 00:04:25,370
< No Speech >

83
00:04:25,370 --> 00:04:27,610
那也就是说manager id是有重复的

84
00:04:27,610 --> 00:04:34,090
那我们要想确定经理的人数是不是用distinct把经理id做一个去重复的处理

85
00:04:34,090 --> 00:04:35,290
对吧

86
00:04:35,290 --> 00:04:38,050
比如说安卓拉伊表里有张三李四王五

87
00:04:38,050 --> 00:04:39,650
他们的经理都是同一个人

88
00:04:39,650 --> 00:04:41,330
那经理id肯定都是相同的

89
00:04:41,330 --> 00:04:42,610
对吧

90
00:04:42,610 --> 00:04:43,930
那我们在查询表的时候

91
00:04:43,930 --> 00:04:45,330
这个数据肯定是有重复的

92
00:04:45,330 --> 00:04:49,610
用经理id来作为技术的一个列的话

93
00:04:49,610 --> 00:04:50,690
那这肯定是有重复的

94
00:04:50,690 --> 00:04:52,610
所以我们是得把重复的剔除掉了

95
00:04:52,610 --> 00:04:53,330
明白这些吧

96
00:04:53,330 --> 00:04:53,730
同学们

97
00:04:53,730 --> 00:04:56,610
那么接下来怎么办呢

98
00:04:56,610 --> 00:05:00,410
select from employee

99
00:05:00,410 --> 00:05:01,290
对吧

100
00:05:01,290 --> 00:05:03,326
然后, count

101
00:05:03,326 --> 00:05:08,058
< No Speech >

102
00:05:08,058 --> 00:05:09,578
然后distinct的对吧

103
00:05:09,578 --> 00:05:10,578
肯定要去重的

104
00:05:10,578 --> 00:05:11,610
< No Speech >

105
00:05:11,610 --> 00:05:18,770
然后我们起个别名,E.ManageID,以它作为经理列的一个技术

106
00:05:18,770 --> 00:05:21,890
对吧,人家说了嘛,用ManageID决定经理号嘛,是吧

107
00:05:21,890 --> 00:05:26,930
然后运行,OK,那么在安普赖伊表当中一共有18个经理,对吧

108
00:05:26,930 --> 00:05:29,022
好,保存一下

109
00:05:29,626 --> 00:05:39,626
第三题 我们再来看第四题 第四题呢 他说写一个查询显示最高和最低薪水之间的差

110
00:05:39,626 --> 00:05:47,626
这个比较简单了吧 我们去求薪水的max 然后用它去减去这个最低薪水不就可以了吗 对不对

111
00:05:47,626 --> 00:05:49,726
我们来写一个

112
00:05:49,726 --> 00:05:52,986
< No Speech >

113
00:05:52,986 --> 00:05:58,226
最高select,然后from,apply,对吧

114
00:05:58,226 --> 00:05:59,426
也不需要做什么分组了

115
00:05:59,426 --> 00:06:00,946
一大组就可以了是吧

116
00:06:00,946 --> 00:06:03,198
然后呢这里是max

117
00:06:04,154 --> 00:06:05,594
取了 commanded matchinglish

118
00:06:05,594 --> 00:06:07,386
< No Speech >

119
00:06:07,386 --> 00:06:09,546
然后一点celery

120
00:06:09,906 --> 00:06:11,986
减去meat

121
00:06:11,986 --> 00:06:14,906
然后一点celery

122
00:06:15,546 --> 00:06:17,546
是不是可以了?运行

123
00:06:17,546 --> 00:06:20,226
最高薪水减去最低薪水的差是它

124
00:06:20,226 --> 00:06:22,226
对吧?好,保存一下

125
00:06:22,226 --> 00:06:24,186
< No Speech >

126
00:06:24,186 --> 00:06:26,186
OK 我们再来看第五题

127
00:06:26,186 --> 00:06:27,834
< No Speech >

128
00:06:27,834 --> 00:06:45,054
第五题,显示经理号和经理付给雇员的最低薪水,排除那些经理未职的人,排除最低薪水小于等于6000的主,按薪水降续排序输出。

129
00:06:46,010 --> 00:06:55,050
这个题我们好好分析一下 我们先看他说要排除哪些人 首先排除那些经理位置的人

130
00:06:55,050 --> 00:06:56,634
< No Speech >

131
00:06:56,634 --> 00:06:58,674
那么我们是不是在查询数据的时候

132
00:06:58,674 --> 00:07:01,794
是不是应该先用val子去排除那些经理未知的人

133
00:07:01,794 --> 00:07:04,594
经理未知的人排除他们的条件是什么

134
00:07:04,594 --> 00:07:07,486
是不是managerid is not a non 不就可以了

135
00:07:07,486 --> 00:07:09,050
< No Speech >

136
00:07:09,050 --> 00:07:12,410
这样的没有经理的雇员就会被排除掉

137
00:07:12,410 --> 00:07:12,970
对吧

138
00:07:12,970 --> 00:07:15,130
然后接下来他要去算什么

139
00:07:15,130 --> 00:07:22,250
是不是要根据经理号和经理付给雇员的最低薪水

140
00:07:22,250 --> 00:07:23,210
经理号是谁

141
00:07:23,210 --> 00:07:24,090
manager id

142
00:07:24,090 --> 00:07:26,490
我们是不是得按照manager id去分组

143
00:07:26,490 --> 00:07:30,730
然后去求出按照经理号分出以后的付给雇员的最低薪水

144
00:07:30,730 --> 00:07:31,850
最低薪水不就是min

145
00:07:31,850 --> 00:07:33,130
对吧

146
00:07:33,130 --> 00:07:36,730
然后排除最低薪水小于等于6000的组

147
00:07:36,730 --> 00:07:40,170
那我们是不是还得用having子句对经理号分组以后的数据

148
00:07:40,170 --> 00:07:44,490
再用having子句去做一个最小薪水怎么的

149
00:07:44,490 --> 00:07:47,690
最小薪水大于6000的组

150
00:07:47,690 --> 00:07:50,650
排除小于等于

151
00:07:50,650 --> 00:07:52,250
最低薪水排除小于

152
00:07:52,250 --> 00:07:55,170
那我们要的不就是比6000小的

153
00:07:55,170 --> 00:07:57,534
我们是不是得最低薪水大于6000

154
00:07:58,298 --> 00:08:02,206
明白这些吗?然后按照吸血教育排序就可以了。

155
00:08:02,938 --> 00:08:05,938
我们把这个题分析出来了 接下来做就很容易了

156
00:08:05,938 --> 00:08:09,098
我们一步一步来 遇到这样稍微复杂一些的题

157
00:08:09,098 --> 00:08:11,178
你不要想着一次性就把它写出来

158
00:08:11,178 --> 00:08:12,858
我们先一步一步的去解决

159
00:08:12,858 --> 00:08:16,138
比如说先写select from然后unplye

160
00:08:16,138 --> 00:08:19,258
我们确定这个表里的所有的数据用一个unplye表就够了

161
00:08:19,258 --> 00:08:22,218
对吧 然后接下来去排除看看它有什么数据

162
00:08:22,218 --> 00:08:24,218
排除那些经理未知的人

163
00:08:24,218 --> 00:08:25,578
这里肯定有y二子句了

164
00:08:25,578 --> 00:08:30,778
一点managerid is notnone

165
00:08:30,778 --> 00:08:33,978
这是不是就把那些经理未知的人排出去了

166
00:08:33,978 --> 00:08:37,498
对不对 然后接下来还得去算按照经理号

167
00:08:37,498 --> 00:08:41,498
显示经理号和经理付给雇员的最低薪水

168
00:08:41,498 --> 00:08:45,258
经理付给雇员的最低薪水那不得按经理分组

169
00:08:45,258 --> 00:08:49,978
所以肯定有个grow by 谁呢一点managerid

170
00:08:49,978 --> 00:08:55,178
对吧同学们 然后它要显示最低薪水

171
00:08:55,178 --> 00:09:01,258
那这我们是不是可以先显示一点managerid然后再来一个min

172
00:09:01,258 --> 00:09:04,618
然后一点salary把最低薪水显示出来对吧

173
00:09:04,618 --> 00:09:06,218
那么现在我们查的是什么

174
00:09:06,218 --> 00:09:09,338
是排除了没有经理的这个人

175
00:09:09,338 --> 00:09:10,618
没有经理的那些人

176
00:09:10,618 --> 00:09:12,298
那就查询有经理的

177
00:09:12,298 --> 00:09:18,298
然后显示他们每个相同经理的员工所付给的最低薪水

178
00:09:18,298 --> 00:09:20,990
就是经理相同的人他们的最低薪水

179
00:09:20,990 --> 00:09:22,362
< No Speech >

180
00:09:22,362 --> 00:09:22,962
是吧

181
00:09:22,962 --> 00:09:24,762
但是我还不是要所有最低的

182
00:09:24,762 --> 00:09:25,242
我要什么

183
00:09:25,242 --> 00:09:29,722
要薪水最低薪水小于等于6000的

184
00:09:29,722 --> 00:09:30,002
组

185
00:09:30,722 --> 00:09:31,602
排除注意

186
00:09:31,602 --> 00:09:34,242
是排除最低薪水小于等于6000

187
00:09:34,242 --> 00:09:36,282
那我要的不就是大于6000的了

188
00:09:36,282 --> 00:09:37,042
对不对

189
00:09:37,042 --> 00:09:39,562
所以这个时候是不是在grow by后面

190
00:09:39,562 --> 00:09:43,482
还得加一个having子句去过滤6000的

191
00:09:43,482 --> 00:09:43,722
组

192
00:09:43,722 --> 00:09:44,842
是吧

193
00:09:44,842 --> 00:09:46,162
排除小于6000的组

194
00:09:46,162 --> 00:09:46,922
那就是什么

195
00:09:46,922 --> 00:09:49,442
mean salary

196
00:09:49,442 --> 00:09:50,682
一点

197
00:09:50,682 --> 00:09:51,562
salary

198
00:09:51,562 --> 00:09:56,202
排除小排除低于小于等于那就是要大于6000的

199
00:09:56,202 --> 00:09:56,990
对不对

200
00:09:56,990 --> 00:09:58,234
< No Speech >

201
00:09:58,234 --> 00:10:03,154
对吧同学们 然后他又说按薪水的降续排序

202
00:10:03,154 --> 00:10:07,194
那我再来一个order by 按照最低薪水的一个降续排序

203
00:10:07,194 --> 00:10:11,034
那就是再min 然后一点 salary

204
00:10:11,034 --> 00:10:14,874
一点 salary 对吧

205
00:10:14,874 --> 00:10:18,834
然后降续disc 不就行了吗 是吧

206
00:10:18,834 --> 00:10:20,714
运行 ok 可以看到

207
00:10:20,714 --> 00:10:24,194
现在我们所查到的数据就是相同经理号

208
00:10:24,194 --> 00:10:26,754
那些相同经理号的最低薪水

209
00:10:26,754 --> 00:10:30,754
并且排除了这个薪水 最低薪水

210
00:10:30,754 --> 00:10:33,874
小于等于6000 都是大于6000的

211
00:10:33,874 --> 00:10:36,954
都是大于6000以上的 并且是不包含6000的

212
00:10:36,954 --> 00:10:40,894
对吧同学们 这样我们就把这个结果记查出来了

213
00:10:40,894 --> 00:10:44,186
< No Speech >

214
00:10:44,186 --> 00:10:49,666
第五题,好我们再来看第六题,第六题呢他要求的是写一个查询

215
00:10:49,666 --> 00:10:57,546
显示每个部门的名字、地点、人数和部门中所有雇员的平均薪水,四舍五入到两位小数

216
00:10:57,546 --> 00:10:58,714
< No Speech >

217
00:10:58,714 --> 00:11:10,074
那么你看他要的这个结果是什么 他要的是显示部门的名字 地点 人数和部门中所有雇员的平均薪水

218
00:11:10,074 --> 00:11:15,518
部门的名字在哪个表里 是不是在department的表里 对吧 地点呢 也在department表里

219
00:11:15,518 --> 00:11:17,242
< No Speech >

220
00:11:17,242 --> 00:11:20,402
那么我们这里是不是得去查询还有平均薪水

221
00:11:20,402 --> 00:11:21,762
薪水是在unemployee表里

222
00:11:21,762 --> 00:11:23,722
那我这是一个典型的多表链接了

223
00:11:23,722 --> 00:11:26,442
得去查unemployee表跟department表

224
00:11:26,442 --> 00:11:27,762
对吧同学们

225
00:11:27,762 --> 00:11:29,022
然后呢

226
00:11:29,690 --> 00:11:36,090
显示每个部门的名字,我们是不是还得按部门名称,就department的内部去分组

227
00:11:36,090 --> 00:11:43,358
对吧,部门名字,然后地点,显示每个部门的名字,地点

228
00:11:43,358 --> 00:11:44,826
< No Speech >

229
00:11:44,826 --> 00:11:51,026
那我是不是按照部门的名字分完组了以后 我还得按这个部门的地点再去分组

230
00:11:51,026 --> 00:11:52,122
< No Speech >

231
00:11:52,122 --> 00:11:56,322
明白这些吧同学们 这样我们这个查询基本上就写出来了

232
00:11:56,322 --> 00:11:58,322
好 我们一步一步来

233
00:11:58,322 --> 00:12:02,402
先select from

234
00:12:02,402 --> 00:12:05,122
我们现在确定了我们要的数据来源于两个表

235
00:12:05,122 --> 00:12:09,122
一个是employee表 一个是departmentid

236
00:12:09,122 --> 00:12:11,602
然后呢 where先去做一个等值链接

237
00:12:11,602 --> 00:12:16,002
一点departmentid等于d.departmentid

238
00:12:16,002 --> 00:12:19,682
现在我们就能找到所有的员工以及员工所对应的所有的部门了

239
00:12:19,682 --> 00:12:21,682
对不对 那么我们要的是什么呢

240
00:12:21,682 --> 00:12:26,482
要的是每个部门的名字以及地点的人数

241
00:12:26,482 --> 00:12:30,162
那么人数我们是不是可以用count星啊

242
00:12:30,162 --> 00:12:34,882
对吧 那他现在呢要按部门名字以及地点

243
00:12:34,882 --> 00:12:37,442
那我们这肯定要做一个分组了 谁呢

244
00:12:37,442 --> 00:12:42,322
一d.departmentid 先按名字分组

245
00:12:42,322 --> 00:12:45,522
名字分组以后呢还有这个工作的地点呢

246
00:12:45,522 --> 00:12:48,802
那逗号再去d.locationid

247
00:12:48,802 --> 00:12:55,642
按照他去分组 是不是就可以找到名字相同的且地点不同的了

248
00:12:55,642 --> 00:12:56,794
< No Speech >

249
00:12:56,794 --> 00:12:57,394
对吧

250
00:12:57,394 --> 00:12:59,594
然后人数人数怎么办

251
00:12:59,594 --> 00:13:03,066
< No Speech >

252
00:13:03,066 --> 00:13:05,506
对吧 那他还要什么 显示部门的名字

253
00:13:05,506 --> 00:13:11,786
地点department name 这个肯定是要的

254
00:13:11,786 --> 00:13:17,066
对吧 然后还有什么 这个地点location 对吧

255
00:13:17,066 --> 00:13:20,670
然后呢 逗号还有一个count 逗号

256
00:13:20,670 --> 00:13:23,162
< No Speech >

257
00:13:23,162 --> 00:13:27,402
看的形容不就行了吗?去计算它们的人数嘛

258
00:13:27,402 --> 00:13:31,362
然后还有呢,试试五入吸血道两位小数,那就是逗号

259
00:13:31,362 --> 00:13:33,246
medicine当然来源于老臭痘痛的粗义糖。

260
00:13:33,246 --> 00:13:34,426
< No Speech >

261
00:13:34,426 --> 00:13:36,638
最小薪平均薪水是吧

262
00:13:36,638 --> 00:13:39,482
< No Speech >

263
00:13:39,482 --> 00:13:42,962
啊 雇员的平均薪水 然后告诉你 市场五日薪水到两倍小数嘛

264
00:13:42,962 --> 00:13:45,962
那就是AVG 对吧 然后谁呢

265
00:13:45,962 --> 00:13:48,126
一点儿salary

266
00:13:48,126 --> 00:13:53,594
< No Speech >

267
00:13:53,594 --> 00:14:06,034
现在我们看到的这个结果就是啊部门名称相同的不同地点的员工数以及他们的平均薪水45日后的平均薪水

268
00:14:06,034 --> 00:14:07,386
< No Speech >

269
00:14:07,386 --> 00:14:20,826
明白吗同学们 我再说一遍 我们现在所查到的结果集就是部门名称相同的工作地点不同的人数以及他们薪水的平均薪水的市场入后的结果

270
00:14:20,826 --> 00:14:21,946
< No Speech >

271
00:14:21,946 --> 00:14:23,066
明天见 拜拜

272
00:14:24,058 --> 00:14:26,618
这样我们就把这个结果机插出来了

273
00:14:26,618 --> 00:14:28,058
< No Speech >

274
00:14:28,058 --> 00:14:31,978
OK,好同学们,那么这节课呢我们通过6个练习题

275
00:14:31,978 --> 00:14:34,658
对这个聚合函数以及数据分组

276
00:14:34,658 --> 00:14:39,378
数据分组当中的多列分组以及用海灵子聚过滤数据

277
00:14:39,378 --> 00:14:41,258
这样的练习我们都加了

278
00:14:41,258 --> 00:14:45,378
目的呢就是让大家进一步的去体会这个聚合函数与数据分组

279
00:14:45,378 --> 00:14:50,138
特别是这个数据分组,我们在开发的时候用的是非常多的

280
00:14:50,138 --> 00:14:54,178
一般复杂性查询都会有数据分组以及海灵子聚

281
00:14:54,178 --> 00:14:55,858
还有聚合函数的使用

282
00:14:55,858 --> 00:14:58,458
好同学们,那么这节课就到这

