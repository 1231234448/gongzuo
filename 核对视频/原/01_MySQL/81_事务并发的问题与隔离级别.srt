1
00:00:00,000 --> 00:00:01,146
< No Speech >

2
00:00:01,146 --> 00:00:06,466
这节课我们再来讲解一下MySQL数据库中的事物并发问题

3
00:00:06,466 --> 00:00:08,826
那么什么是事物并发问题呢?

4
00:00:08,826 --> 00:00:13,666
事物并发问题不仅仅出现在MySQL数据库中

5
00:00:13,666 --> 00:00:17,506
而是所有的公安型数据库里都会有事物并发问题

6
00:00:17,506 --> 00:00:22,026
那我们要先搞清楚,事物并发问题是怎么产生的呢?

7
00:00:22,026 --> 00:00:26,506
所有的公安型数据库,为了提高数据库的性能

8
00:00:26,506 --> 00:00:32,478
它在处理客户端链接的请求或者是处理客户端发送过来的SQL语句的时候

9
00:00:32,478 --> 00:00:34,010
< No Speech >

10
00:00:34,010 --> 00:00:36,490
多线程的方式来运行的

11
00:00:36,490 --> 00:00:37,450
那我们知道

12
00:00:37,450 --> 00:00:40,290
如果什么东西以多线程的方式来运行

13
00:00:40,290 --> 00:00:42,686
那也就意味着线程之间是有并发问题的

14
00:00:43,226 --> 00:00:47,546
对吧?比如说现在当两个线程或者叫两个事物

15
00:00:47,546 --> 00:00:49,786
每一个事物都是一个线程可以吧

16
00:00:49,786 --> 00:00:52,746
那么这两个事物操作同一个账户时

17
00:00:52,746 --> 00:00:54,558
那么这肯定会有并发的问题啊

18
00:00:54,558 --> 00:00:56,634
< No Speech >

19
00:00:56,634 --> 00:01:00,914
并发的问题一旦出现了,它会产生哪些现象呢?

20
00:01:00,914 --> 00:01:05,594
这里我们来看一下,第一个现象就是会出现脏毒的现象

21
00:01:05,594 --> 00:01:07,006
那么什么叫脏毒呢?

22
00:01:07,006 --> 00:01:08,186
< No Speech >

23
00:01:08,186 --> 00:01:13,946
读取未提交的数据,指一个事物读取了另外一个事物未提交的数据

24
00:01:13,946 --> 00:01:17,706
我们来看一下,这有一个表格,在这个表格当中有三个链

25
00:01:17,706 --> 00:01:22,986
第一个链是一个时间轴,第二个链是一个转账事物,第三个链是一个取款事物

26
00:01:22,986 --> 00:01:26,558
那么现在转账事物跟取款事物操作同一个账户

27
00:01:27,194 --> 00:01:29,194
而且这两个事物是并发的

28
00:01:29,194 --> 00:01:31,474
那么这里肯定会遇到一个什么

29
00:01:31,474 --> 00:01:33,674
现成安全的问题 对不对

30
00:01:33,674 --> 00:01:34,718
我们来看一下啊

31
00:01:34,718 --> 00:01:36,922
< No Speech >

32
00:01:36,922 --> 00:01:41,162
时间顺序为1的这个阶段,取款事务开始执行了

33
00:01:41,162 --> 00:01:42,430
那么它开始一个事务

34
00:01:42,430 --> 00:01:43,642
< No Speech >

35
00:01:43,642 --> 00:01:46,722
多线程 CPU在处理多线程时

36
00:01:46,722 --> 00:01:47,710
它采用的是什么?

37
00:01:48,346 --> 00:01:52,106
CPU在解决并发的问题是它采用的是什么方式

38
00:01:52,106 --> 00:01:54,706
是不是线程交替运行

39
00:01:54,706 --> 00:01:56,946
每个线程都有一个自己的时间片

40
00:01:56,946 --> 00:01:58,466
当这个时间片到达之后

41
00:01:58,466 --> 00:02:00,946
这个线程处于等待的状态

42
00:02:00,946 --> 00:02:02,346
然后另一个线程再运行

43
00:02:02,346 --> 00:02:06,146
另一个线程时间片到了再去换下一个线程过来

44
00:02:06,146 --> 00:02:07,306
来回交替的运行的

45
00:02:07,306 --> 00:02:08,346
对吧同学们

46
00:02:08,346 --> 00:02:10,266
那么比如说在1这个时间

47
00:02:10,266 --> 00:02:11,586
取款事务先执行了

48
00:02:11,586 --> 00:02:12,506
它开启一个事务

49
00:02:12,506 --> 00:02:14,466
然后它刚要往下执行

50
00:02:14,466 --> 00:02:16,106
结果它的时间片到了

51
00:02:16,106 --> 00:02:17,826
这个事务是不是就去等待状态了

52
00:02:17,826 --> 00:02:18,746
对吧去wait去了

53
00:02:18,746 --> 00:02:21,026
然后转账事务开始执行

54
00:02:21,026 --> 00:02:24,226
在2这个时间轴上转账事务开启事务

55
00:02:24,226 --> 00:02:26,146
然后取款事务处于等待

56
00:02:26,146 --> 00:02:29,506
然后在3这个时间轴上转账事务又去等待了

57
00:02:29,506 --> 00:02:30,506
它的时间片到了

58
00:02:30,506 --> 00:02:32,706
然后取款事务开始执行

59
00:02:32,706 --> 00:02:34,026
它查询余额为2000

60
00:02:34,026 --> 00:02:36,666
比如说现在这个账户的余额就是2000

61
00:02:36,666 --> 00:02:37,826
它查到的是2000

62
00:02:37,826 --> 00:02:38,986
然后它又往下走

63
00:02:38,986 --> 00:02:39,866
取款1000

64
00:02:39,866 --> 00:02:41,626
余额变更为1000

65
00:02:41,626 --> 00:02:43,546
然后这个时候注意它只是取了1000

66
00:02:43,546 --> 00:02:45,346
但是没有最终的事务确认的

67
00:02:45,346 --> 00:02:46,466
没有提交

68
00:02:46,466 --> 00:02:48,958
没有提交其实这个时候一切都是

69
00:02:48,958 --> 00:02:50,682
< No Speech >

70
00:02:50,682 --> 00:02:52,482
是没有最终确认的

71
00:02:52,482 --> 00:02:54,002
对吧同学们

72
00:02:54,002 --> 00:02:55,522
那么在这个阶段

73
00:02:55,522 --> 00:02:56,682
他的时间篇到了

74
00:02:56,682 --> 00:02:58,082
转账事务又进来了

75
00:02:58,082 --> 00:02:59,642
这个时候他去查询账户

76
00:02:59,642 --> 00:03:00,922
查询账户肯定是1000

77
00:03:00,922 --> 00:03:03,902
为什么原来2000被这个事务取了1000呢

78
00:03:03,902 --> 00:03:05,530
< No Speech >

79
00:03:05,530 --> 00:03:07,294
但是他读到这个1000是

80
00:03:07,294 --> 00:03:09,626
< No Speech >

81
00:03:09,626 --> 00:03:10,986
什么叫真实的数据

82
00:03:10,986 --> 00:03:14,466
是被这个事物彻底操作完毕以后的数据才是真实的

83
00:03:14,466 --> 00:03:17,906
而你现在读到这个1000只是被取款事物取出来了

84
00:03:17,906 --> 00:03:19,106
但是他没有最终确认

85
00:03:19,106 --> 00:03:20,798
他有可能确认有可能回轨的

86
00:03:21,370 --> 00:03:25,850
如果他确认了,那你在这个事物里查到的一千没问题

87
00:03:25,850 --> 00:03:27,038
那如果他要回滚呢?

88
00:03:28,026 --> 00:03:31,866
原来1000又变成2000了,那你这个1000和2000这不就不等了吗

89
00:03:31,866 --> 00:03:36,986
所以你现在读到这个1000,在转账事务里读到这个1000并不是真实的数据

90
00:03:36,986 --> 00:03:38,714
< No Speech >

91
00:03:38,714 --> 00:03:39,754
明白这些吧?

92
00:03:39,754 --> 00:03:42,334
然后注意看在6这个时间轴上

93
00:03:42,334 --> 00:03:43,866
< No Speech >

94
00:03:43,866 --> 00:03:47,866
我们说了事物是可以回滚的

95
00:03:47,866 --> 00:03:50,366
所谓的回滚就是撤销刚刚的操作

96
00:03:50,366 --> 00:03:52,990
那么他这撤销什么?是不是撤销区块操作呀?

97
00:03:52,990 --> 00:03:54,458
< No Speech >

98
00:03:54,458 --> 00:03:58,698
是2000取了1000一撤销把1000再还回去是不是账户又变成2000了

99
00:03:58,698 --> 00:03:59,138
对吧

100
00:03:59,138 --> 00:04:00,818
但是这他读到的仍然1000

101
00:04:00,818 --> 00:04:01,578
然后你再看

102
00:04:01,578 --> 00:04:03,978
转入2000余额被更改为3000

103
00:04:03,978 --> 00:04:04,778
为什么是3000

104
00:04:04,778 --> 00:04:07,058
因为他转了2000加他读到的1000

105
00:04:07,058 --> 00:04:10,298
这不3000张读的1000加转了20003000

106
00:04:10,298 --> 00:04:13,658
但是实质上现在金额转完账金额应该是几才对

107
00:04:13,658 --> 00:04:14,978
是不是4000才对

108
00:04:14,978 --> 00:04:16,658
因为原来里面有2000的

109
00:04:16,658 --> 00:04:17,938
你再转2000这不是4000

110
00:04:17,938 --> 00:04:19,298
那你这怎么变成3000了

111
00:04:19,298 --> 00:04:20,958
就因为我这读到的1000的是

112
00:04:20,958 --> 00:04:23,578
< No Speech >

113
00:04:23,578 --> 00:04:25,278
并不是最终的数据而导致的

114
00:04:25,278 --> 00:04:27,098
< No Speech >

115
00:04:27,098 --> 00:04:29,738
是吧同学们 然后就提交事务

116
00:04:29,738 --> 00:04:31,738
可是你的金额肯定是不对的

117
00:04:31,738 --> 00:04:32,778
按照正常逻辑

118
00:04:32,778 --> 00:04:35,058
此时账户余额应该为4000才对

119
00:04:35,058 --> 00:04:36,658
而现在是为3000

120
00:04:36,658 --> 00:04:38,110
这就是赃毒啊

121
00:04:38,938 --> 00:04:46,858
A45读取B45尚未提交的数据,此时如果B45发生错误并且执行回轨,那么A45读取到的数据就是脏数据

122
00:04:46,858 --> 00:04:52,218
这就是事物并发时有可能出现的第一个问题就是脏读

123
00:04:52,218 --> 00:04:56,618
当两个事物操作同一个数据时,有可能出现脏读的问题

124
00:04:56,618 --> 00:05:00,798
那么除了可能出现脏读以外,还可能出现什么呢?

125
00:05:00,798 --> 00:05:02,106
< No Speech >

126
00:05:02,106 --> 00:05:05,786
什么是不可重复读?就是前后多次读取,数据内容不一致

127
00:05:05,786 --> 00:05:10,622
在一个事物内读取表中的某一行数据,多次读取结果都不同

128
00:05:10,622 --> 00:05:13,658
< No Speech >

129
00:05:13,658 --> 00:05:18,258
还是第一列是时间轴 第二列是H5A 第三列是15B

130
00:05:18,258 --> 00:05:19,614
还是操作同一个数据

131
00:05:20,442 --> 00:05:22,590
依这个时间段 15A开启15A

132
00:05:22,590 --> 00:05:23,610
< No Speech >

133
00:05:23,610 --> 00:05:30,250
2这个时间段,时间轴上A是15,第一次查询,小明年龄为20,B是15,还是处于等待状态

134
00:05:30,250 --> 00:05:36,010
在3这个时间轴上,事物B被唤醒,他开始事物了,然后事物A处于等待状态

135
00:05:36,010 --> 00:05:42,462
然后在4这个时间轴上,事物A又被唤醒了,去完成其他操作,事物B又处于等待状态

136
00:05:42,462 --> 00:05:43,482
< No Speech >

137
00:05:43,482 --> 00:05:49,438
在事物B在5这个时间轴上更改,事物B运行了,更改小明的年龄为30

138
00:05:49,438 --> 00:05:50,810
< No Speech >

139
00:05:50,810 --> 00:05:57,810
然后第二次查询,这个事物A又做了一个对数据的查询,发现小明的年龄为30

140
00:05:57,810 --> 00:06:00,538
< No Speech >

141
00:06:00,538 --> 00:06:04,578
他在一个事物当中第一次查小明的年龄是12岁

142
00:06:04,578 --> 00:06:08,258
然后在第二次查小明的年龄时确认30岁

143
00:06:08,258 --> 00:06:09,658
那么这个30岁哪来的呢?

144
00:06:09,658 --> 00:06:11,818
这个30岁就是受事物B的影响

145
00:06:11,818 --> 00:06:12,818
它改变了事物

146
00:06:12,818 --> 00:06:15,898
所以我在事物A当中第二次读取小明的年龄时

147
00:06:15,898 --> 00:06:17,898
就读到他改完以后的30岁了

148
00:06:17,898 --> 00:06:20,298
那现在就出现了第一次在同一个事物里

149
00:06:20,298 --> 00:06:22,558
第一次跟第二次读到的数据是不一样的

150
00:06:23,258 --> 00:06:25,938
对吧同学们 所以这就是不可重复读

151
00:06:25,938 --> 00:06:30,298
正确 按正确逻辑 45A前后两次读到的数据应该是一致的

152
00:06:30,298 --> 00:06:33,178
但是现在不是 这就是不可重复读

153
00:06:33,178 --> 00:06:38,298
45A在执行读取操作 有整个45A比较大

154
00:06:38,298 --> 00:06:41,258
前后读取的一条数据需要经历很长时间

155
00:06:41,258 --> 00:06:43,258
而在45A第一次读取数据

156
00:06:43,962 --> 00:06:48,042
比如此时读取了小明的年龄是20,而事务B执行更改操作

157
00:06:48,042 --> 00:06:52,922
将小明的年龄更改为30,此时事务A第二次读取小明年龄时

158
00:06:52,922 --> 00:06:56,318
发现年龄是30岁了,和之前读的数据不一样了。

159
00:06:57,210 --> 00:06:58,654
数据不能重复了

160
00:06:59,162 --> 00:07:00,762
数据不能重复读了

161
00:07:00,762 --> 00:07:01,602
读的都不一致了

162
00:07:01,602 --> 00:07:02,522
两次读的都不一致了

163
00:07:02,522 --> 00:07:03,322
就不能重复了

164
00:07:03,322 --> 00:07:03,962
对不对

165
00:07:03,962 --> 00:07:05,882
系统不可以读取到重复的数据

166
00:07:05,882 --> 00:07:07,294
成为不可重复读

167
00:07:07,898 --> 00:07:12,938
这就是在事物并发时会产生的第二种现象,叫不可重复读

168
00:07:12,938 --> 00:07:13,578
明白吧

169
00:07:13,578 --> 00:07:18,378
那么其实在事物并发当中还有第三种现象,叫什么

170
00:07:18,378 --> 00:07:19,018
换读

171
00:07:19,018 --> 00:07:19,978
什么叫换读呢

172
00:07:19,978 --> 00:07:22,782
就是前后多次读取,数据总量不一致

173
00:07:23,386 --> 00:07:27,926
是指一个事物内读取到的别的事物插入的数据

174
00:07:27,926 --> 00:07:30,286
导致其后读取的数量是不一致的

175
00:07:30,286 --> 00:07:31,998
我们来看一下这有一个表格

176
00:07:31,998 --> 00:07:33,370
< No Speech >

177
00:07:33,370 --> 00:07:38,610
在时间轴1这个时间轴上,事物A开始失误,事物B处于等待

178
00:07:38,610 --> 00:07:43,650
然后2这个时间轴上,事物A第一次查询,数据总量为100条,事物B仍然等待

179
00:07:43,650 --> 00:07:47,970
在3这个时间轴上,B失误开始,然后A失误处于等待

180
00:07:47,970 --> 00:07:53,250
在4这个时间轴上,A失误又开始,进行了其他的操作,事物B又处于等待

181
00:07:53,250 --> 00:07:57,090
在第5个时间轴上,新增数据100条,然后提交失误

182
00:07:57,090 --> 00:07:57,470
kicked

183
00:07:58,362 --> 00:08:00,362
这时候45A是处于等待的吧 是吧

184
00:08:00,362 --> 00:08:03,230
在745A第二次查询数据总量为200000

185
00:08:03,230 --> 00:08:06,330
< No Speech >

186
00:08:06,330 --> 00:08:08,050
不可重复的有点相似

187
00:08:08,050 --> 00:08:11,130
也就是前后读导的数据仍然是不一致的

188
00:08:11,130 --> 00:08:12,490
按正确逻辑

189
00:08:12,490 --> 00:08:15,806
45A前后两次读导的数据总量应该是一致的

190
00:08:15,806 --> 00:08:20,410
< No Speech >

191
00:08:20,410 --> 00:08:24,210
执行读取操作时,需要两次统计数据的总量

192
00:08:24,210 --> 00:08:29,410
前一次查询的总量后,此时事物B执行了新增数据的操作后并提交

193
00:08:29,410 --> 00:08:32,890
这个时候事物A读取到的数据总量和之前的统计不一样

194
00:08:32,890 --> 00:08:37,890
就像产生了幻觉一样,平白无故的多了几条数据,那就成了幻读了

195
00:08:37,890 --> 00:08:39,090
明白这些是吧?

196
00:08:39,090 --> 00:08:42,970
幻读现象也是在事物的并发问题当中

197
00:08:42,970 --> 00:08:46,206
并发问题当中会出现的一种现象

198
00:08:46,206 --> 00:08:48,122
< No Speech >

199
00:08:48,122 --> 00:08:54,522
我们怎么解决这个问题呢?其实数据库也知道由于它的并发问题会影响到事物的

200
00:08:54,522 --> 00:08:57,086
由于它支持它的数据库支持这个并发问题的问题,所以它会影响到事物的

201
00:08:57,086 --> 00:08:58,426
< No Speech >

202
00:08:58,426 --> 00:08:59,906
以多线程的模式来运行

203
00:08:59,906 --> 00:09:02,226
那么他也知道会产生事物的并发问题

204
00:09:02,226 --> 00:09:05,026
所以这里所有的公安型数据库

205
00:09:05,026 --> 00:09:09,342
都可以通过添加事物的隔离级别来解决

206
00:09:10,298 --> 00:09:13,098
但是他也不能很好地全部解决

207
00:09:13,098 --> 00:09:15,898
那么其实对于数据库而言

208
00:09:15,898 --> 00:09:17,338
关于数据库而言

209
00:09:17,338 --> 00:09:19,178
它在这一块也是比较难做的

210
00:09:19,178 --> 00:09:22,898
如果他要把事物隔离级别做得很安全

211
00:09:22,898 --> 00:09:23,902
那大家想一想

212
00:09:24,890 --> 00:09:26,210
隔离级别是最安全的

213
00:09:26,210 --> 00:09:29,690
就是现在比如说两个事物同时操作一个账户出现并发问题

214
00:09:29,690 --> 00:09:31,650
如果换成你去解决这个问题

215
00:09:31,650 --> 00:09:33,330
你觉得什么样是最安全的

216
00:09:33,330 --> 00:09:35,370
是不是把并发去掉

217
00:09:35,370 --> 00:09:37,610
让他们所有的事物都变成串行化

218
00:09:37,610 --> 00:09:39,010
一个一个去执行

219
00:09:39,010 --> 00:09:41,890
不就不会有事物并发的问题了

220
00:09:41,890 --> 00:09:43,490
A事物执行完了

221
00:09:43,490 --> 00:09:44,730
B事物再执行

222
00:09:44,730 --> 00:09:46,718
这肯定不会有并发的问题

223
00:09:47,450 --> 00:09:49,250
你失误一串形化了

224
00:09:49,250 --> 00:09:51,610
你的数据库的性能会不会受到影响

225
00:09:51,610 --> 00:09:52,670
肯定会受到影响啊

226
00:09:53,178 --> 00:09:56,258
所有的并发都改成串行化,性能肯定会受到影响

227
00:09:56,258 --> 00:09:56,858
对不对?

228
00:09:56,858 --> 00:10:01,058
那你如果为了考虑性能,把所有的事物都支持并发了

229
00:10:01,058 --> 00:10:03,498
你的数据库是支持这种多线程模式运行的话

230
00:10:03,498 --> 00:10:05,098
那就会产生这种并发的现象

231
00:10:05,098 --> 00:10:06,174
那并发到纽约

232
00:10:06,174 --> 00:10:08,826
< No Speech >

233
00:10:08,826 --> 00:10:09,546
对不对

234
00:10:09,546 --> 00:10:13,026
所以数据库也是在一直纠结这个问题

235
00:10:13,026 --> 00:10:16,186
该重点让天平偏向于谁

236
00:10:16,186 --> 00:10:19,166
是偏向于性能还是偏向于安全

237
00:10:19,962 --> 00:10:20,522
对吧

238
00:10:20,522 --> 00:10:22,526
所以不同的数据户品牌

239
00:10:23,514 --> 00:10:26,206
凡尔玛这个游标它所偏向的重点

240
00:10:26,206 --> 00:10:28,698
< No Speech >

241
00:10:28,698 --> 00:10:30,938
我们来看一下事物隔离级别

242
00:10:30,938 --> 00:10:35,778
事物的隔离级别用于决定如何控制并发用户读写数据的操作

243
00:10:35,778 --> 00:10:38,618
数据库是允许多用户并发访问的

244
00:10:38,618 --> 00:10:42,618
如果多个用户同时开启事物并对同一数据进行读写操作的话

245
00:10:42,618 --> 00:10:43,518
有可能出现

246
00:10:44,058 --> 00:10:46,218
不可重复读和换读的问题

247
00:10:46,218 --> 00:10:47,258
这我们刚刚说过了

248
00:10:47,258 --> 00:10:49,138
这都是事物并发所带来的问题

249
00:10:49,138 --> 00:10:49,618
对吧

250
00:10:49,618 --> 00:10:51,018
所以我们在mycycle当中

251
00:10:51,018 --> 00:10:53,738
提供了四种隔离级别来解决上述问题

252
00:10:53,738 --> 00:10:55,102
事物的隔离级别

253
00:10:55,102 --> 00:10:56,954
< No Speech >

254
00:10:56,954 --> 00:10:58,954
它的安全性从低到高

255
00:10:58,954 --> 00:11:00,030
分别是

256
00:11:00,030 --> 00:11:01,498
< No Speech >

257
00:11:01,498 --> 00:11:02,750
认真读。

258
00:11:02,750 --> 00:11:03,930
< No Speech >

259
00:11:03,930 --> 00:11:06,690
Read committed 读以提交

260
00:11:06,690 --> 00:11:08,414
还有一个repeatable read

261
00:11:08,414 --> 00:11:13,018
< No Speech >

262
00:11:13,018 --> 00:11:16,098
那么他的隔离级别是从低到高

263
00:11:16,098 --> 00:11:18,058
也就是说Threshold的隔离级别是最高的

264
00:11:18,058 --> 00:11:19,418
为什么?他都串行化了

265
00:11:19,418 --> 00:11:20,818
他能级别能不高吗?

266
00:11:20,818 --> 00:11:23,858
他肯定不会出现事物并发的问题

267
00:11:23,858 --> 00:11:25,898
对不对?那么谁的隔离级别最低呢?

268
00:11:25,898 --> 00:11:27,678
瑞丹卡蜜的毒味提要

269
00:11:28,186 --> 00:11:33,626
好,那我们看这里给大家准备了一个表,在这个表当中你看它有四种隔离级别

270
00:11:33,626 --> 00:11:38,386
其实不仅仅是MySQL,其他的数据库也是有这四种隔离级别的

271
00:11:38,386 --> 00:11:43,106
那么这四种隔离级别会出现一个什么样的现象呢?

272
00:11:43,106 --> 00:11:43,678
比如说……

273
00:11:43,678 --> 00:11:46,010
< No Speech >

274
00:11:46,010 --> 00:11:53,330
串型化就是把所有的事物都不是并发去运行 而是一个一个的去串型化执行 那它肯定安全性是最高的

275
00:11:53,330 --> 00:11:57,370
所以它不会出现脏毒 注意看Y表示解决 N表示未解决

276
00:11:57,370 --> 00:12:04,702
所以在串型化这个级别上 它不会出现脏毒 也不会出现不可重复毒 也不会出现换毒 它安全性是最高的

277
00:12:04,702 --> 00:12:07,258
< No Speech >

278
00:12:07,258 --> 00:12:08,478
性能是最低的

279
00:12:08,478 --> 00:12:09,626
< No Speech >

280
00:12:09,626 --> 00:12:11,826
对吧 同学们 它的性能肯定是最低的

281
00:12:11,826 --> 00:12:13,982
原来是一起执行 现在变成一个一个执行

282
00:12:13,982 --> 00:12:17,018
< No Speech >

283
00:12:17,018 --> 00:12:19,230
这个隔离级别叫repeatable read

284
00:12:19,802 --> 00:12:21,214
Repeatable Read是

285
00:12:21,214 --> 00:12:22,266
< No Speech >

286
00:12:22,266 --> 00:12:24,506
repeatable不重复的意思吗 是吧 重复读

287
00:12:24,506 --> 00:12:29,662
然后它解决了脏读 也就是说如果你的事物隔离级别是repeatable read的话

288
00:12:30,618 --> 00:12:31,978
脏毒不会出现

289
00:12:31,978 --> 00:12:33,374
不可重复毒不会出现

290
00:12:33,374 --> 00:12:36,218
< No Speech >

291
00:12:36,218 --> 00:12:38,814
明天这次如果是瑞德扛的呢

292
00:12:38,814 --> 00:12:41,338
< No Speech >

293
00:12:41,338 --> 00:12:42,622
然后不可重复读

294
00:12:42,622 --> 00:12:44,986
< No Speech >

295
00:12:44,986 --> 00:12:47,866
脏毒不会出现,这两个会出现,明白吧

296
00:12:47,866 --> 00:12:50,586
还有一个read,uncommitted,这是所有的都会出现

297
00:12:50,586 --> 00:12:52,226
它的隔离级别是最低的

298
00:12:52,226 --> 00:12:55,506
脏毒,不可乘务毒,患毒都会出现,明白这意思吧

299
00:12:55,506 --> 00:12:59,066
那么在MySQL当中,它默认的隔离级别是谁呢

300
00:12:59,066 --> 00:13:01,950
MySQL当中默认的隔离级别是repeatable read

301
00:13:02,810 --> 00:13:06,850
而其他官型数据库大多数比如说像Oracle

302
00:13:06,850 --> 00:13:08,158
他们的隔离级别是

303
00:13:08,158 --> 00:13:11,994
< No Speech >

304
00:13:11,994 --> 00:13:15,554
明白吧?那MySQL当中默认的是repeatable read

305
00:13:15,554 --> 00:13:16,634
这个同学们要注意

306
00:13:16,634 --> 00:13:17,074
好

307
00:13:17,434 --> 00:13:20,314
那么我们现在能不能查看一下MySQL当中的

308
00:13:20,314 --> 00:13:22,474
这个15格里级别到底是什么呢?可以的

309
00:13:22,474 --> 00:13:24,434
我们通过一个select的语句就可以了

310
00:13:24,434 --> 00:13:25,034
select

311
00:13:25,034 --> 00:13:26,474
然后att2at4

312
00:13:26,474 --> 00:13:28,674
然后transaction下滑线有一个

313
00:13:28,674 --> 00:13:29,534
ésolation

314
00:13:30,074 --> 00:13:31,674
隔离对吧 说的也是

315
00:13:31,674 --> 00:13:33,022
好 我们去执行一下

316
00:13:33,022 --> 00:13:35,258
< No Speech >

317
00:13:35,258 --> 00:13:41,258
现在读到了我MySQL数据库的默认隔离级别是什么

318
00:13:41,258 --> 00:13:42,938
是不是repeatable read

319
00:13:42,938 --> 00:13:43,498
对吧

320
00:13:43,538 --> 00:13:46,018
那么repeatable read会解决什么问题

321
00:13:46,018 --> 00:13:47,778
脏读不可存入读

322
00:13:47,818 --> 00:13:48,618
没有解决什么

323
00:13:48,618 --> 00:13:49,310
换读

324
00:13:49,310 --> 00:13:51,610
< No Speech >

325
00:13:51,610 --> 00:13:54,810
那么我们能不能对这个事物隔离级别做设置呢?

326
00:13:54,810 --> 00:13:58,410
答案是可以的,我们通过set session就可以了

327
00:13:58,410 --> 00:14:02,050
但是这里需要注意,你现在所设置的这个事物隔离级别

328
00:14:02,050 --> 00:14:04,410
是仅对当前session有效,什么叫session呢?

329
00:14:04,410 --> 00:14:07,010
就是你的客户端连接了Mesko的服务端

330
00:14:07,010 --> 00:14:10,410
那么这一次绘画对于当前这个客户端而言

331
00:14:10,410 --> 00:14:14,250
这是一个session绘画,你另一个客户端又去连接Mesko了

332
00:14:14,250 --> 00:14:16,250
那么这个时候它又是一个独立的session

333
00:14:16,250 --> 00:14:19,970
所以说我们在某个客户端里去设置了这个事物隔离级别

334
00:14:19,970 --> 00:14:22,450
它的有效性只针对你当前这个客户端

335
00:14:22,450 --> 00:14:25,930
而其他的客户端当中,它的事物隔离级别

336
00:14:25,930 --> 00:14:31,010
你的设置事物隔离级别并不会影响到其他客户端的绘画

337
00:14:31,010 --> 00:14:33,610
它是一个局部的设置一个绘画

338
00:14:33,610 --> 00:14:36,090
明白这些吧,同学们?

339
00:14:36,090 --> 00:14:39,770
我们可以通过set session transaction isolation level

340
00:14:39,770 --> 00:14:42,650
然后给定,比如说现在我想把它变成serializable

341
00:14:42,650 --> 00:14:46,654
那就把它拷过来,然后放到这

342
00:14:46,654 --> 00:14:47,706
< No Speech >

343
00:14:47,706 --> 00:14:49,706
然后我们选中去运行

344
00:14:49,706 --> 00:14:51,706
然后我们再去查

345
00:14:52,346 --> 00:14:55,546
但是这个时候如果你再打开一个客户端

346
00:14:55,546 --> 00:14:56,786
你去连接这个MySQL

347
00:14:56,786 --> 00:15:01,086
那么它的事物隔离级别就不是SERIALIZABLE

348
00:15:01,754 --> 00:15:03,794
明天再说吧我们可以看一下啊

349
00:15:03,794 --> 00:15:05,146
< No Speech >

350
00:15:05,146 --> 00:15:06,946
我们找 MySQL

351
00:15:07,446 --> 00:15:09,146
我再打开一个客户端

352
00:15:09,646 --> 00:15:12,106
然后这里我输入 root

353
00:15:12,106 --> 00:15:15,358
然后把命令copy过来

354
00:15:15,358 --> 00:15:18,042
< No Speech >

355
00:15:18,042 --> 00:15:19,642
然后我们粘过来

356
00:15:20,474 --> 00:15:25,114
看到了吗同学们 是什么呀 是不是还是repeatable read

357
00:15:25,114 --> 00:15:27,934
是吧 我们在查 在这里在查

358
00:15:27,934 --> 00:15:29,434
< No Speech >

359
00:15:29,434 --> 00:15:32,794
我们在这里再查是不是realizable是吧

360
00:15:32,794 --> 00:15:36,114
然后这里是repeatable reader看到了吗

361
00:15:36,114 --> 00:15:40,034
这就是仅对当前这个客户端会话

362
00:15:40,034 --> 00:15:44,954
或者叫客户端会话生效的一种设置隔离级别的方式

363
00:15:44,954 --> 00:15:47,154
没有吧这已经很直接了是吧

364
00:15:47,154 --> 00:15:48,554
看这个结果已经很直接了

365
00:15:48,554 --> 00:15:51,314
那么同学说老师除了这种方式

366
00:15:51,314 --> 00:15:53,794
有没有其他的方式来解决这个事物隔离级别呢

367
00:15:53,794 --> 00:15:55,954
我听你说完以后我觉得这个问题很严重

368
00:15:55,954 --> 00:15:58,194
我们在开发的时候怎么去解决这个问题呢

369
00:15:58,194 --> 00:16:02,474
这一块同学不要太去过度的操心

370
00:16:02,474 --> 00:16:03,074
为什么呢

371
00:16:03,074 --> 00:16:06,434
我们未来会学到一个框架叫Spring

372
00:16:06,434 --> 00:16:10,834
在Spring当中它有一个特点就是

373
00:16:10,834 --> 00:16:13,954
在Spring当中是可以做事物控制的

374
00:16:13,954 --> 00:16:16,714
那Spring当中是可以它的事物控制

375
00:16:16,714 --> 00:16:19,074
对这个数据库的事物控制非常的强大

376
00:16:19,074 --> 00:16:19,754
它怎么办呢

377
00:16:19,754 --> 00:16:22,914
它可以指定某一个方法

378
00:16:22,914 --> 00:16:25,714
或者某些方法间的事物隔离级别

379
00:16:25,714 --> 00:16:28,914
就不像我们现在设置的这个是针对某一次绘画了

380
00:16:28,914 --> 00:16:31,358
也就是这次绘画当中的所有的

381
00:16:31,358 --> 00:16:32,666
< No Speech >

382
00:16:32,666 --> 00:16:35,546
操作都得是这样的一个隔离级别的

383
00:16:35,546 --> 00:16:37,466
它针对的是绘画

384
00:16:37,466 --> 00:16:40,586
而Spring当中是针对的某些方法

385
00:16:40,586 --> 00:16:41,706
它的隔离级别是什么

386
00:16:41,706 --> 00:16:43,866
那你想想谁的颗粒度更细

387
00:16:43,866 --> 00:16:46,026
是不是Spring里的设置更细

388
00:16:46,026 --> 00:16:46,746
对吧

389
00:16:46,746 --> 00:16:48,666
它可以针对某些方法在运行时

390
00:16:48,666 --> 00:16:50,346
如果这些方法在同时运行时

391
00:16:50,346 --> 00:16:53,066
那么它应该是一个什么样的隔离级别

392
00:16:53,066 --> 00:16:55,786
不同的方法可以指定不同的隔离级别

393
00:16:55,786 --> 00:16:59,866
所以我们未来会更多的会依赖于Spring框架

394
00:16:59,866 --> 00:17:04,186
来做更颗粒度更细致的或者更细腻的事物控制

395
00:17:04,186 --> 00:17:07,626
那么这个事物隔离级别的一个控制

396
00:17:07,626 --> 00:17:09,546
那么其实这样带来的好处就是

397
00:17:09,546 --> 00:17:12,186
你的事物隔离级别已经做了

398
00:17:12,186 --> 00:17:13,786
保证了你现成的安全

399
00:17:13,786 --> 00:17:17,786
同时你数据库的并发性能又没有受到太大的影响

400
00:17:17,786 --> 00:17:19,386
明白这些吧同学们

401
00:17:19,386 --> 00:17:21,822
所以在这儿同学们只要知道

402
00:17:22,362 --> 00:17:25,502
在数据库当中由于有事物并发的问题

403
00:17:25,502 --> 00:17:30,162
它会出现这种事物隔离性的一个问题

404
00:17:30,702 --> 00:17:31,302
是吧

405
00:17:31,302 --> 00:17:34,202
我们可以通过事物隔离级别来解决这个事物并发的问题

406
00:17:34,202 --> 00:17:35,102
能明白这意思吧

407
00:17:35,102 --> 00:17:36,030
好

408
00:17:36,730 --> 00:17:39,890
我们再来看一下这节课的实时效果反馈

409
00:17:39,890 --> 00:17:42,130
MySQL默认事物隔离级别是什么

410
00:17:42,130 --> 00:17:43,010
大家想一下

411
00:17:43,010 --> 00:17:44,370
A. Uncommit

412
00:17:44,370 --> 00:17:45,370
B. Commit

413
00:17:45,370 --> 00:17:46,770
C. Repeatable Read

414
00:17:46,770 --> 00:17:47,850
D. Serializable

415
00:17:47,850 --> 00:17:48,970
应该是哪个呢

416
00:17:48,970 --> 00:17:50,490
是不是很显然是C啊

417
00:17:50,490 --> 00:17:51,730
Repeatable Read

418
00:17:51,730 --> 00:17:52,210
是吧

419
00:17:52,210 --> 00:17:53,530
答案是C

420
00:17:53,530 --> 00:17:54,330
没有问题

421
00:17:54,330 --> 00:17:55,050
好同学们

422
00:17:55,050 --> 00:17:58,210
那么以上我们就把MySQL数据库当中的

423
00:17:58,210 --> 00:17:59,770
事物并发的问题

424
00:17:59,770 --> 00:18:01,770
它会带来哪些影响

425
00:18:01,770 --> 00:18:04,130
以及什么是事物隔离级别

426
00:18:04,130 --> 00:18:07,290
事物隔离级别对应的事物隔离级别可以解决

427
00:18:07,290 --> 00:18:09,410
事物并发问题的哪些现象

428
00:18:09,410 --> 00:18:10,490
这里我们都说了

429
00:18:10,490 --> 00:18:12,690
那么对于本节课的内容

430
00:18:12,690 --> 00:18:16,050
同学们更多的是需要做一个了解即可

431
00:18:16,050 --> 00:18:19,730
因为未来我们怎么具体的解决事物隔离级别的问题

432
00:18:19,730 --> 00:18:20,250
我说了

433
00:18:20,250 --> 00:18:23,330
还是要依赖于我们后面学到的Supreme框架去解决

434
00:18:23,330 --> 00:18:23,970
明白这意思吧

435
00:18:23,970 --> 00:18:25,450
但是这里你要知道

436
00:18:25,450 --> 00:18:27,410
事物并发时会产生哪些问题

437
00:18:27,410 --> 00:18:29,570
它的隔离级别又指的是什么意思

438
00:18:29,570 --> 00:18:30,770
OK

439
00:18:30,770 --> 00:18:31,370
好同学们

440
00:18:31,370 --> 00:18:33,374
那我们这节课就到这

