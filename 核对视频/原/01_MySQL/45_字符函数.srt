1
00:00:00,000 --> 00:00:01,242
< No Speech >

2
00:00:01,242 --> 00:00:04,638
上节课我们讲解了单行函数的介绍。

3
00:00:04,638 --> 00:00:05,658
< No Speech >

4
00:00:05,658 --> 00:00:07,658
在MySQL的大行函数当中

5
00:00:08,474 --> 00:00:10,154
五种类型的对吧

6
00:00:10,154 --> 00:00:15,314
那么接下来呢我们就会把这五种类型的函数啊进行逐一的讲解

7
00:00:15,314 --> 00:00:19,326
那么这节课呢我们先来讲解一下单行函数当中的函数

8
00:00:19,326 --> 00:00:20,762
< No Speech >

9
00:00:20,762 --> 00:00:26,602
那么什么是自服函数呢?其实我们通过这个名字也能知道这个函数的作用

10
00:00:26,602 --> 00:00:29,002
它就是来处理自服的,对吧?

11
00:00:29,002 --> 00:00:33,482
那么根据这个函数的特点,我们又分为两大类

12
00:00:33,482 --> 00:00:35,198
自服函数又分为两大类

13
00:00:36,122 --> 00:00:40,842
大小写处理的函数,第二大类是字符处理函数

14
00:00:40,842 --> 00:00:43,762
那我们先来看一下大小写处理函数

15
00:00:43,762 --> 00:00:50,042
那么其实大小写处理函数它的作用就是来转换大小写处理的

16
00:00:50,042 --> 00:00:54,622
好,那我们先来看一下能够做大小写处理的函数有哪些呢?

17
00:00:55,322 --> 00:01:00,642
首先第一个,函数名叫lower,然后这个函数需要一个参数

18
00:01:00,642 --> 00:01:06,602
那么这个函数的作用就是将给定的参数转换为小写

19
00:01:06,602 --> 00:01:12,602
那么除了有一个lower函数以外,还可以用一个lkis给一个参数

20
00:01:12,602 --> 00:01:16,282
这个参数也会被lkis这个函数转换成小写

21
00:01:16,282 --> 00:01:19,562
那么这个l其实指的就是lower这个单词的首字母

22
00:01:19,562 --> 00:01:22,602
明白这意思吧?这两个函数的作用都是相同的

23
00:01:22,602 --> 00:01:26,402
将字符串s转换为小写,比如说有一个实例

24
00:01:26,402 --> 00:01:30,162
将字符串o的卢转换为小写,o的卢现在是大写的对吧

25
00:01:30,162 --> 00:01:34,162
那么怎么转换呢?这里就涉及到一个问题了,什么问题呢?

26
00:01:34,162 --> 00:01:38,202
就是在MySQL当中我们怎么去调用这个函数

27
00:01:38,202 --> 00:01:43,122
这里我们要知道,如果你函数当中的参数这个值

28
00:01:43,122 --> 00:01:47,402
并不是来源于某个表的某个列实

29
00:01:47,402 --> 00:01:51,362
是你自己给的一个自定义的这个参数实

30
00:01:51,362 --> 00:01:53,562
那么我们对于这个函数的调用

31
00:01:53,562 --> 00:02:00,682
在MySQL当中我们给定用select的关键字来调用这个函数就可以了

32
00:02:00,682 --> 00:02:02,526
但是这里同学们注意啊

33
00:02:03,034 --> 00:02:06,994
在不同的官型数据库当中对于函数的调用是不一样的

34
00:02:06,994 --> 00:02:10,994
比如说Mysql当中是使用select然后加函数的名来调用

35
00:02:10,994 --> 00:02:12,514
而在Oracle当中

36
00:02:12,514 --> 00:02:17,194
如果你的函数的值并不是来源于某个表的某个列式

37
00:02:17,194 --> 00:02:19,554
它也要select函数名

38
00:02:19,554 --> 00:02:22,154
但是后面必须要加from

39
00:02:22,154 --> 00:02:24,474
然后加一个尾表的表名

40
00:02:24,474 --> 00:02:26,234
尾表就是假的那个尾列的

41
00:02:26,234 --> 00:02:28,074
尾表表名叫dol

42
00:02:28,074 --> 00:02:34,034
它提供了一个尾表用这个尾表来做一个补充为了满足这个结构化的查询语言

43
00:02:34,034 --> 00:02:35,634
这是Oracle的一个特点

44
00:02:35,634 --> 00:02:37,434
但是在Mysql下就不用了

45
00:02:37,434 --> 00:02:40,754
Mysql直接用select去调用函数就可以了

46
00:02:40,754 --> 00:02:41,954
明白这意思吧

47
00:02:41,954 --> 00:02:44,594
好那么接下来我们来写一个这个案例看一下

48
00:02:44,594 --> 00:02:52,094
如何通过lower这个函数将我们的这个大写的这个内容转换成小写

49
00:02:52,826 --> 00:02:54,826
好 我们来看一下第一个函数的使用

50
00:02:54,826 --> 00:02:55,930
< No Speech >

51
00:02:55,930 --> 00:02:58,330
用select的关键字去调用

52
00:02:58,330 --> 00:03:01,730
后面紧跟的给的就是你这个函数的名字

53
00:03:01,730 --> 00:03:04,730
当然这个函数的名字也是不区分大小写的

54
00:03:04,730 --> 00:03:07,570
然后在函数的括号当中来给定参数

55
00:03:07,570 --> 00:03:11,770
那么lower它既然是做字符串大小写处理的函数了

56
00:03:11,770 --> 00:03:13,930
那么它的参数肯定是字符串类型的

57
00:03:13,930 --> 00:03:16,210
所以我们给定一个字符串

58
00:03:16,210 --> 00:03:18,210
比如说大写的O的卢

59
00:03:18,210 --> 00:03:19,890
好 我们现在运行

60
00:03:19,890 --> 00:03:21,130
看到了吗同学们

61
00:03:21,130 --> 00:03:23,490
现在返回的结果是不是小写的O的卢

62
00:03:23,490 --> 00:03:27,330
对不对 这就是lower函数的一个作用

63
00:03:27,330 --> 00:03:29,570
好 那么这是转小写

64
00:03:29,570 --> 00:03:32,050
转大写我们会用upper

65
00:03:32,050 --> 00:03:35,130
upper然后也是给定一个字符串参数

66
00:03:35,130 --> 00:03:37,530
这个函数会把这个参数转化成大写

67
00:03:37,530 --> 00:03:40,290
那么除了upper以外还可以用一个Ukeys

68
00:03:40,290 --> 00:03:44,170
这个函数也是可以将这个参数转化成大写的

69
00:03:44,170 --> 00:03:47,010
那么这个U指的就是upper这个单词的简写

70
00:03:47,010 --> 00:03:48,730
首字母 明白这意思吧

71
00:03:48,730 --> 00:03:51,050
字符串将字符串S转回大写

72
00:03:51,050 --> 00:03:52,650
将字符串O的卢转回大写

73
00:03:52,650 --> 00:03:54,090
selected upper O的卢

74
00:03:54,090 --> 00:03:56,530
最后查询到的结果就是大写的O的卢

75
00:03:56,530 --> 00:03:58,174
我们也可以试一下

76
00:03:58,174 --> 00:03:59,258
< No Speech >

77
00:03:59,258 --> 00:04:01,938
现在把lower转换成upper

78
00:04:02,874 --> 00:04:04,994
OK,然后呢这里给定一个

79
00:04:04,994 --> 00:04:06,794
当然我说了在Meseco当中啊

80
00:04:06,794 --> 00:04:08,594
这个字符串是不区分

81
00:04:08,594 --> 00:04:11,514
字符串的这个符号是可以用单引号也可以用双引号的

82
00:04:11,514 --> 00:04:12,594
都是一样的啊

83
00:04:12,594 --> 00:04:14,594
比如说这里给一个大写的奥德罗

84
00:04:14,594 --> 00:04:16,506
< No Speech >

85
00:04:16,506 --> 00:04:18,506
啊,这转换成小写的

86
00:04:18,506 --> 00:04:23,578
< No Speech >

87
00:04:23,578 --> 00:04:25,458
是吧 转成大写欧德卢了吧

88
00:04:25,458 --> 00:04:28,898
好 那么这里还有一个知识点 同学们需要注意

89
00:04:28,898 --> 00:04:32,698
在mySQL数据库当中 对于字符串的内容

90
00:04:32,698 --> 00:04:37,378
包括数据 字符串的数据在做条件判断时

91
00:04:37,378 --> 00:04:41,578
mySQL会自动帮助我们转换大小写 什么意思

92
00:04:41,578 --> 00:04:46,098
你看 我们先看一下这个题 看一下这个示例

93
00:04:46,098 --> 00:04:50,818
现在这个示例要求显示雇员David的雇员号

94
00:04:50,818 --> 00:04:55,138
姓名和部门号 将姓名转换为大写

95
00:04:55,138 --> 00:04:57,818
我们先去查David的这个雇员啊

96
00:04:57,818 --> 00:05:04,298
select 然后他要什么 要雇员号 那就是employee下滑线ID逗号

97
00:05:04,298 --> 00:05:08,258
然后呢 还要姓名 就是这个姓 是吧

98
00:05:08,258 --> 00:05:10,258
last name是姓 first name是名 是吧

99
00:05:10,258 --> 00:05:12,030
last name

100
00:05:12,986 --> 00:05:23,386
然后还要一个部门号,部门号departmentid,department下滑线id,然后from employee

101
00:05:23,386 --> 00:05:25,018
< No Speech >

102
00:05:25,018 --> 00:05:27,018
然后VAL条件

103
00:05:27,018 --> 00:05:31,162
< No Speech >

104
00:05:31,162 --> 00:05:35,402
什么条件呢?Last name姓是David的对吧

105
00:05:36,026 --> 00:05:37,566
最后一个名字。

106
00:05:37,566 --> 00:05:39,386
< No Speech >

107
00:05:39,386 --> 00:05:45,694
注意看啊,我现在先给一个小写的

108
00:05:45,694 --> 00:05:47,098
< No Speech >

109
00:05:47,098 --> 00:05:48,138
是不是查到了

110
00:05:48,138 --> 00:05:49,578
同学们发现了吗

111
00:05:49,578 --> 00:05:52,138
实质上他的lastname的值

112
00:05:52,138 --> 00:05:53,058
这个david

113
00:05:53,058 --> 00:05:54,738
他的d是大写的

114
00:05:54,738 --> 00:05:56,698
而我现在给的是字符串

115
00:05:56,698 --> 00:05:58,098
首字母是小写的

116
00:05:58,138 --> 00:05:59,138
他也能查到

117
00:05:59,138 --> 00:05:59,898
说明什么问题

118
00:05:59,898 --> 00:06:02,298
说明mySQL

119
00:06:02,338 --> 00:06:04,618
他在帮我做数据查询时

120
00:06:04,618 --> 00:06:08,938
字符串自动做了大小写的忽略

121
00:06:08,978 --> 00:06:10,058
默认的情况下

122
00:06:10,218 --> 00:06:12,578
字符串它是会做大小写忽略的

123
00:06:12,618 --> 00:06:15,418
那么能不能让这个表的列

124
00:06:15,418 --> 00:06:18,298
严格区分大小写可以怎么做

125
00:06:18,738 --> 00:06:20,738
在你创建表时

126
00:06:20,738 --> 00:06:22,698
在这个列的定义列的时候

127
00:06:22,698 --> 00:06:24,578
后面加一个binary关键字

128
00:06:24,618 --> 00:06:27,258
那么这一列就会严格区分大小写了

129
00:06:27,298 --> 00:06:29,818
如果没有给定binary关键字

130
00:06:29,858 --> 00:06:31,098
他默认的是会

131
00:06:31,138 --> 00:06:32,778
这个列的值会忽略大小写

132
00:06:33,018 --> 00:06:34,018
明白这些东西吗

133
00:06:34,018 --> 00:06:34,698
好

134
00:06:34,698 --> 00:06:36,538
比如说我这块甚至也可以这么写

135
00:06:36,578 --> 00:06:38,578
给个大写的D大写的A

136
00:06:38,898 --> 00:06:39,618
运行

137
00:06:39,658 --> 00:06:41,018
他也能查到david

138
00:06:41,018 --> 00:06:42,018
这不忽略大小写的

139
00:06:42,018 --> 00:06:42,538
对不对

140
00:06:42,778 --> 00:06:43,498
这个我们要明白

141
00:06:43,778 --> 00:06:44,298
好

142
00:06:44,298 --> 00:06:45,978
然后接下来我们看他的需求

143
00:06:45,978 --> 00:06:48,958
他的需求是要求将姓名转化为大写

144
00:06:49,882 --> 00:06:57,022
转换为大写,转换为小写,转换为大写就不是lower了,是upper

145
00:06:57,022 --> 00:06:58,042
< No Speech >

146
00:06:58,042 --> 00:07:00,282
这个例子有问题啊 改一下

147
00:07:00,282 --> 00:07:01,594
< No Speech >

148
00:07:01,594 --> 00:07:02,194
是吧

149
00:07:02,194 --> 00:07:04,874
那这里我们是不是得用ARP这个函数去做了

150
00:07:04,874 --> 00:07:05,234
好

151
00:07:05,234 --> 00:07:06,514
我们把这个改一下

152
00:07:06,514 --> 00:07:08,874
把lastname放到哪呢

153
00:07:08,874 --> 00:07:10,674
放到ARP函数当中

154
00:07:10,674 --> 00:07:12,314
直接把列名放进去就可以了

155
00:07:12,314 --> 00:07:12,874
明白吧

156
00:07:12,874 --> 00:07:13,714
然后运行

157
00:07:13,714 --> 00:07:14,394
看到了吗

158
00:07:14,394 --> 00:07:18,834
现在这个lastname的值就被ARP函数转换成大写了

159
00:07:18,834 --> 00:07:19,234
啊

160
00:07:19,234 --> 00:07:19,794
OK

161
00:07:19,794 --> 00:07:20,274
好

162
00:07:20,274 --> 00:07:22,434
这是这个大小写处理函数

163
00:07:22,434 --> 00:07:25,114
那么在这个Mysql的字符函数当中

164
00:07:25,114 --> 00:07:26,874
除了有大小写处理函数以外

165
00:07:26,994 --> 00:07:28,674
它还有字符处理函数

166
00:07:28,674 --> 00:07:29,754
字符处理函数

167
00:07:29,754 --> 00:07:32,274
我们在开发的过程当中用的也是比较多的

168
00:07:32,474 --> 00:07:36,234
这里我给大家罗列了一些用的比较常见的

169
00:07:36,234 --> 00:07:37,274
当然还有很多

170
00:07:37,474 --> 00:07:39,194
我没有把它整理出来

171
00:07:39,234 --> 00:07:41,434
具体的那些同学们用到了

172
00:07:41,514 --> 00:07:42,234
咱们再说

173
00:07:42,554 --> 00:07:43,794
那么在这个表格当中

174
00:07:43,914 --> 00:07:46,074
这个函数的解释

175
00:07:46,194 --> 00:07:47,354
我已经说得很清楚了

176
00:07:47,474 --> 00:07:49,074
比如说我们看一个lint

177
00:07:49,274 --> 00:07:49,674
lint

178
00:07:50,314 --> 00:07:51,754
我们通过函数名也知道了

179
00:07:51,754 --> 00:07:53,274
它的作用就是返回长度的

180
00:07:53,274 --> 00:07:53,594
是吧

181
00:07:53,594 --> 00:07:54,314
返回什么呢

182
00:07:54,314 --> 00:07:56,274
你给定的这个参数的长度

183
00:07:56,394 --> 00:07:59,394
那么这个参数既然是处理字符处理函数了

184
00:07:59,394 --> 00:08:01,954
它的参数肯定是字符串类型的

185
00:08:01,954 --> 00:08:02,394
对不对

186
00:08:02,394 --> 00:08:04,314
所以返回这个字符串的一个长度

187
00:08:04,314 --> 00:08:06,874
跟我们Java里的这个lint方法的作用是相似的

188
00:08:06,874 --> 00:08:07,434
是一样的

189
00:08:07,874 --> 00:08:09,514
返回字符串S长度

190
00:08:09,794 --> 00:08:11,794
比如说返回字符串O的LU长度

191
00:08:11,794 --> 00:08:12,766
那就slacc它

192
00:08:13,338 --> 00:08:15,458
Xleng子或者是leng子都可以啊

193
00:08:15,458 --> 00:08:18,218
Xleng子也是可以返回字符串的长度啊

194
00:08:18,218 --> 00:08:21,418
这里我们用二者就两个函数记住一个就可以了

195
00:08:21,418 --> 00:08:22,846
leng子然后

196
00:08:22,846 --> 00:08:26,330
< No Speech >

197
00:08:26,330 --> 00:08:30,330
然后返回5 我们看看是不是这样 我们用一下这个函数

198
00:08:30,330 --> 00:08:33,918
selector然后length

199
00:08:33,918 --> 00:08:39,130
< No Speech >

200
00:08:39,130 --> 00:08:42,250
没问题 是不是 哎 返回它的长度 这是length函数

201
00:08:42,250 --> 00:08:44,250
然后呢 还有一个concate

202
00:08:44,250 --> 00:08:46,330
concate呢 是可以给多个参数的

203
00:08:46,330 --> 00:08:47,930
你看它后面是一个可变参数嘛

204
00:08:47,930 --> 00:08:49,850
啊 就我们家瓦里的可变参数指的

205
00:08:49,850 --> 00:08:51,610
指的是可以给多个参数

206
00:08:51,610 --> 00:08:53,530
那么这个函数的作用是什么呢

207
00:08:53,530 --> 00:08:54,850
是字符串拼接的

208
00:08:54,850 --> 00:08:57,970
可以将字符串S1 S2等多个字符串

209
00:08:57,970 --> 00:09:00,850
这个拼合拼接起来变成一个字符串

210
00:09:00,850 --> 00:09:03,450
我们用一下 你先看这个实例啊

211
00:09:03,450 --> 00:09:04,650
合并多个字符串

212
00:09:04,650 --> 00:09:05,730
selected concate

213
00:09:05,730 --> 00:09:06,890
summary time teacher

214
00:09:06,890 --> 00:09:07,810
然后odd rule

215
00:09:07,810 --> 00:09:09,650
最后结果就是上一堂teacher odd rule

216
00:09:09,650 --> 00:09:10,650
明白吧 哎

217
00:09:10,650 --> 00:09:12,410
那比如说我们这用一个啊

218
00:09:12,410 --> 00:09:13,598
concate

219
00:09:13,598 --> 00:09:15,738
< No Speech >

220
00:09:15,738 --> 00:09:16,738
制服串

221
00:09:16,738 --> 00:09:20,154
< No Speech >

222
00:09:20,154 --> 00:09:21,634
然后我就再给一个

223
00:09:21,634 --> 00:09:23,034
< No Speech >

224
00:09:23,034 --> 00:09:25,834
字符串B你可以给多个啊

225
00:09:25,834 --> 00:09:27,738
< No Speech >

226
00:09:27,738 --> 00:09:29,738
字符串C我们执行

227
00:09:29,738 --> 00:09:31,018
就会变成了ABC

228
00:09:31,018 --> 00:09:31,538
看到了吗

229
00:09:31,538 --> 00:09:32,898
或者我们也可以这么去用

230
00:09:32,898 --> 00:09:34,658
比如说我们这么去用

231
00:09:34,658 --> 00:09:35,858
Concate里面

232
00:09:35,858 --> 00:09:38,658
我们现在想把安普拉意表当中的LastName

233
00:09:38,658 --> 00:09:40,258
跟FirstName拼到一起

234
00:09:40,258 --> 00:09:40,978
怎么办呢

235
00:09:40,978 --> 00:09:43,742
那就要LastName逗号

236
00:09:43,742 --> 00:09:55,194
< No Speech >

237
00:09:55,194 --> 00:09:57,474
看到了吗?然后我们运行看结果

238
00:09:57,474 --> 00:10:02,554
现在我们看到的这个结果就是把姓跟名拼到一起以后的一个结果

239
00:10:02,554 --> 00:10:05,074
看到了吗?我们通过concate函数来拼接的

240
00:10:05,074 --> 00:10:06,594
这就是concate函数

241
00:10:06,594 --> 00:10:10,194
如果我想把salary把薪水也拼到里面可不可以呢?

242
00:10:10,194 --> 00:10:11,486
salary加到里面

243
00:10:11,486 --> 00:10:17,914
< No Speech >

244
00:10:17,914 --> 00:10:23,514
看到了吗?虽然说新水是整形,但是也可以用concate把它拼起来

245
00:10:23,514 --> 00:10:28,714
就返回一个新的字符串,没问题吧?

246
00:10:28,714 --> 00:10:31,102
好,这是concate函数的作用

247
00:10:31,770 --> 00:10:38,810
然后还有这个Lpd,这是一个左天冲,与它对应的还有一个Rpd右天冲

248
00:10:38,810 --> 00:10:41,290
就是向左侧天冲什么

249
00:10:41,290 --> 00:10:44,210
我们看一下这个函数,Lpd它需要三个参数

250
00:10:44,210 --> 00:10:48,130
第一个参数是圆串,第二个参数是支付串的总长度

251
00:10:48,130 --> 00:10:50,078
第三个是天冲什么

252
00:10:51,034 --> 00:10:54,430
比如说将伺服器X添充到ABC

253
00:10:54,430 --> 00:10:56,826
< No Speech >

254
00:10:56,826 --> 00:11:00,826
然后呢总长度看这啊

255
00:11:00,826 --> 00:11:03,386
slack的l,p,a,d,o的炉

256
00:11:03,386 --> 00:11:05,186
然后第二个参数是总长度

257
00:11:05,186 --> 00:11:07,546
注意是总长度它可不是这个

258
00:11:07,546 --> 00:11:09,706
填充多少个字符的长度啊

259
00:11:09,706 --> 00:11:11,706
是字符填完之后的总长度

260
00:11:11,706 --> 00:11:13,346
那么总长度是8

261
00:11:13,346 --> 00:11:14,386
然后呢填什么呢

262
00:11:14,386 --> 00:11:15,646
向左侧填x

263
00:11:16,218 --> 00:11:20,698
那现在odd√的长度是5 那会填几个x呢?填三个是吧

264
00:11:20,698 --> 00:11:22,526
我们来用一下 这个函数没什么难的

265
00:11:22,526 --> 00:11:25,338
< No Speech >

266
00:11:25,338 --> 00:11:27,710
Select LPAD

267
00:11:28,538 --> 00:11:29,758
第1个圆圈

268
00:11:29,758 --> 00:11:33,242
< No Speech >

269
00:11:33,242 --> 00:11:38,362
总字符串的长度,天冲完以后的长度,比如说给它一个10

270
00:11:38,362 --> 00:11:41,842
然后天字符串的内容,天冲的内容是什么

271
00:11:41,842 --> 00:11:42,846
比如说我用天冲

272
00:11:42,846 --> 00:11:45,946
< No Speech >

273
00:11:45,946 --> 00:11:47,626
看一下这是填充完的结果

274
00:11:47,626 --> 00:11:48,586
那么我们来看

275
00:11:48,586 --> 00:11:50,386
这可不是填充10个星

276
00:11:50,386 --> 00:11:51,626
很显然这不是10个星

277
00:11:51,626 --> 00:11:53,106
他填了几个 填了5个

278
00:11:53,106 --> 00:11:54,066
为什么填了5个

279
00:11:54,066 --> 00:11:55,946
因为O的卢本身长度也是5

280
00:11:55,946 --> 00:11:58,066
加起来的总长度是10

281
00:11:58,066 --> 00:12:03,106
所以说这个参数是定义字符串填充完以后的总长度是多少

282
00:12:03,106 --> 00:12:03,866
明白这意思吧

283
00:12:03,866 --> 00:12:06,386
然后你看它的星是在哪填的

284
00:12:06,386 --> 00:12:08,286
在你的这个内容的左侧

285
00:12:08,286 --> 00:12:10,746
< No Speech >

286
00:12:10,746 --> 00:12:12,026
看到了吗 左侧天冲

287
00:12:12,026 --> 00:12:13,266
所以我们叫左天冲

288
00:12:13,266 --> 00:12:15,226
还有一个叫RPD

289
00:12:15,226 --> 00:12:17,054
Right在右侧天冲

290
00:12:17,054 --> 00:12:18,842
< No Speech >

291
00:12:18,842 --> 00:12:20,830
在你的内容的右侧填充

292
00:12:21,690 --> 00:12:23,730
这是LPD跟RPD

293
00:12:23,730 --> 00:12:25,274
< No Speech >

294
00:12:25,274 --> 00:12:32,954
然后还有一个Ltrim,trim指的是什么?是不是去掉空格啊?那么Ltrim指的就是去掉左侧空格

295
00:12:32,954 --> 00:12:37,514
去掉字符串的左侧的空格,比如说Otteroo,Select,Ltrim

296
00:12:37,514 --> 00:12:37,886
然后

297
00:12:38,554 --> 00:12:40,154
左侧空格就会被打去掉

298
00:12:40,154 --> 00:12:41,154
没问题吧

299
00:12:41,154 --> 00:12:41,954
这个我就不用试了

300
00:12:41,954 --> 00:12:42,686
这比较简单

301
00:12:43,610 --> 00:12:48,290
还有replace替换,这个replace替换它需要几个参数?

302
00:12:48,290 --> 00:12:52,370
这个参数我们说一下,它需要三个参数

303
00:12:52,370 --> 00:12:57,010
第一个参数是原串,第二个参数是需要替换哪个内容

304
00:12:57,010 --> 00:12:59,582
第三个参数是替换什么?

305
00:13:00,410 --> 00:13:02,366
比如说我们把这个copy过来看一下

306
00:13:02,366 --> 00:13:06,970
< No Speech >

307
00:13:06,970 --> 00:13:08,970
第一个差数是圆串 我给的o的卢

308
00:13:08,970 --> 00:13:12,970
我现在要把o的卢当中的小写的o换成大写的o

309
00:13:12,970 --> 00:13:16,122
< No Speech >

310
00:13:16,122 --> 00:13:17,402
换成什么

311
00:13:18,234 --> 00:13:22,274
你们这一次把替换哪个字符替换成什么我们运行

312
00:13:22,906 --> 00:13:24,586
看到了吗 是不是变成大写的了

313
00:13:24,586 --> 00:13:28,670
那如果这里有多个O呢 它所有的O都会被替换

314
00:13:28,670 --> 00:13:29,850
< No Speech >

315
00:13:29,850 --> 00:13:33,930
明白了同学们,这是replace这个函数的一个使用啊

316
00:13:33,930 --> 00:13:40,890
然后呢还有这个reverse,reverse什么?反转呗,reverse反转嘛

317
00:13:40,890 --> 00:13:44,730
那就把ABC给他,他反过来就是CBA,这比较简单,我就不试了

318
00:13:44,730 --> 00:13:48,350
然后还有一个RPD,RPD我们已经试过了,又添冲嘛

319
00:13:48,350 --> 00:13:50,522
< No Speech >

320
00:13:50,522 --> 00:14:00,442
好,还有一个R-trim,R-trim指的就是去去掉右侧的空格,L是去掉左侧的空格,R是去掉右侧的空格,这也就不说了

321
00:14:00,442 --> 00:14:04,094
然后还有一个substr,substr呢?

322
00:14:04,762 --> 00:14:08,962
它的作用跟我们加瓦里的substitute是一样的,就是截几串的

323
00:14:08,962 --> 00:14:12,242
它的作用是这样的,我们看到它有三个参数

324
00:14:12,242 --> 00:14:16,642
第一个参数是圆串,第二个参数是从哪个位置开始截

325
00:14:16,642 --> 00:14:19,646
第三个参数是截多少个的长度

326
00:14:20,634 --> 00:14:23,594
然后它的查述是从1开始的

327
00:14:23,594 --> 00:14:25,074
比如现在这个案例

328
00:14:25,074 --> 00:14:26,558
我们把它copy过来啊

329
00:14:26,558 --> 00:14:30,906
< No Speech >

330
00:14:30,906 --> 00:14:33,666
这里我要去对O的卢做子串的截取

331
00:14:33,666 --> 00:14:35,506
然后从第二位开始截

332
00:14:35,506 --> 00:14:37,186
它的查数是从1开始的

333
00:14:37,186 --> 00:14:39,106
这是第一个字符 这是第二个字符

334
00:14:39,106 --> 00:14:40,706
那就从L开始截

335
00:14:40,706 --> 00:14:43,386
截多少个呢?截三位 截三个长度

336
00:14:43,386 --> 00:14:43,966
那就好 confiscate

337
00:14:43,966 --> 00:14:47,898
< No Speech >

338
00:14:47,898 --> 00:14:58,270
比如说现在我想从D开始接,接到L就只想保留DL,那么D是3

339
00:14:58,810 --> 00:15:00,894
对吧 接完长度是几呢 是2

340
00:15:00,894 --> 00:15:03,226
< No Speech >

341
00:15:03,226 --> 00:15:06,906
明白了吗?这是substr的作用

342
00:15:06,906 --> 00:15:09,306
与之对应的也有一个substr

343
00:15:09,306 --> 00:15:12,106
substr跟substr的作用是相同的

344
00:15:12,106 --> 00:15:15,626
这都是一样的,只是有两个函数可以解决这个问题

345
00:15:15,626 --> 00:15:17,106
然后还有一个就是trim

346
00:15:17,106 --> 00:15:19,586
trim如果没有r也没有l

347
00:15:19,586 --> 00:15:23,262
就叫trim,那说明是去掉首尾两侧的空格

348
00:15:24,090 --> 00:15:26,490
明白这意思吧?这是这个trim函数的作用

349
00:15:26,490 --> 00:15:29,090
那么对于字符处理的函数我们已经讲了很多了

350
00:15:29,090 --> 00:15:31,330
这些函数每一个我们都做介绍了是吧

351
00:15:31,330 --> 00:15:32,810
并不是很难的事

352
00:15:32,810 --> 00:15:34,210
好我们来看一个示例

353
00:15:34,210 --> 00:15:39,010
示例要求显示所有工作岗位名称

354
00:15:39,010 --> 00:15:41,970
从第4个字符位置开始

355
00:15:41,970 --> 00:15:43,486
包含字符串

356
00:15:44,058 --> 00:15:54,138
REP的雇员的ID信息将雇员的姓和名连接在一起,还显示雇员的名字的长度以及字母中的A的位置

357
00:15:54,842 --> 00:15:56,062
哦,我们看一下

358
00:15:56,826 --> 00:15:59,186
这个需求还是很长的 是吧

359
00:15:59,186 --> 00:16:01,986
那么这里有一个需求我们可能不会做

360
00:16:01,986 --> 00:16:03,986
哪个呢?就是这个字母a的位置

361
00:16:03,986 --> 00:16:06,986
字母a的位置啊 这里我们会用到一个函数叫什么呢?

362
00:16:06,986 --> 00:16:08,254
叫inHTL

363
00:16:08,890 --> 00:16:14,970
int str它会返回,它需要两个参数,一个是内容,一个是子串

364
00:16:14,970 --> 00:16:21,130
它会返回这个子串在这个名字当中,在这个内容当中出现的第一次出现的位置

365
00:16:21,130 --> 00:16:24,890
明白这意思吧?这是这个int str函数的一个作用

366
00:16:24,890 --> 00:16:27,770
这里我就不把它写到这里,大家知道就行

367
00:16:27,770 --> 00:16:31,102
那我们看对于这样的一个需求我们怎么做呢?

368
00:16:31,642 --> 00:16:35,402
首先我们看他要查询的条件是什么?

369
00:16:35,402 --> 00:16:44,670
他要查询的条件是,Job ID就是他的工作岗位从第四个字符位置开始,包含REP的雇员。

370
00:16:44,670 --> 00:16:45,690
< No Speech >

371
00:16:45,690 --> 00:16:47,530
那我们是不是得去截纸串了

372
00:16:47,530 --> 00:16:49,130
我们看一下他的工作岗位啊

373
00:16:49,130 --> 00:16:52,378
< No Speech >

374
00:16:52,378 --> 00:16:54,378
工作岗位是什么?是不是?

375
00:16:54,378 --> 00:16:56,026
< No Speech >

376
00:16:56,026 --> 00:16:57,626
Job ID 是吧

377
00:16:58,618 --> 00:17:00,058
我们查一下jobID

378
00:17:00,058 --> 00:17:01,238
wrong

379
00:17:01,238 --> 00:17:03,546
< No Speech >

380
00:17:03,546 --> 00:17:07,226
你看他的工作岗位是字符串类型

381
00:17:07,226 --> 00:17:10,386
然后里面有这些工作岗位的编码编号

382
00:17:10,386 --> 00:17:12,306
是吧有这些工作岗位的编号

383
00:17:12,306 --> 00:17:17,426
然后他要求这个工作岗位他的第四位开始

384
00:17:17,426 --> 00:17:22,386
substr第四位是rep的

385
00:17:22,386 --> 00:17:25,186
有人说老师这里少一个参数只给了两个

386
00:17:25,186 --> 00:17:28,306
是的如果少一个参数没给哪个没给截多少位

387
00:17:28,306 --> 00:17:31,466
那就是从第四位开始截到末尾

388
00:17:31,466 --> 00:17:37,306
明白这意思吧我们看一下12341234

389
00:17:37,306 --> 00:17:39,906
从这开始截1234然后截

390
00:17:39,906 --> 00:17:43,186
反正最后截完的结果是rep的

391
00:17:43,186 --> 00:17:46,146
那么对于这样的条件我们是不是也可以先定义出来

392
00:17:46,146 --> 00:17:48,606
比如说在这里加

393
00:17:48,606 --> 00:17:50,362
< No Speech >

394
00:17:50,362 --> 00:17:53,242
什么呢?SAR版STR

395
00:17:54,106 --> 00:18:03,706
对谁做截取呢?对JobID做截取,从哪开始截呢?从第四位开始截,截多少呢?截到末尾

396
00:18:03,706 --> 00:18:06,186
对不对?好,我们运行

397
00:18:06,186 --> 00:18:08,746
哦,这个JobID

398
00:18:08,746 --> 00:18:09,946
< No Speech >

399
00:18:09,946 --> 00:18:10,966
看一下

400
00:18:10,966 --> 00:18:14,138
< No Speech >

401
00:18:14,138 --> 00:18:16,538
呃,Job ID

402
00:18:16,538 --> 00:18:18,554
< No Speech >

403
00:18:18,554 --> 00:18:21,234
我们换一个Employee ID

404
00:18:21,234 --> 00:18:22,938
< No Speech >

405
00:18:22,938 --> 00:18:23,938
也没有

406
00:18:23,938 --> 00:18:27,450
< No Speech >

407
00:18:27,450 --> 00:18:29,570
这我给错了 没给完呢

408
00:18:29,570 --> 00:18:32,922
< No Speech >

409
00:18:32,922 --> 00:18:34,398
下滑械ID

410
00:18:35,066 --> 00:18:38,266
截第四位等于,没给条件呢是吧,是谁呢

411
00:18:38,266 --> 00:18:41,950
是我们看一下是REP的

412
00:18:42,714 --> 00:18:44,414
大写的REP

413
00:18:45,306 --> 00:18:47,546
当然我写小写的也没有问题是吧

414
00:18:47,546 --> 00:18:50,906
你看我换成小写的,REP

415
00:18:50,906 --> 00:18:52,154
< No Speech >

416
00:18:52,154 --> 00:18:53,874
也没有问题 是不是

417
00:18:53,874 --> 00:18:54,906
< No Speech >

418
00:18:54,906 --> 00:18:55,906
REP

419
00:18:55,906 --> 00:18:57,178
< No Speech >

420
00:18:57,178 --> 00:19:05,658
那么现在查到了这个部门以后,查到了这个部门编号以后,他要干嘛呢?我们看一下啊

421
00:19:05,658 --> 00:19:13,470
包含Zfuture REP雇员的ID信息,好ID信息,那我们接着往下给

422
00:19:13,470 --> 00:19:17,402
< No Speech >

423
00:19:17,402 --> 00:19:18,682
安普拉EID吧

424
00:19:18,682 --> 00:19:21,242
< No Speech >

425
00:19:21,242 --> 00:19:29,362
然后还有将固原的姓和名连接在一起 连接是不是要用到concate函数了

426
00:19:29,362 --> 00:19:36,242
姓和名 姓是反了 last name是姓 first name是名

427
00:19:36,242 --> 00:19:40,414
国外的名字不是姓在前 姓在后吗

428
00:19:40,414 --> 00:19:42,202
< No Speech >

429
00:19:42,202 --> 00:19:46,042
那我们这写一下 这个是 last name

430
00:19:46,042 --> 00:19:49,310
然后这个是 first name

431
00:19:49,310 --> 00:19:51,578
< No Speech >

432
00:19:51,578 --> 00:20:00,778
OK对吧 然后还要什么 还显示顾元明的长度 顾元明的长度 last name

433
00:20:00,778 --> 00:20:03,194
< No Speech >

434
00:20:03,194 --> 00:20:05,154
那就是lens对吧

435
00:20:05,154 --> 00:20:05,794
lens函数

436
00:20:05,794 --> 00:20:08,514
然后呢把lastname放到里面

437
00:20:09,434 --> 00:20:15,834
对吧 然后还要什么 还显示雇员的名字长度以及名字中间字母a的位置

438
00:20:15,834 --> 00:20:21,434
显示某个字母a的位置 显示某个位置 这里我们是要我们是不是要用到这个

439
00:20:21,434 --> 00:20:29,246
in cr函数了是吧in str函数了对吧 然后这里给last name

440
00:20:29,246 --> 00:20:31,098
< No Speech >

441
00:20:31,098 --> 00:20:32,414
然后呢这里给

442
00:20:32,414 --> 00:20:33,722
< No Speech >

443
00:20:33,722 --> 00:20:34,974
A的位置

444
00:20:34,974 --> 00:20:36,122
< No Speech >

445
00:20:36,122 --> 00:20:41,002
是吧 这样我们就可以查到内容了 当然这里还有一个别名

446
00:20:41,002 --> 00:20:42,362
< No Speech >

447
00:20:42,362 --> 00:20:45,726
拿过来那么这个别名我再说一下同学们啊

448
00:20:45,726 --> 00:20:47,290
< No Speech >

449
00:20:47,290 --> 00:20:52,570
如果你的别名是一个正常的字符串,那正常写就可以了

450
00:20:52,570 --> 00:20:56,062
如果你的别名里还有空格,还有像这种特殊符号

451
00:20:56,698 --> 00:20:59,778
特殊符号你必须要把它加到双引号当中

452
00:20:59,778 --> 00:21:00,818
明白这意思吧

453
00:21:00,818 --> 00:21:02,258
来保证它的格式不变

454
00:21:02,258 --> 00:21:02,878
否则会有问题

455
00:21:03,642 --> 00:21:04,882
好,我们运行

456
00:21:04,882 --> 00:21:06,882
好,我们看一下

457
00:21:06,882 --> 00:21:09,466
< No Speech >

458
00:21:09,466 --> 00:21:12,958
另一次,啊,这儿少了一个逗号

459
00:21:12,958 --> 00:21:14,938
< No Speech >

460
00:21:14,938 --> 00:21:16,638
这也少了一个逗号

461
00:21:17,402 --> 00:21:18,654
好 运行

462
00:21:18,654 --> 00:21:22,586
< No Speech >

463
00:21:22,586 --> 00:21:24,386
还能少一个逗号

464
00:21:24,386 --> 00:21:30,586
< No Speech >

465
00:21:30,586 --> 00:21:36,386
这位可以查到了是吧 我们可以看到 这是这个姓和名拼完以后的

466
00:21:36,386 --> 00:21:39,706
然后这个是叫拜的啊 是2EP的是吧

467
00:21:39,706 --> 00:21:43,186
然后呢 名字的长度啊 就这个姓的长度是6

468
00:21:43,186 --> 00:21:48,426
然后他的姓当中有A的 如果是有A的话 A是第几位

469
00:21:48,426 --> 00:21:52,666
第几个A是出现的 第一次出现的位置是G 是吧

470
00:21:52,666 --> 00:21:54,826
哎 这样可以查到这个数据了啊

471
00:21:54,826 --> 00:22:02,506
这就是我们通过一个综合的案例 去进一步的详解了一下关于这个字符函数的一个处理

472
00:22:02,506 --> 00:22:08,506
其实这个字符函数呢 很简单的 我们只要记住它的这个函数的名以及函数的特点就可以了

473
00:22:08,506 --> 00:22:13,226
那么至于那些记不住的 我们现用现查吧 不可能把所有的函数都记住 对不对

474
00:22:13,226 --> 00:22:15,230
好 同学们 那我们接下来呢

